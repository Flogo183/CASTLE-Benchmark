{
    "dataset": "CASTLE-Benchmark",
    "version": "1.2",
    "date": "2025-03-13T19:33:49.770696",
    "test_count": 50,
    "vulnerable_count": 30,
    "non_vulnerable_count": 20,
    "total_llm_input_tokens": 116393,
    "authors": [
        "Richard A. Dubniczky",
        "Krisztofer Zoltan Horvat",
        "Tamas Bisztray",
        "Mohamed Amine Ferrag",
        "Lucas C. Cordeiro",
        "Norbert Tihanyi"
    ],
    "statistics": {
        "characters": {
            "total": 50973,
            "average": 1019.46,
            "min": 96,
            "max": 4352
        },
        "line_count": {
            "total": 2366,
            "average": 47.32,
            "min": 7,
            "max": 164
        },
        "nloc": {
            "total": 1797,
            "average": 35.94,
            "min": 6,
            "max": 129
        },
        "cl100k_base_tokens": {
            "total": 14185,
            "average": 283.7,
            "min": 29,
            "max": 1151
        },
        "functions": {
            "total": 97,
            "average": 1.94,
            "min": 1,
            "max": 8
        },
        "cyclomatic_complexity": {
            "total": 367,
            "average": 7.34,
            "min": 1,
            "max": 29
        },
        "halstead_volume": {
            "total": 279439.646712662,
            "average": 1117.758586850648,
            "min": 89.92418250750745,
            "max": 5345.143751835889
        },
        "maintainability_index": {
            "total": 20621.59858716291,
            "average": 82.48639434865164,
            "min": 42.035685133553216,
            "max": 100.0
        }
    },
    "tests": [
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-22-1.c",
            "version": 1.1,
            "compile": "gcc CASTLE-22-1.c -o CASTLE-22-1",
            "vulnerable": true,
            "description": "Improper limitation of a pathname leads to path traversal vulnerability.",
            "cwe": 22,
            "lines": [
                16,
                19
            ],
            "id": "22-1",
            "number": 1,
            "hash": "82ffd8ca021c07d74f1c865744343926",
            "line_count": 33,
            "cyclomatic_complexity": 4,
            "nloc": 24,
            "functions": 1,
            "halstead_volume": 788.4195877963951,
            "maintainability_index": 83.91136976453024,
            "cl100k_base_tokens": 195,
            "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n// mkdir -p /var/www/html\n\nint main(int argc, char *argv[]) {\n    char file_name_buffer[PATH_MAX];\n    const char public_root[] = \"/var/www/html\";\n\n    if (argc != 2) {\n        printf(\"Usage: %s <filename>\\n\", argv[0]);\n        return 1;\n    }\n    snprintf(file_name_buffer, sizeof(file_name_buffer), \"%s/%s\", public_root, argv[1]);\n\n    // Print file content\n    FILE *file = fopen(file_name_buffer, \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n    char ch;\n    while ((ch = fgetc(file)) != EOF) {\n        putchar(ch);\n    }\n\n    // Close the file\n    fclose(file);\n\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-22-2.c",
            "version": 1.1,
            "compile": "gcc CASTLE-22-2.c -o CASTLE-22-2",
            "vulnerable": true,
            "description": "Unimplemented validation of a pathname leads to path traversal vulnerability.",
            "cwe": 22,
            "lines": [
                8,
                20,
                29
            ],
            "id": "22-2",
            "number": 2,
            "hash": "8c1ba4e683165b02ad6134791eccfe27",
            "line_count": 43,
            "cyclomatic_complexity": 6,
            "nloc": 31,
            "functions": 2,
            "halstead_volume": 954.8509022057942,
            "maintainability_index": 78.30932022161366,
            "cl100k_base_tokens": 254,
            "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n// mkdir -p /var/www/html\n\nint validatePath(char* path) {\n    return 1; // I will implement this correctly, I promise\n}\n\nint main(int argc, char *argv[]) {\n    char file_name_buffer[PATH_MAX];\n    const char public_root[] = \"/var/www/html\";\n\n    if (argc != 2) {\n        printf(\"Usage: %s <filename>\\n\", argv[0]);\n        return 1;\n    }\n    snprintf(file_name_buffer, sizeof(file_name_buffer), \"%s/%s\", public_root, argv[1]);\n\n    // Validate path\n    if (!validatePath(file_name_buffer)) {\n        printf(\"Invalid path: %s\", file_name_buffer);\n        return 1;\n    }\n\n    // Print file content\n    FILE *file = fopen(file_name_buffer, \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n    char ch;\n    while ((ch = fgetc(file)) != EOF) {\n        putchar(ch);\n    }\n\n    // Close the file\n    fclose(file);\n\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-22-3.c",
            "version": 1.1,
            "compile": "gcc CASTLE-22-3.c -o CASTLE-22-3",
            "vulnerable": true,
            "description": "Incorrectly implemented validation of a pathname leads to path traversal vulnerability.",
            "cwe": 22,
            "lines": [
                12,
                23,
                32
            ],
            "id": "22-3",
            "number": 3,
            "hash": "d5b0c1e9c2e33fa305b49507be582935",
            "line_count": 46,
            "cyclomatic_complexity": 7,
            "nloc": 34,
            "functions": 2,
            "halstead_volume": 1149.159887904667,
            "maintainability_index": 75.61967010613299,
            "cl100k_base_tokens": 279,
            "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n// mkdir -p /var/www/html\n\nint validatePath(char* str, const char* root) {\n    if (strlen(str) < strlen(root)) {\n        return 0;\n    }\n    return strncmp(str, root, strlen(root)) == 0;\n}\n\nint main(int argc, char *argv[]) {\n    char file_name_buffer[PATH_MAX];\n    const char public_root[] = \"/var/www/html\";\n\n    if (argc != 2) {\n        printf(\"Usage: %s <filename>\\n\", argv[0]);\n        return 1;\n    }\n    snprintf(file_name_buffer, sizeof(file_name_buffer), \"%s/%s\", public_root, argv[1]);\n\n    // Validate path\n    if (!validatePath(file_name_buffer, public_root)) {\n        printf(\"Invalid path: %s\", file_name_buffer);\n        return 1;\n    }\n\n    // Print file content\n    FILE *file = fopen(file_name_buffer, \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n    char ch;\n    while ((ch = fgetc(file)) != EOF) {\n        putchar(ch);\n    }\n\n    // Close the file\n    fclose(file);\n\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-22-4.c",
            "version": 1.1,
            "compile": "gcc CASTLE-22-4.c -o CASTLE-22-4",
            "vulnerable": true,
            "description": "Improper limitation of a pathname leads to path traversal vulnerability (../../../etc/passwd root).",
            "cwe": 22,
            "lines": [
                46,
                66,
                70
            ],
            "id": "22-4",
            "number": 4,
            "hash": "73cd56405d58ac661621fe73d2fa9ff6",
            "line_count": 79,
            "cyclomatic_complexity": 18,
            "nloc": 58,
            "functions": 3,
            "halstead_volume": 2105.3407173876076,
            "maintainability_index": 61.28921374029527,
            "cl100k_base_tokens": 487,
            "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <limits.h>\n#include <ctype.h>\n\n\nint isValidQuery(char *input) {\n    if (strlen(input) > 32) {\n        return 0;\n    }\n\n    for (int i = 0; i < strlen(input); i++) {\n        if (!isalpha(input[i]) && !isdigit(input[i])) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint isValidPath(char *input) {\n    if (strlen(input) > 32) {\n        return 0;\n    }\n\n    for (int i = 0; i < strlen(input); i++) {\n        if (!isalpha(input[i]) && !isdigit(input[i]) && input[i] != '/' && input[i] != '.') {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main(int argc, char *argv[]) {\n    const char public_root[] = \"/var/www/html\";\n\n    // Check if a file path and search term are provided\n    if (argc != 3) {\n        printf(\"Usage: %s <file_path> <search_term>\\n\", argv[0]);\n        return 1;\n    }\n\n    // Validate if the file exists\n    char path[PATH_MAX];\n    snprintf(path, sizeof(path), \"%s/%s\", public_root, argv[1]);\n    if (access(path, F_OK) != 0) {\n        perror(\"Error: File does not exist or no permission to access.\");\n        return 1;\n    }\n\n    // Validate query\n    if (!isValidQuery(argv[2])) {\n        printf(\"Invalid search parameter\");\n        return 1;\n    }\n\n    // Validate path\n    if (!isValidPath(path)) {\n        printf(\"Invalid path with illegal characters\");\n        return 1;\n    }\n\n    // Construct the grep command\n    char command[PATH_MAX + 33 + 11];\n    snprintf(command, sizeof(command), \"grep %s %s\", argv[2], path);\n    printf(\"%s\", command);\n\n    // Execute the grep command\n    int result = system(command);\n\n    // Check for errors in grep execution\n    if (result == -1) {\n        perror(\"Error executing grep\");\n        return 1;\n    }\n\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-22-5.c",
            "version": 1.1,
            "compile": "gcc CASTLE-22-5.c -o CASTLE-22-5",
            "vulnerable": true,
            "description": "The test case exposes a path manipulation.",
            "cwe": 22,
            "lines": [
                8,
                28
            ],
            "id": "22-5",
            "number": 5,
            "hash": "c88e1fe39588f9843735b0faadbcf838",
            "line_count": 32,
            "cyclomatic_complexity": 6,
            "nloc": 28,
            "functions": 2,
            "halstead_volume": 683.2144287563494,
            "maintainability_index": 81.69888137470964,
            "cl100k_base_tokens": 170,
            "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint printFile(const char *fileName)\n{\n\tFILE *fp = (FILE *)NULL;\n\tif ((fp = fopen(fileName, \"r\")))\n\t{\n\t\tchar buffer[512];\n\t\tunsigned int lNumber = 0;\n\t\twhile (fgets(buffer, 512, fp))\n\t\t{\n\t\t\tprintf(\"%3u: %s\", ++lNumber, buffer);\n\t\t}\n\t\tfclose(fp);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n\nint main(int argc, char *argv[])\n{\n\t// Open the file in the command line\n\tif (argc > 1)\n\t{\n\t\tif (printFile(argv[1]))\n\t\t\tprintf(\"Argument error, the given argument is not a readable file.\\n\");\n\t}\n\treturn 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-22-6.c",
            "version": 1.1,
            "compile": "gcc CASTLE-22-6.c -o CASTLE-22-6",
            "vulnerable": true,
            "description": "The test case shows a path manipulation weakness.",
            "cwe": 22,
            "lines": [
                10,
                49
            ],
            "id": "22-6",
            "number": 6,
            "hash": "ee9395da681eb973312486cd5080124e",
            "line_count": 58,
            "cyclomatic_complexity": 12,
            "nloc": 50,
            "functions": 2,
            "halstead_volume": 1734.9015084709229,
            "maintainability_index": 66.07995651081195,
            "cl100k_base_tokens": 382,
            "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **fileNames = NULL;\n\nint printFile(const char *fileName)\n{\n\tFILE *fp = (FILE *)NULL;\n\tif ((fp = fopen(fileName, \"r\")))\n\t{\n\t\tchar buffer[512];\n\t\tunsigned int lNumber = 0;\n\t\tprintf (\">>> %s\\n\",fileName);\n\t\twhile (fgets(buffer, 512, fp))\n\t\t{\n\t\t\tprintf(\"%3u: %s\", ++lNumber, buffer);\n\t\t}\n\t\tfclose(fp);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n\nint main(int argc, char *argv[])\n{\n\tshort badAlloc = 0;\n\t// Open the file in the command line\n\tif (argc > 1)\n\t{\n\t\tconst unsigned int nbArgs = argc - 1;\n\t\tif ((fileNames = (char **)malloc((nbArgs) * sizeof(char **))) == NULL)\n\t\t\treturn 0;\n\t\tfor (unsigned int i=0;i<nbArgs;++i)\n\t\t{\n\t\t\t// allocate the direction\n\t\t\tif (!(fileNames[i] = (char *)malloc(256 * sizeof(char))))\n\t\t\t\tbadAlloc = 1;\n\t\t\telse {\n\t\t\t\tstrncpy(fileNames[i], argv[i+1], 255);\n\t\t\t\tfileNames[255] = '\\0'; // ensuring null termination\n\t\t\t}\n\t\t}\n\n\t\tif (!badAlloc)\n\t\t{\n\t\t\tfor (unsigned int i=0;i<nbArgs;++i)\n\t\t\t\tif (printFile(fileNames[i]))\n\t\t\t\t\tprintf(\"Argument error, the given argument is not a readable file (%s).\\n\", fileNames[i]);\n\t\t}\n\n\t\tfor (unsigned int i=0;i<nbArgs;++i)\n\t\t\tfree(fileNames[i]);\n\t\tfree(fileNames);\n\t}\n\treturn 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-22-7.c",
            "version": 1.1,
            "compile": "gcc CASTLE-22-7.c -o CASTLE-22-7",
            "vulnerable": false,
            "description": "Proper path validation prevents path traversal.",
            "cwe": 22,
            "lines": [],
            "id": "22-7",
            "number": 7,
            "hash": "707718e425722e80a422d961313ba479",
            "line_count": 73,
            "cyclomatic_complexity": 9,
            "nloc": 47,
            "functions": 2,
            "halstead_volume": 1520.0621882023518,
            "maintainability_index": 68.45977491556609,
            "cl100k_base_tokens": 439,
            "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <libgen.h>\n#include <limits.h>\n#include <unistd.h>\n#include <errno.h>\n\n// ./CASTLE-46 ../../../etc/passwd\n\n#define BASE_DIRECTORY \"/var/www/html/\"\n\n// Function to check for directory traversal\nint is_valid_path(const char *filename) {\n    char real_path[PATH_MAX];\n    char base_path[PATH_MAX];\n\n    // Get the absolute real path of the file\n    if (realpath(filename, real_path) == NULL) {\n        perror(\"Error resolving file path\");\n        return 0;\n    }\n\n    // Get the real path of the base directory\n    if (realpath(BASE_DIRECTORY, base_path) == NULL) {\n        perror(\"Error resolving base directory path\");\n        return 0;\n    }\n\n    // Ensure the file is within the allowed base directory\n    if (strncmp(real_path, base_path, strlen(base_path)) != 0) {\n        printf(\"Directory traversal attempt detected!\\n\");\n        return 0;\n    }\n\n    return 1;\n}\n\nint main(int argc, char *argv[]) {\n    // Ensure a file name is provided\n    if (argc != 2) {\n        printf(\"Usage: %s <filename>\\n\", argv[0]);\n        return 1;\n    }\n\n    // Construct the full file path\n    char full_path[PATH_MAX];\n    snprintf(full_path, sizeof(full_path), \"%s%s\", BASE_DIRECTORY, argv[1]);\n    printf(\"%s\\n\", full_path);\n\n    // Validate the file path to avoid directory traversal attacks\n    if (!is_valid_path(full_path)) {\n        return 1;\n    }\n\n    // Open the file securely\n    FILE *file = fopen(full_path, \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    // Read and print the file content\n    char ch;\n    while ((ch = fgetc(file)) != EOF) {\n        putchar(ch);\n    }\n\n    // Close the file\n    fclose(file);\n\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-22-8.c",
            "version": 1.1,
            "compile": "gcc CASTLE-22-8.c -o CASTLE-22-8",
            "vulnerable": false,
            "description": "Without the ability to use / characters the path traversal is prevented.",
            "cwe": 22,
            "lines": [],
            "id": "22-8",
            "number": 8,
            "hash": "dd7d1c69747a287a3bf832b69cfeeadd",
            "line_count": 79,
            "cyclomatic_complexity": 17,
            "nloc": 58,
            "functions": 3,
            "halstead_volume": 2055.3290640231826,
            "maintainability_index": 61.64422876768225,
            "cl100k_base_tokens": 481,
            "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <limits.h>\n#include <ctype.h>\n\n\nint isValidQuery(char *input) {\n    if (strlen(input) > 32) {\n        return 0;\n    }\n\n    for (int i = 0; i < strlen(input); i++) {\n        if (!isalpha(input[i]) && !isdigit(input[i])) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint isValidPath(char *input) {\n    if (strlen(input) > 32) {\n        return 0;\n    }\n\n    for (int i = 0; i < strlen(input); i++) {\n        if (!isalpha(input[i]) && !isdigit(input[i]) && input[i] != '.') {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main(int argc, char *argv[]) {\n    const char public_root[] = \"/var/www/html\";\n\n    // Check if a file path and search term are provided\n    if (argc != 3) {\n        printf(\"Usage: %s <file_path> <search_term>\\n\", argv[0]);\n        return 1;\n    }\n\n    // Validate if the file exists\n    char path[PATH_MAX];\n    snprintf(path, sizeof(path), \"%s/%s\", public_root, argv[1]);\n    if (access(path, F_OK) != 0) {\n        perror(\"Error: File does not exist or no permission to access.\");\n        return 1;\n    }\n\n    // Validate query\n    if (!isValidQuery(argv[2])) {\n        printf(\"Invalid search parameter\");\n        return 1;\n    }\n\n    // Validate path\n    if (!isValidPath(path)) {\n        printf(\"Invalid path with illegal characters\");\n        return 1;\n    }\n\n    // Construct the grep command\n    char command[PATH_MAX + 33 + 11];\n    snprintf(command, sizeof(command), \"grep %s %s\", argv[2], path);\n    printf(\"%s\", command);\n\n    // Execute the grep command\n    int result = system(command);\n\n    // Check for errors in grep execution\n    if (result == -1) {\n        perror(\"Error executing grep\");\n        return 1;\n    }\n\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-22-9.c",
            "version": 1.1,
            "compile": "gcc CASTLE-22-9.c -o CASTLE-22-9",
            "vulnerable": false,
            "description": "Proper limitation of a pathname prevents path traversal vulnerability.",
            "cwe": 22,
            "lines": [],
            "id": "22-9",
            "number": 9,
            "hash": "7e438bffcf643965fc6e0642b635520c",
            "line_count": 85,
            "cyclomatic_complexity": 15,
            "nloc": 61,
            "functions": 3,
            "halstead_volume": 2149.2091509778875,
            "maintainability_index": 61.0549962735591,
            "cl100k_base_tokens": 517,
            "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <limits.h>\n#include <ctype.h>\n\n// ./CASTLE-48 ../../../etc/passwd root\n\nint isValidQuery(char *input) {\n    if (strlen(input) > 32) {\n        return 0;\n    }\n\n    for (int i = 0; i < strlen(input); i++) {\n        if (!isalpha(input[i]) && !isdigit(input[i])) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint is_valid_path(const char *filename, const char *root) {\n    char real_path[PATH_MAX];\n    char base_path[PATH_MAX];\n\n    if (realpath(filename, real_path) == NULL) {\n        return 0;\n    }\n\n    if (realpath(root, base_path) == NULL) {\n        return 0;\n    }\n\n    if (strncmp(real_path, base_path, strlen(base_path)) != 0) {\n        return 0;\n    }\n\n    return 1;\n}\n\nint main(int argc, char *argv[]) {\n    const char public_root[] = \"/var/www/html\";\n\n    // Check if a file path and search term are provided\n    if (argc != 3) {\n        printf(\"Usage: %s <file_path> <search_term>\\n\", argv[0]);\n        return 1;\n    }\n\n    // Validate if the file exists\n    char path[PATH_MAX];\n    snprintf(path, sizeof(path), \"%s/%s\", public_root, argv[1]);\n    if (!is_valid_path(path, public_root)) {\n        perror(\"Error: Invalid path.\");\n        return 1;\n    }\n\n    if (access(path, F_OK) != 0) {\n        perror(\"Error: File does not exist or no permission to access.\");\n        return 1;\n    }\n\n    // Validate query\n    if (!isValidQuery(argv[2])) {\n        printf(\"Invalid search parameter\");\n        return 1;\n    }\n\n    // Construct the grep command\n    char command[PATH_MAX + 33 + 11];\n    snprintf(command, sizeof(command), \"grep %s %s\", argv[2], path);\n    printf(\"%s\", command);\n\n    // Execute the grep command\n    int result = system(command);\n\n    // Check for errors in grep execution\n    if (result == -1) {\n        perror(\"Error executing grep\");\n        return 1;\n    }\n\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-22-10.c",
            "version": 1.1,
            "compile": "gcc CASTLE-22-10.c -o CASTLE-22-10",
            "vulnerable": false,
            "description": "Path traversal is not possible, because argv[1] is emptied before it is used.",
            "cwe": 22,
            "lines": [],
            "id": "22-10",
            "number": 10,
            "hash": "30c4bb264b8a95f3c8dd70355785763f",
            "line_count": 34,
            "cyclomatic_complexity": 4,
            "nloc": 25,
            "functions": 1,
            "halstead_volume": 849.859877888125,
            "maintainability_index": 82.8598399081058,
            "cl100k_base_tokens": 206,
            "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n// mkdir -p /var/www/html\n\nint main(int argc, char *argv[]) {\n    char file_name_buffer[PATH_MAX];\n    const char public_root[] = \"/var/www/html\";\n\n    if (argc != 2) {\n        printf(\"Usage: %s <filename>\\n\", argv[0]);\n        return 1;\n    }\n    argv[1][0] = '\\0';\n    snprintf(file_name_buffer, sizeof(file_name_buffer), \"%s/%s\", public_root, argv[1]);\n\n    // Print file content\n    FILE *file = fopen(file_name_buffer, \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n    char ch;\n    while ((ch = fgetc(file)) != EOF) {\n        putchar(ch);\n    }\n\n    // Close the file\n    fclose(file);\n\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-78-1.c",
            "version": 1.1,
            "compile": "gcc CASTLE-78-1.c -o CASTLE-78-1",
            "vulnerable": true,
            "description": "Missing input validation of fgets input allows for OS command injection",
            "cwe": 78,
            "lines": [
                13,
                16
            ],
            "id": "78-1",
            "number": 11,
            "hash": "fe3a599c4bfaadf7c9f5c6d372553580",
            "line_count": 19,
            "cyclomatic_complexity": 1,
            "nloc": 11,
            "functions": 1,
            "halstead_volume": 315.0,
            "maintainability_index": 100.0,
            "cl100k_base_tokens": 104,
            "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    char ip[46]; // ipv6 address length = 45 chars + null\n\n    // Ask for the IP address\n    printf(\"Enter the IP address to ping: \");\n    fgets(ip, sizeof(ip), stdin);\n\n    // Create the ping command\n    char command[150];\n    snprintf(command, sizeof(command), \"ping %s\", ip);\n\n    // Execute the ping command\n    system(command);\n\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-78-2.c",
            "version": 1.1,
            "compile": "gcc CASTLE-78-2.c -o CASTLE-78-2",
            "vulnerable": true,
            "description": "Missing input validation of command line arguments allows for OS command injection",
            "cwe": 78,
            "lines": [
                9,
                10
            ],
            "id": "78-2",
            "number": 12,
            "hash": "ce85e826db0a73598adc723480ea7ba2",
            "line_count": 12,
            "cyclomatic_complexity": 1,
            "nloc": 9,
            "functions": 1,
            "halstead_volume": 328.27411308447785,
            "maintainability_index": 100.0,
            "cl100k_base_tokens": 70,
            "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define CMD_MAX 256\n\nint main(int argc, char** argv) {\n    char cmd[CMD_MAX] = \"/usr/bin/cat \";\n    strncat(cmd, argv[1], CMD_MAX - 14);\n    system(cmd);\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-78-3.c",
            "version": 1.1,
            "compile": "gcc CASTLE-78-3.c -o CASTLE-78-3",
            "vulnerable": true,
            "description": "Missing input validation of command line arguments allows for OS command injection",
            "cwe": 78,
            "lines": [
                23,
                25
            ],
            "id": "78-3",
            "number": 13,
            "hash": "b1a9ab47a1799dbbcf64592655c296e5",
            "line_count": 28,
            "cyclomatic_complexity": 3,
            "nloc": 23,
            "functions": 1,
            "halstead_volume": 787.479712601683,
            "maintainability_index": 84.8370381372678,
            "cl100k_base_tokens": 167,
            "code": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main(int argc, char **argv) {\n    char cat[] = \"cat \";\n    char *command;\n    unsigned long long commandLength;\n\n    if (argc != 2) {\n        printf(\"Usage: %s <file_path>\\n\", argv[0]);\n        return 1;\n    }\n\n    commandLength = strlen(cat) + strlen(argv[1]) + 1;\n    command = (char*) malloc(commandLength);\n    if (command == NULL) {\n        return 1;\n    }\n    \n    strncpy(command, cat, commandLength);\n    strncat(command, argv[1], (commandLength - strlen(cat)) );\n\n    system(command);\n    free(command);\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-78-4.c",
            "version": 1.1,
            "compile": "gcc CASTLE-78-4.c -o CASTLE-78-4",
            "vulnerable": true,
            "description": "Missing input validation of fgets input allows for OS command injection",
            "cwe": 78,
            "lines": [
                11,
                12
            ],
            "id": "78-4",
            "number": 14,
            "hash": "619cb23532fb3c5b543355800d7e2606",
            "line_count": 15,
            "cyclomatic_complexity": 1,
            "nloc": 11,
            "functions": 1,
            "halstead_volume": 315.0,
            "maintainability_index": 100.0,
            "cl100k_base_tokens": 79,
            "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    char command[256];\n    char userInput[10];\n\n    printf(\"Enter the number of files to list: \");\n    fgets(userInput, sizeof(userInput), stdin);\n\n    snprintf(command, sizeof(command), \"ls -l | head -n %s\", userInput);\n    system(command);\n\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-78-5.c",
            "version": 1.1,
            "compile": "gcc CASTLE-78-5.c -o CASTLE-78-5",
            "vulnerable": true,
            "description": "The test case exposes an OS Command Injection in scope complexity.",
            "cwe": 78,
            "lines": [
                10
            ],
            "id": "78-5",
            "number": 15,
            "hash": "d61c526301774d7a78729efe2aa9d69c",
            "line_count": 25,
            "cyclomatic_complexity": 4,
            "nloc": 21,
            "functions": 2,
            "halstead_volume": 605.4501848328625,
            "maintainability_index": 87.44768060877351,
            "cl100k_base_tokens": 118,
            "code": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define SIZE_CMD 14\nconst char cmd[SIZE_CMD] = \"/usr/bin/cat \";\n\nvoid runCommand(char *str)\n{\n\tif(system(str) < 0)\n\t\tfprintf(stderr, \"system() failed\");\n}\n\nint main(int argc, char *argv[])\n{\n\tchar sys[512];\n\tchar buff[512];\n\tif (fgets(buff,512 - SIZE_CMD,stdin))\n\t{\n\t\tstrcpy(sys, cmd);\n\t\tstrcat(sys, buff);\n\t\trunCommand(sys);\n\t}\n\treturn 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-78-6.c",
            "version": 1.1,
            "compile": "gcc CASTLE-78-6.c -o CASTLE-78-6",
            "vulnerable": true,
            "description": "Missing input validation of fgets input allows for OS command injection",
            "cwe": 78,
            "lines": [
                29
            ],
            "id": "78-6",
            "number": 16,
            "hash": "1f66b7392abbcfa98dde3c6b014be736",
            "line_count": 34,
            "cyclomatic_complexity": 8,
            "nloc": 28,
            "functions": 1,
            "halstead_volume": 1008.2253473856907,
            "maintainability_index": 79.21536262584907,
            "cl100k_base_tokens": 189,
            "code": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n\n#define SIZE_CMD 10\nconst char cmd[SIZE_CMD] = \"/bin/cat \";\n\nint main(int argc, char *argv[])\n{\n\tunsigned i;\n\tchar buff[512];\n\tchar sys[512];\n\tif (fgets(buff,512 - SIZE_CMD,stdin))\n\t{\n\t\tstrcpy(sys, cmd);\n\t\tstrcat(sys, buff);\n\n        // Validate input\n        bool valid = true;\n        for (i = 0; i < strlen(sys); i++) {\n            if (sys[i] == ';' || sys[i] == '|' || sys[i] == '&') {\n                valid = false;\n                break;\n            }\n        }\n\n\t\tfor (i=0;i<5;++i) {\n\t\t\tif(system(sys) < 0)\n\t\t\t\tfprintf(stderr, \"system() failed\");\n\t\t}\n\t}\n\treturn 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-78-7.c",
            "version": 1.1,
            "compile": "gcc CASTLE-78-7.c -o CASTLE-78-7",
            "vulnerable": false,
            "description": "OS command input is verified sufficiently.",
            "cwe": 78,
            "lines": [],
            "id": "78-7",
            "number": 17,
            "hash": "57bbbc79247a5afd9e8b3f435c9c1943",
            "line_count": 40,
            "cyclomatic_complexity": 5,
            "nloc": 28,
            "functions": 2,
            "halstead_volume": 863.2331253245202,
            "maintainability_index": 80.71272603633433,
            "cl100k_base_tokens": 233,
            "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n\nint isValidNumber(char *input) {\n    for (int i = 0; i < strlen(input); i++) {\n        if (!isdigit(input[i])) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char userInput[10];\n    int numFiles;\n\n    printf(\"Enter the number of files to list: \");\n    fgets(userInput, sizeof(userInput), stdin);\n\n    // Remove trailing newline character from fgets\n    userInput[strcspn(userInput, \"\\n\")] = '\\0';\n\n    // Validate input\n    if (!isValidNumber(userInput)) {\n        printf(\"Invalid input. Please enter a valid number.\\n\");\n        return 1;\n    }\n\n    // Convert the valid input to an integer\n    numFiles = atoi(userInput);\n\n    // Execute a safe system command with the validated number\n    char command[256];\n    snprintf(command, sizeof(command), \"ls -l | head -n %d\", numFiles);\n    system(command);\n\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-78-8.c",
            "version": 1.1,
            "compile": "gcc CASTLE-78-8.c -o CASTLE-78-8",
            "vulnerable": false,
            "description": "fgets input validated correcly disallowing OS command injection",
            "cwe": 78,
            "lines": [],
            "id": "78-8",
            "number": 18,
            "hash": "e0b55db2f16d0de7f8686c4ff27c9815",
            "line_count": 36,
            "cyclomatic_complexity": 7,
            "nloc": 31,
            "functions": 1,
            "halstead_volume": 1000.0493183915131,
            "maintainability_index": 77.83882338732141,
            "cl100k_base_tokens": 198,
            "code": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <ctype.h>\n\n#define SIZE_CMD 10\nconst char cmd[SIZE_CMD] = \"/bin/cat \";\n\nint main(int argc, char *argv[])\n{\n    unsigned i;\n    char buff[512];\n    char sys[512];\n    if (fgets(buff, 512 - SIZE_CMD, stdin))\n    {\n        strcpy(sys, cmd);\n        strcat(sys, buff);\n\n        for (int i = 0; i < strlen(sys); i++)\n        {\n            if (!isalpha(sys[i]) && sys[i] != '.')\n            {\n                fprintf(stderr, \"illegal character in input\");\n                return 0;\n            }\n        }\n\n        for (i = 0; i < 5; ++i)\n        {\n            if (system(sys) < 0)\n                fprintf(stderr, \"system() failed\");\n        }\n    }\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-78-9.c",
            "version": 1.1,
            "compile": "gcc CASTLE-78-9.c -o CASTLE-78-9",
            "vulnerable": false,
            "description": "Input is sufficienty validated before being used in a command.",
            "cwe": 78,
            "lines": [],
            "id": "78-9",
            "number": 19,
            "hash": "8620e70780bbc93c92daf94c857031dc",
            "line_count": 41,
            "cyclomatic_complexity": 8,
            "nloc": 31,
            "functions": 3,
            "halstead_volume": 893.555590911859,
            "maintainability_index": 78.19432282895727,
            "cl100k_base_tokens": 188,
            "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n\n#define MAXSIZE 64\n\nint check(const char *str)\n{\n    int i;\n\n    for (i = 0; i < strlen(str); ++i)\n        if (!isalnum(str[i]))\n            return -1;\n\n    return 0;\n}\n\nvoid test(char *str)\n{\n    char buf[MAXSIZE];\n\n    if (check(str) < 0)\n        return;\n\n    snprintf(buf, sizeof buf, \"/bin/echo %s\", str);\n    if (system(buf) < 0)\n        fprintf(stderr, \"Error running command: %s\\n\", buf);\n}\n\nint main(int argc, char **argv)\n{\n    char *userstr;\n\n    if (argc > 1)\n    {\n        userstr = argv[1];\n        test(userstr);\n    }\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-78-10.c",
            "version": 1.1,
            "compile": "gcc CASTLE-78-10.c -o CASTLE-78-10",
            "vulnerable": false,
            "description": "Input is sufficienty validated before being used in a command.",
            "cwe": 78,
            "lines": [],
            "id": "78-10",
            "number": 20,
            "hash": "b2aa7e363970347c8e53782c27e736d5",
            "line_count": 45,
            "cyclomatic_complexity": 10,
            "nloc": 39,
            "functions": 2,
            "halstead_volume": 1340.6448720520207,
            "maintainability_index": 71.90559000279131,
            "cl100k_base_tokens": 264,
            "code": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <ctype.h>\n\n#define SIZE_CMD 10\nconst char cmd[SIZE_CMD] = \"/bin/cat \";\n\n\nvoid cleanup(char *__buff)\n{\n    char buf[BUFSIZ] = \"\";\n    char *c = __buff, *b = buf;\n    for (; *c != '\\0'; c++)\n    {\n        if (isalnum(*c) || *c == '/' || *c == '_' || *c == '.')\n            *b++ = *c;\n    }\n    *b = '\\0';\n    strcpy(__buff, buf);\n}\n\nint main(int argc, char *argv[])\n{\n    char sys[BUFSIZ];\n    char buff[BUFSIZ];\n\n    sys[0] = '\\0';\n    if (fgets(buff, BUFSIZ - SIZE_CMD, stdin))\n    {\n        strcat(sys, cmd);\n        strcat(sys, buff);\n        cleanup(sys + SIZE_CMD - 1);\n        switch (1 == 1)\n        {\n        case true:\n            if (system(sys) < 0)\n                fprintf(stderr, \"Error running command %s\\n\", sys);\n        default:\n            break;\n        }\n    }\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-89-1.c",
            "version": 1.1,
            "compile": "gcc CASTLE-89-1.c -o CASTLE-89-1 -lsqlite3",
            "vulnerable": true,
            "description": "Missing input validation of fgets input allows for SQL injection.",
            "cwe": 89,
            "lines": [
                25,
                28
            ],
            "id": "89-1",
            "number": 21,
            "hash": "36de87458f7704876446943078adcbba",
            "line_count": 48,
            "cyclomatic_complexity": 4,
            "nloc": 32,
            "functions": 1,
            "halstead_volume": 1116.0,
            "maintainability_index": 77.44404643134992,
            "cl100k_base_tokens": 340,
            "code": "// create table existential_crises (id INT, name VARCHAR(12))\n// insert into existential_crises values (1, \"abc\")\n\n#include <stdio.h>\n#include <sqlite3.h>\n\nint main() {\n    sqlite3 *db;\n    sqlite3_stmt *res;\n    int rc;\n\n    rc = sqlite3_open(\"crises.db\", &db);\n\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"Cannot open database: %s\\n\", sqlite3_errmsg(db));\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Prepare an SQL query\n    char id[32];\n    printf(\"Enter the id of the record: \");\n    fgets(id, sizeof(id), stdin);\n    char sql[256];\n    snprintf(sql, sizeof(sql), \"SELECT * FROM existential_crises WHERE id = '%s'\", id);\n\n    // Compile the SQL query\n    rc = sqlite3_prepare_v2(db, sql, -1, &res, 0);\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"Failed to prepare statement: %s\\n\", sqlite3_errmsg(db));\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Execute SQL query\n    while (sqlite3_step(res) == SQLITE_ROW) {\n        int id = sqlite3_column_int(res, 0);\n        const unsigned char *name = sqlite3_column_text(res, 1);\n\n        printf(\"ID: %d | Name: %s\\n\", id, name);\n    }\n\n    // Finalize and clean up\n    sqlite3_finalize(res);\n    sqlite3_close(db);\n\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-89-2.c",
            "version": 1.1,
            "compile": "gcc CASTLE-89-2.c -o CASTLE-89-2 -lmysqlclient",
            "vulnerable": true,
            "description": "Insufficient inpit validation of fgets input allows for SQL injection.",
            "cwe": 89,
            "lines": [
                40,
                43
            ],
            "id": "89-2",
            "number": 22,
            "hash": "962d12f86394e7070f0bd9aa9b135373",
            "line_count": 68,
            "cyclomatic_complexity": 11,
            "nloc": 49,
            "functions": 1,
            "halstead_volume": 1937.8294855911893,
            "maintainability_index": 66.0620273905943,
            "cl100k_base_tokens": 443,
            "code": "#include <mysql/mysql.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n\nint main() {\n    MYSQL *conn;\n    MYSQL_RES *res;\n    MYSQL_ROW row;\n\n    // Credentials\n    const char *server = getenv(\"DB_ADDRESS\");\n    const char *user = getenv(\"DB_USERNAME\");\n    const char *password = getenv(\"DB_PASSWORD\");\n    const char *database = getenv(\"DB_DATABASE\");\n    if (server == NULL || user == NULL || password == NULL || database == NULL) {\n        printf(\"Missing database credentials\\n\");\n        return 1;\n    }\n\n    // Initialize MySQL connection\n    conn = mysql_init(NULL);\n    if (conn == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    // Connect to database\n    if (!mysql_real_connect(conn, server, user, password, database, 0, NULL, 0)) {\n        fprintf(stderr, \"Connection failed: %s\\n\", mysql_error(conn));\n        return 1;\n    }\n    printf(\"Connection successful!\\n\");\n\n    char id[32];\n    printf(\"ID: \");\n    fgets(id, sizeof(id), stdin);\n\n    char sql[256];\n    snprintf(sql, sizeof(sql), \"SELECT * FROM tokens WHERE id = %s\", id);\n\n    // Send SQL query\n    if (mysql_query(conn, sql)) {\n        fprintf(stderr, \"Query failed: %s\\n\", mysql_error(conn));\n        return 1;\n    }\n\n    // Store the result\n    res = mysql_store_result(conn);\n\n    // Output the result row by row\n    int num_fields = mysql_num_fields(res);\n    while ((row = mysql_fetch_row(res))) {\n        unsigned long *lengths;\n        lengths = mysql_fetch_lengths(res);\n        for(int i = 0; i < num_fields; i++) {\n            printf(\"[%.*s] \", (int) lengths[i],\n                    row[i] ? row[i] : \"NULL\");\n        }\n        printf(\"\\n\");\n    }\n\n    // Clean up\n    mysql_free_result(res);\n    mysql_close(conn);\n\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-89-3.c",
            "version": 1.1,
            "compile": "gcc CASTLE-89-3.c -o CASTLE-89-3 -lmysqlclient",
            "vulnerable": true,
            "description": "Missing input validation of fgets input allows for SQL injection.",
            "cwe": 89,
            "lines": [
                121,
                122
            ],
            "id": "89-3",
            "number": 23,
            "hash": "a0ae8f94d78545bcfd76f47c24bcebc3",
            "line_count": 138,
            "cyclomatic_complexity": 17,
            "nloc": 106,
            "functions": 3,
            "halstead_volume": 3696.5369976290317,
            "maintainability_index": 48.823497763759335,
            "cl100k_base_tokens": 724,
            "code": "#include <mysql/mysql.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <termios.h>\n#include <stdint.h>\n\n\nchar *my_memset_s(char *s, int c, size_t n)\n{\n    volatile char *p = s;\n\n    if (p != NULL)\n        while (n--)\n            *p++ = c;\n\n    return s;\n}\n\n\nchar *getpass_r(const char *prompt)\n{\n    struct termios oflags, nflags;\n    char password[64] = {'\\0'};\n    char *ret = NULL;\n\n    \n    if (tcgetattr(fileno(stdin), &oflags))\n        return NULL;\n\n    nflags = oflags;\n    nflags.c_lflag &= ~ECHO;\n    nflags.c_lflag |= ECHONL;\n\n    if (tcsetattr(fileno(stdin), TCSAFLUSH, &nflags))\n        return NULL;\n\n    \n    fprintf(stderr, \"%s\", prompt);\n    ret = fgets(password, sizeof(password), stdin);\n\n    \n    if (tcsetattr(fileno(stdin), TCSAFLUSH, &oflags))\n    {\n        my_memset_s(password, 0, sizeof(password));\n        return NULL;\n    }\n\n    if (ret)\n    {\n        strtok(password, \"\\n\");\n        ret = strdup(password);\n        my_memset_s(password, 0, sizeof(password));\n    }\n\n    return ret;\n}\n\nint main(int argc, char *argv[])\n{\n    MYSQL *conn;\n    MYSQL_RES *res;\n    MYSQL_ROW row;\n\n    size_t arglen, fmtlen;\n\n    char *server = \"localhost\";\n    char *user = \"root\";\n    char *database = \"bank\";\n    char *password;\n    char *query;\n    char *fmtString = \"SELECT * FROM users WHERE firstname LIKE '%s'\";\n\n    if (argc < 2)\n    {\n        printf(\"You should give an entry parameter!\\n\");\n        return -1;\n    }\n\n    // Authenticate\n    conn = mysql_init(NULL);\n    if (!conn)\n        return -1;\n\n    password = getpass_r(\"DB Password: \");\n    if (!password)\n    {\n        mysql_close(conn);\n        return -1;\n    }\n\n    if (!mysql_real_connect(conn, server,\n                            user, password, database, 0, NULL, 0))\n    {\n        my_memset_s(password, 0, strlen(password));\n        free(password);\n        mysql_close(conn);\n        return -1;\n    }\n\n    my_memset_s(password, 0, strlen(password));\n    free(password);\n\n\n    // Send Query\n    arglen = strlen(argv[1]);\n    fmtlen = strlen(fmtString);\n    if (arglen > SIZE_MAX / sizeof *query - fmtlen)\n    {\n        mysql_close(conn);\n        return -1;\n    }\n    query = malloc((arglen + fmtlen) * sizeof *query);\n    if (query == NULL)\n    {\n        mysql_close(conn);\n        return -1;\n    }\n\n    sprintf(query, fmtString, argv[1]);\n    if (mysql_query(conn, query))\n    {\n        free(query);\n        mysql_close(conn);\n        return -1;\n    }\n\n    res = mysql_use_result(conn);\n\n    while ((row = mysql_fetch_row(res)) != NULL)\n        printf(\"%s %s\\n\", row[1], row[2]);\n\n    free(query);\n    mysql_free_result(res);\n    mysql_close(conn);\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-89-4.c",
            "version": 1.1,
            "compile": "gcc CASTLE-89-4.c -o CASTLE-89-4 -lmysqlclient",
            "vulnerable": true,
            "description": "Missing input validation of fgets input allows for SQL injection.",
            "cwe": 89,
            "lines": [
                123,
                125
            ],
            "id": "89-4",
            "number": 24,
            "hash": "927140e4325ab253557eca862449c502",
            "line_count": 145,
            "cyclomatic_complexity": 18,
            "nloc": 110,
            "functions": 3,
            "halstead_volume": 3868.015337125457,
            "maintainability_index": 47.75763460134365,
            "cl100k_base_tokens": 754,
            "code": "#include <mysql/mysql.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdint.h>\n\n\nchar *my_memset_s(char *s, int c, size_t n)\n{\n    volatile char *p = s;\n\n    if (p != NULL)\n        while (n--)\n            *p++ = c;\n\n    return s;\n}\n\nchar *getpass_r(const char *prompt)\n{\n    struct termios oflags, nflags;\n    char password[64] = {'\\0'};\n    char *ret = NULL;\n\n    \n    if (tcgetattr(fileno(stdin), &oflags))\n        return NULL;\n\n    nflags = oflags;\n    nflags.c_lflag &= ~ECHO;\n    nflags.c_lflag |= ECHONL;\n\n    if (tcsetattr(fileno(stdin), TCSAFLUSH, &nflags))\n        return NULL;\n\n    \n    fprintf(stderr, \"%s\", prompt);\n    ret = fgets(password, sizeof(password), stdin);\n\n    \n    if (tcsetattr(fileno(stdin), TCSAFLUSH, &oflags))\n    {\n        my_memset_s(password, 0, sizeof(password));\n        return NULL;\n    }\n\n    if (ret)\n    {\n        strtok(password, \"\\n\");\n        ret = strdup(password);\n        my_memset_s(password, 0, sizeof(password));\n    }\n\n    return ret;\n}\n\nint main(int argc, char *argv[])\n{\n    MYSQL *conn = 0;\n    MYSQL_RES *res = 0;\n    MYSQL_ROW row;\n\n    size_t arglen, fmtlen;\n\n    char *server = \"localhost\";\n    char *user = \"root\";\n    char *database = \"bank\";\n    char *password;\n    char *query;\n    char *fmtString = \"SELECT * FROM users WHERE firstname LIKE '%s'\";\n    unsigned int i;\n\n    if (argc < 2)\n    {\n        printf(\"You should give an entry parameter!\\n\");\n        return -1;\n    }\n\n    conn = mysql_init(NULL);\n    if (!conn)\n        return -1;\n\n    password = getpass_r(\"DB Password: \");\n    if (!password)\n    {\n        mysql_close(conn);\n        return -1;\n    }\n\n    \n    if (!mysql_real_connect(conn, server,\n                            user, password, database, 0, NULL, 0))\n    {\n        my_memset_s(password, 0, strlen(password));\n        free(password);\n        mysql_close(conn);\n        return -1;\n    }\n\n    my_memset_s(password, 0, strlen(password));\n    free(password);\n\n    \n    for (i = 1; i < argc; ++i)\n    {\n        // allocate memory for the query\n        arglen = strlen(argv[i]);\n        fmtlen = strlen(fmtString);\n        if (arglen > SIZE_MAX / sizeof *query - fmtlen)\n        {\n            mysql_close(conn);\n            return -1;\n        }\n        query = malloc((arglen + fmtlen) * sizeof *query);\n        if (query == NULL)\n        {\n            mysql_close(conn);\n            return -1;\n        }\n\n        sprintf(query, fmtString, argv[i]);\n\n        if (mysql_query(conn, query))\n        {\n            free(query);\n            mysql_close(conn);\n            return -1;\n        }\n\n        res = mysql_use_result(conn);\n\n        \n        while ((row = mysql_fetch_row(res)) != NULL)\n            printf(\"%s %s\\n\", row[1], row[2]);\n\n        free(query);\n        mysql_free_result(res);\n    }\n\n    \n    mysql_close(conn);\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-89-5.c",
            "version": 1.1,
            "compile": "gcc CASTLE-89-5.c -o CASTLE-89-5 -lmysqlclient",
            "vulnerable": true,
            "description": "Insufficient input validation of fgets input allows for SQL injection.",
            "cwe": 89,
            "lines": [
                55,
                58
            ],
            "id": "89-5",
            "number": 25,
            "hash": "a8646d369aac6135a8c6ca5a99f3aeb4",
            "line_count": 83,
            "cyclomatic_complexity": 15,
            "nloc": 61,
            "functions": 2,
            "halstead_volume": 2325.7288853491555,
            "maintainability_index": 60.644541806970224,
            "cl100k_base_tokens": 523,
            "code": "#include <mysql/mysql.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n\nint validate_id(const char *id) {\n    for (int i = 0; id[i] != '\\0'; i++) {\n        if (id[i] == '\\'') {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    MYSQL *conn;\n    MYSQL_RES *res;\n    MYSQL_ROW row;\n\n    // Credentials\n    const char *server = getenv(\"DB_ADDRESS\");\n    const char *user = getenv(\"DB_USERNAME\");\n    const char *password = getenv(\"DB_PASSWORD\");\n    const char *database = getenv(\"DB_DATABASE\");\n    if (server == NULL || user == NULL || password == NULL || database == NULL) {\n        printf(\"Missing database credentials\\n\");\n        return 1;\n    }\n\n    // Initialize MySQL connection\n    conn = mysql_init(NULL);\n    if (conn == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    // Connect to database\n    if (!mysql_real_connect(conn, server, user, password, database, 0, NULL, 0)) {\n        fprintf(stderr, \"Connection failed: %s\\n\", mysql_error(conn));\n        return 1;\n    }\n    printf(\"Connection successful!\\n\");\n\n    char id[32];\n    printf(\"ID: \");\n    fgets(id, sizeof(id), stdin);\n\n    // Validate input\n    if (!validate_id(id)) {\n        printf(\"Invalid ID\\n\");\n        return 1;\n    }\n\n    char sql[256];\n    snprintf(sql, sizeof(sql), \"SELECT * FROM tokens WHERE id = %s\", id);\n\n    // Send SQL query\n    if (mysql_query(conn, sql)) {\n        fprintf(stderr, \"Query failed: %s\\n\", mysql_error(conn));\n        return 1;\n    }\n\n    // Store the result\n    res = mysql_store_result(conn);\n\n    // Output the result row by row\n    int num_fields = mysql_num_fields(res);\n    while ((row = mysql_fetch_row(res))) {\n        unsigned long *lengths;\n        lengths = mysql_fetch_lengths(res);\n        for(int i = 0; i < num_fields; i++) {\n            printf(\"[%.*s] \", (int) lengths[i],\n                    row[i] ? row[i] : \"NULL\");\n        }\n        printf(\"\\n\");\n    }\n\n    // Clean up\n    mysql_free_result(res);\n    mysql_close(conn);\n\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-89-6.c",
            "version": 1.1,
            "compile": "gcc CASTLE-89-6.c -o CASTLE-89-6 -lmysqlclient",
            "vulnerable": true,
            "description": "Insufficient input validation hidden in subfunction allows for SQL injection.",
            "cwe": 89,
            "lines": [
                126,
                128
            ],
            "id": "89-6",
            "number": 26,
            "hash": "1268a38571516615e501aae4cec7987e",
            "line_count": 146,
            "cyclomatic_complexity": 19,
            "nloc": 112,
            "functions": 4,
            "halstead_volume": 3901.5801980880674,
            "maintainability_index": 47.19080625394993,
            "cl100k_base_tokens": 767,
            "code": "#include <mysql/mysql.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdint.h>\n\n\nchar *my_memset_s(char *s, int c, size_t n)\n{\n    volatile char *p = s;\n\n    if (p != NULL)\n        while (n--)\n            *p++ = c;\n\n    return s;\n}\n\nchar *getpass_r(const char *prompt)\n{\n    struct termios oflags, nflags;\n    char password[64] = {'\\0'};\n    char *ret = NULL;\n\n    \n    if (tcgetattr(fileno(stdin), &oflags))\n        return NULL;\n\n    nflags = oflags;\n    nflags.c_lflag &= ~ECHO;\n    nflags.c_lflag |= ECHONL;\n\n    if (tcsetattr(fileno(stdin), TCSAFLUSH, &nflags))\n        return NULL;\n\n    \n    fprintf(stderr, \"%s\", prompt);\n    ret = fgets(password, sizeof(password), stdin);\n\n    \n    if (tcsetattr(fileno(stdin), TCSAFLUSH, &oflags))\n    {\n        my_memset_s(password, 0, sizeof(password));\n        return NULL;\n    }\n\n    if (ret)\n    {\n        strtok(password, \"\\n\");\n        ret = strdup(password);\n        my_memset_s(password, 0, sizeof(password));\n    }\n\n    return ret;\n}\n\nint runSQLCommand(MYSQL *conn, const char *query)\n{\n    if (mysql_query(conn, query))\n        return 1;\n    return 0;\n}\n\nint main(int argc, char *argv[])\n{\n    MYSQL *conn;\n    MYSQL_RES *res;\n    MYSQL_ROW row;\n\n    size_t arglen, fmtlen;\n\n    char *server = \"localhost\";\n    char *user = \"root\";\n    char *database = \"bank\";\n    char *password;\n    char *query;\n    char *fmtString = \"SELECT * FROM users WHERE firstname LIKE '%s'\";\n\n    if (argc < 2)\n    {\n        printf(\"You should give an entry parameter!\\n\");\n        return -1;\n    }\n\n    conn = mysql_init(NULL);\n    if (!conn)\n        return -1;\n\n    password = getpass_r(\"DB Password: \");\n    if (!password)\n    {\n        mysql_close(conn);\n        return -1;\n    }\n\n    if (!mysql_real_connect(conn, server,\n                            user, password, database, 0, NULL, 0))\n    {\n        my_memset_s(password, 0, strlen(password));\n        free(password);\n        mysql_close(conn);\n        return -1;\n    }\n\n    my_memset_s(password, 0, strlen(password));\n    free(password);\n\n\n    arglen = strlen(argv[1]);\n    fmtlen = strlen(fmtString);\n    if (arglen > SIZE_MAX / sizeof *query - fmtlen)\n    {\n        // the operation would cause an integer overflow\n        mysql_close(conn);\n        return -1;\n    }\n    query = malloc((arglen + fmtlen) * sizeof *query);\n    if (query == NULL)\n    {\n        mysql_close(conn);\n        return -1;\n    }\n\n    sprintf(query, fmtString, argv[1]);\n\n    if (runSQLCommand(conn, (const char *)query))\n    {\n        free(query);\n        mysql_close(conn);\n        return -1;\n    }\n\n    res = mysql_use_result(conn);\n\n    \n    while ((row = mysql_fetch_row(res)) != NULL)\n        printf(\"%s %s\\n\", row[1], row[2]);\n\n    \n    free(query);\n    mysql_free_result(res);\n    mysql_close(conn);\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-89-7.c",
            "version": 1.1,
            "compile": "gcc CASTLE-89-7.c -o CASTLE-89-7 -lsqlite3",
            "vulnerable": false,
            "description": "Static SQL query is not vulnerable to injection.",
            "cwe": 89,
            "lines": [],
            "id": "89-7",
            "number": 27,
            "hash": "dc7463a2cb4cb6d9f1a45abc6822a679",
            "line_count": 43,
            "cyclomatic_complexity": 4,
            "nloc": 28,
            "functions": 1,
            "halstead_volume": 925.0175541639455,
            "maintainability_index": 80.58326081816587,
            "cl100k_base_tokens": 320,
            "code": "// create table students (id INT, name VARCHAR(18), class VARCHAR(5))\n// insert into students values (1, 'Arnold', \"1b\")\n// insert into students values (2, 'Claire', \"3c\")\n\n#include <stdio.h>\n#include <sqlite3.h>\n\nint main() {\n    sqlite3 *db;\n    sqlite3_stmt *res;\n    int rc;\n\n    rc = sqlite3_open(\"students.db\", &db);\n\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"Cannot open database: %s\\n\", sqlite3_errmsg(db));\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Compile the SQL query\n    rc = sqlite3_prepare_v2(db, \"SELECT * FROM students\", -1, &res, 0);\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"Failed to prepare statement: %s\\n\", sqlite3_errmsg(db));\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Execute SQL query\n    while (sqlite3_step(res) == SQLITE_ROW) {\n        int id = sqlite3_column_int(res, 0);\n        const unsigned char *name = sqlite3_column_text(res, 1);\n        const unsigned char *grade = sqlite3_column_text(res, 2);\n\n        printf(\"Name: %s, Grade: %s\\n\", name, grade);\n    }\n\n    // Finalize and clean up\n    sqlite3_finalize(res);\n    sqlite3_close(db);\n\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-89-8.c",
            "version": 1.1,
            "compile": "gcc CASTLE-89-8.c -o CASTLE-89-8 -lmysqlclient",
            "vulnerable": false,
            "description": "Sufficient ingteger valudation of parameter ID does not allow for SQL injection",
            "cwe": 89,
            "lines": [],
            "id": "89-8",
            "number": 28,
            "hash": "79980d7644a1cbe4407bfefa1ba8ae9e",
            "line_count": 83,
            "cyclomatic_complexity": 16,
            "nloc": 61,
            "functions": 2,
            "halstead_volume": 2377.1714627603374,
            "maintainability_index": 60.3007770863172,
            "cl100k_base_tokens": 532,
            "code": "#include <mysql/mysql.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n\nint validate_id(const char *id) {\n    for (int i = 0; id[i] != '\\0'; i++) {\n        if (id[i] < '0' || id[i] > '9') {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    MYSQL *conn;\n    MYSQL_RES *res;\n    MYSQL_ROW row;\n\n    // Credentials\n    const char *server = getenv(\"DB_ADDRESS\");\n    const char *user = getenv(\"DB_USERNAME\");\n    const char *password = getenv(\"DB_PASSWORD\");\n    const char *database = getenv(\"DB_DATABASE\");\n    if (server == NULL || user == NULL || password == NULL || database == NULL) {\n        printf(\"Missing database credentials\\n\");\n        return 1;\n    }\n\n    // Initialize MySQL connection\n    conn = mysql_init(NULL);\n    if (conn == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    // Connect to database\n    if (!mysql_real_connect(conn, server, user, password, database, 0, NULL, 0)) {\n        fprintf(stderr, \"Connection failed: %s\\n\", mysql_error(conn));\n        return 1;\n    }\n    printf(\"Connection successful!\\n\");\n\n    char id[32];\n    printf(\"ID: \");\n    fgets(id, sizeof(id), stdin);\n\n    // Validate input\n    if (!validate_id(id)) {\n        printf(\"Invalid ID\\n\");\n        return 1;\n    }\n\n    char sql[256];\n    snprintf(sql, sizeof(sql), \"SELECT * FROM tokens WHERE id = %s\", id);\n\n    // Send SQL query\n    if (mysql_query(conn, sql)) {\n        fprintf(stderr, \"Query failed: %s\\n\", mysql_error(conn));\n        return 1;\n    }\n\n    // Store the result\n    res = mysql_store_result(conn);\n\n    // Output the result row by row\n    int num_fields = mysql_num_fields(res);\n    while ((row = mysql_fetch_row(res))) {\n        unsigned long *lengths;\n        lengths = mysql_fetch_lengths(res);\n        for(int i = 0; i < num_fields; i++) {\n            printf(\"[%.*s] \", (int) lengths[i],\n                    row[i] ? row[i] : \"NULL\");\n        }\n        printf(\"\\n\");\n    }\n\n    // Clean up\n    mysql_free_result(res);\n    mysql_close(conn);\n\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-89-9.c",
            "version": 1.1,
            "compile": "gcc CASTLE-89-9.c -o CASTLE-89-9 -lmysqlclient",
            "vulnerable": false,
            "description": "Sufficient ingteger valudation of parameter ID does not allow for SQL injection",
            "cwe": 89,
            "lines": [],
            "id": "89-9",
            "number": 29,
            "hash": "af8f9c17bae8b246839c1e5f07a0238f",
            "line_count": 160,
            "cyclomatic_complexity": 20,
            "nloc": 127,
            "functions": 3,
            "halstead_volume": 4496.385777741146,
            "maintainability_index": 44.186817398109554,
            "cl100k_base_tokens": 887,
            "code": "#include <mysql/mysql.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdint.h>\n\n\nchar *my_memset_s(char *s, int c, size_t n)\n{\n    volatile char *p = s;\n\n    if (p != NULL)\n        while (n--)\n            *p++ = c;\n\n    return s;\n}\n\nchar *getpass_r(const char *prompt)\n{\n    struct termios oflags, nflags;\n    char password[64] = {'\\0'};\n    char *ret = NULL;\n\n    \n    if (tcgetattr(fileno(stdin), &oflags))\n        return NULL;\n\n    nflags = oflags;\n    nflags.c_lflag &= ~ECHO;\n    nflags.c_lflag |= ECHONL;\n\n    if (tcsetattr(fileno(stdin), TCSAFLUSH, &nflags))\n        return NULL;\n\n    \n    fprintf(stderr, \"%s\", prompt);\n    ret = fgets(password, sizeof(password), stdin);\n\n    \n    if (tcsetattr(fileno(stdin), TCSAFLUSH, &oflags))\n    {\n        my_memset_s(password, 0, sizeof(password));\n        return NULL;\n    }\n\n    if (ret)\n    {\n        strtok(password, \"\\n\");\n        ret = strdup(password);\n        my_memset_s(password, 0, sizeof(password));\n    }\n\n    return ret;\n}\n\nint main(int argc, char *argv[])\n{\n    MYSQL *conn = 0;\n    MYSQL_RES *res = 0;\n    MYSQL_ROW row;\n\n    size_t arglen, esclen, fmtlen;\n\n    char *server = \"localhost\";\n    char *user = \"root\";\n    char *database = \"bank\";\n    char *password;\n    char *query;\n    char *fmtString = \"SELECT * FROM users WHERE firstname LIKE '%s'\";\n    char *param_escaped;\n    unsigned int i;\n\n    if (argc < 2)\n    {\n        printf(\"You should give an entry parameter!\\n\");\n        return -1;\n    }\n\n    conn = mysql_init(NULL);\n    if (!conn)\n        return -1;\n\n    password = getpass_r(\"DB Password: \");\n    if (!password)\n    {\n        mysql_close(conn);\n        return -1;\n    }\n\n    \n    if (!mysql_real_connect(conn, server,\n                            user, password, database, 0, NULL, 0))\n    {\n        my_memset_s(password, 0, strlen(password));\n        free(password);\n        mysql_close(conn);\n        return -1;\n    }\n\n    my_memset_s(password, 0, strlen(password));\n    free(password);\n\n    for (i = 1; i < argc; ++i)\n    {\n        arglen = strlen(argv[i]);\n        if (arglen > (SIZE_MAX / sizeof *param_escaped - 1) / 2)\n        {\n            mysql_close(conn);\n            return -1;\n        }\n        param_escaped = malloc((2 * arglen + 1) * sizeof *param_escaped);\n        if (param_escaped == NULL)\n        {\n            mysql_close(conn);\n            return -1;\n        }\n\n        esclen = mysql_real_escape_string(conn, param_escaped, argv[i], arglen);\n\n        fmtlen = strlen(fmtString);\n        if (esclen > SIZE_MAX / sizeof *query - fmtlen)\n        {\n            free(param_escaped);\n            mysql_close(conn);\n            return -1;\n        }\n        query = malloc((esclen + fmtlen + 1) * sizeof *query);\n        if (query == NULL)\n        {\n            free(param_escaped);\n            mysql_close(conn);\n            return -1;\n        }\n\n        sprintf(query, fmtString, param_escaped);\n\n        if (mysql_query(conn, query))\n        {\n            free(param_escaped);\n            free(query);\n            mysql_close(conn);\n            return -1;\n        }\n\n        res = mysql_use_result(conn);\n\n        while ((row = mysql_fetch_row(res)) != NULL)\n            printf(\"%s %s\\n\", row[1], row[2]);\n\n        free(param_escaped);\n        free(query);\n        mysql_free_result(res);\n    }\n\n    mysql_close(conn);\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-89-10.c",
            "version": 1.1,
            "compile": "gcc CASTLE-89-10.c -o CASTLE-89-10 -lsqlite3",
            "vulnerable": false,
            "description": "Static input to SQL query does not allow for SQL injection.",
            "cwe": 89,
            "lines": [],
            "id": "89-10",
            "number": 30,
            "hash": "362bb4816261bcc6bbd8d777a3c7d012",
            "line_count": 46,
            "cyclomatic_complexity": 4,
            "nloc": 30,
            "functions": 1,
            "halstead_volume": 1015.9851824446653,
            "maintainability_index": 78.97780938918794,
            "cl100k_base_tokens": 322,
            "code": "// create table existential_crises (id INT, name VARCHAR(12))\n// insert into existential_crises values (1, \"abc\")\n\n#include <stdio.h>\n#include <sqlite3.h>\n\nint main() {\n    sqlite3 *db;\n    sqlite3_stmt *res;\n    int rc;\n\n    rc = sqlite3_open(\"crises.db\", &db);\n\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"Cannot open database: %s\\n\", sqlite3_errmsg(db));\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Prepare an SQL query\n    char* id = \"12\";\n    char sql[256];\n    snprintf(sql, sizeof(sql), \"SELECT * FROM existential_crises WHERE id = '%s'\", id);\n\n    // Compile the SQL query\n    rc = sqlite3_prepare_v2(db, sql, -1, &res, 0);\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"Failed to prepare statement: %s\\n\", sqlite3_errmsg(db));\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Execute SQL query\n    while (sqlite3_step(res) == SQLITE_ROW) {\n        int id = sqlite3_column_int(res, 0);\n        const unsigned char *name = sqlite3_column_text(res, 1);\n\n        printf(\"ID: %d | Name: %s\\n\", id, name);\n    }\n\n    // Finalize and clean up\n    sqlite3_finalize(res);\n    sqlite3_close(db);\n\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-134-1.c",
            "version": 1.1,
            "compile": "gcc CASTLE-134-1.c -o CASTLE-134-1",
            "vulnerable": true,
            "description": "The format string is sourced fron an input without sanitization",
            "cwe": 134,
            "lines": [
                9
            ],
            "id": "134-1",
            "number": 41,
            "hash": "a393a722473344737d6709ef9d2528b0",
            "line_count": 11,
            "cyclomatic_complexity": 2,
            "nloc": 9,
            "functions": 1,
            "halstead_volume": 216.22022703449022,
            "maintainability_index": 100.0,
            "cl100k_base_tokens": 59,
            "code": "#include <stdio.h>\n\nint main(int argc, char **argv) {\n    if (argc < 2) {\n        printf(\"Usage: %s <text>\\n\", argv[0]);\n        return 1;\n    }\n\n    printf(argv[1]);\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-134-2.c",
            "version": 1.1,
            "compile": "gcc CASTLE-134-2.c -o CASTLE-134-2",
            "vulnerable": true,
            "description": "The format string is sourced fron an input without sanitization",
            "cwe": 134,
            "lines": [
                9
            ],
            "id": "134-2",
            "number": 42,
            "hash": "84844035716966faee2d14abac87964c",
            "line_count": 11,
            "cyclomatic_complexity": 2,
            "nloc": 9,
            "functions": 1,
            "halstead_volume": 240.0,
            "maintainability_index": 100.0,
            "cl100k_base_tokens": 53,
            "code": "#include <stdio.h>\n\nint main(int argc, char **argv) {\n    char buffer[256];\n    if (fgets(buffer, sizeof(buffer), stdin) == NULL) {\n        return 1;\n    }\n\n    printf(buffer);\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-134-3.c",
            "version": 1.1,
            "compile": "gcc CASTLE-134-3.c -o CASTLE-134-3",
            "vulnerable": true,
            "description": "The format string is sourced fron an input without sanitization",
            "cwe": 134,
            "lines": [
                4,
                13
            ],
            "id": "134-3",
            "number": 43,
            "hash": "59cb34388623a83fbf9007bbd3981486",
            "line_count": 15,
            "cyclomatic_complexity": 3,
            "nloc": 12,
            "functions": 2,
            "halstead_volume": 302.627697999753,
            "maintainability_index": 100.0,
            "cl100k_base_tokens": 65,
            "code": "#include <stdio.h>\n\nvoid logger(char *msg) {\n    printf(msg);\n}\n\nint main(int argc, char **argv) {\n    char buffer[256];\n    if (fgets(buffer, sizeof(buffer), stdin) == NULL) {\n        return 1;\n    }\n\n    logger(buffer);\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-134-4.c",
            "version": 1.1,
            "compile": "gcc CASTLE-134-4.c -o CASTLE-134-4",
            "vulnerable": true,
            "description": "The format string is sourced fron an input without sanitization",
            "cwe": 134,
            "lines": [
                6,
                21,
                23
            ],
            "id": "134-4",
            "number": 44,
            "hash": "64a02a9101ef187bf03792687bc34d95",
            "line_count": 25,
            "cyclomatic_complexity": 4,
            "nloc": 21,
            "functions": 2,
            "halstead_volume": 749.8694949764811,
            "maintainability_index": 86.33526074848524,
            "cl100k_base_tokens": 156,
            "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid logger(char *msg) {\n    printf(msg);\n}\n\nint main(int argc, char **argv) {\n    char buffer[256];\n    if (fgets(buffer, sizeof(buffer), stdin) == NULL) {\n        return 1;\n    }\n\n    char *hello = \"Hello, \";\n    char *combined = (char*)malloc(strlen(hello) + strlen(buffer) + 1);\n    if (combined == NULL) {\n        return 1;\n    }\n    strncpy(combined, hello, sizeof(combined) - 1);\n    strncat(combined, buffer, sizeof(combined) - strlen(buffer) - 1);\n\n    logger(buffer);\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-134-5.c",
            "version": 1.1,
            "compile": "gcc CASTLE-134-5.c -o CASTLE-134-5",
            "vulnerable": true,
            "description": "The format string is sourced fron an input without sanitization",
            "cwe": 134,
            "lines": [
                6,
                7
            ],
            "id": "134-5",
            "number": 45,
            "hash": "b74ce8df5bc39473479bad4be28ab6fb",
            "line_count": 10,
            "cyclomatic_complexity": 2,
            "nloc": 9,
            "functions": 1,
            "halstead_volume": 255.15831097164298,
            "maintainability_index": 100.0,
            "cl100k_base_tokens": 57,
            "code": "#include <stdio.h>\n\nint main(int argc, char **argv) {\n    if (argc > 1) {\n        char buffer[1024];\n        snprintf(buffer, sizeof(buffer), argv[1]);\n        printf(\"%s\", buffer);\n    }\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-134-6.c",
            "version": 1.1,
            "compile": "gcc CASTLE-134-6.c -o CASTLE-134-6",
            "vulnerable": true,
            "description": "The dynamic parameter selector of the formal string is sourced from an input without sanitization",
            "cwe": 134,
            "lines": [
                17,
                18
            ],
            "id": "134-6",
            "number": 46,
            "hash": "054c6fb22fb977af45097f144959d395",
            "line_count": 21,
            "cyclomatic_complexity": 3,
            "nloc": 17,
            "functions": 1,
            "halstead_volume": 578.6997515755535,
            "maintainability_index": 91.33586817393186,
            "cl100k_base_tokens": 140,
            "code": "#include <stdio.h>\n\nint main(int argc, char **argv) {\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s <number>\\n\", argv[0]);\n        return 1;\n    }\n\n    int id;\n    if (sscanf(argv[1], \"%9d\", &id) != 1) {\n        fprintf(stderr, \"Invalid number: %s\\n\", argv[1]);\n        return 1;\n    }\n\n    char* prefix = \"%\";\n    char formatter[1024];\n    snprintf(formatter, sizeof(formatter), \"%s%d$d\\n\", prefix, id);\n    printf(formatter, id);\n\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-134-7.c",
            "version": 1.1,
            "compile": "gcc CASTLE-134-7.c -o CASTLE-134-7",
            "vulnerable": false,
            "description": "The format string not sourced from outside the program",
            "cwe": 134,
            "lines": [],
            "id": "134-7",
            "number": 47,
            "hash": "cf8a8d7bee07a0f61de2ef482ffcb1f0",
            "line_count": 11,
            "cyclomatic_complexity": 2,
            "nloc": 9,
            "functions": 1,
            "halstead_volume": 228.23460010384647,
            "maintainability_index": 100.0,
            "cl100k_base_tokens": 62,
            "code": "#include <stdio.h>\n\nint main(int argc, char **argv) {\n    if (argc < 2) {\n        printf(\"Usage: %s <text>\\n\", argv[0]);\n        return 1;\n    }\n\n    printf(\"%s\", argv[1]);\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-134-8.c",
            "version": 1.1,
            "compile": "gcc CASTLE-134-8.c -o CASTLE-134-8",
            "vulnerable": false,
            "description": "The format string is sourced fron an input without sanitization",
            "cwe": 134,
            "lines": [],
            "id": "134-8",
            "number": 48,
            "hash": "8b3f8c99c466c2283ea9ddb22db35e9e",
            "line_count": 15,
            "cyclomatic_complexity": 3,
            "nloc": 12,
            "functions": 2,
            "halstead_volume": 315.36542508798107,
            "maintainability_index": 100.0,
            "cl100k_base_tokens": 69,
            "code": "#include <stdio.h>\n\nvoid logger(char *msg) {\n    printf(\"%s\\n\", msg);\n}\n\nint main(int argc, char **argv) {\n    char buffer[256];\n    if (fgets(buffer, sizeof(buffer), stdin) == NULL) {\n        return 1;\n    }\n\n    logger(buffer);\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-134-9.c",
            "version": 1.1,
            "compile": "gcc CASTLE-134-9.c -o CASTLE-134-9",
            "vulnerable": false,
            "description": "The format string is not sourced fron an input without sanitization",
            "cwe": 134,
            "lines": [],
            "id": "134-9",
            "number": 49,
            "hash": "e059cda837f5b34eac018e31546a0276",
            "line_count": 10,
            "cyclomatic_complexity": 2,
            "nloc": 9,
            "functions": 1,
            "halstead_volume": 264.97209216286,
            "maintainability_index": 100.0,
            "cl100k_base_tokens": 60,
            "code": "#include <stdio.h>\n\nint main(int argc, char **argv) {\n    if (argc > 1) {\n        char buffer[1024];\n        snprintf(buffer, sizeof(buffer), \"%s\", argv[1]);\n        printf(\"%s\", buffer);\n    }\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-134-10.c",
            "version": 1.1,
            "compile": "gcc CASTLE-134-10.c -o CASTLE-134-10",
            "vulnerable": false,
            "description": "The format string is sourced fron an input with sufficient sanitization",
            "cwe": 134,
            "lines": [],
            "id": "134-10",
            "number": 50,
            "hash": "701a3abf402193dca58b665b53336e68",
            "line_count": 28,
            "cyclomatic_complexity": 6,
            "nloc": 23,
            "functions": 2,
            "halstead_volume": 613.1066573880208,
            "maintainability_index": 85.44859135290397,
            "cl100k_base_tokens": 141,
            "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\n\nint isValidText(char *input) {\n    for (int i = 0; i < strlen(input); i++) {\n        if (!isalpha(input[i])) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main(int argc, char **argv) {\n    if (argc < 2) {\n        printf(\"Usage: %s <text>\\n\", argv[0]);\n        return 1;\n    }\n\n    if (!isValidText(argv[1])) {\n        printf(\"Invalid parameter!\");\n        return 1;\n    }\n\n    printf(argv[1]);\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-190-1.c",
            "version": 1.1,
            "compile": "gcc CASTLE-190-1.c -o CASTLE-190-1",
            "vulnerable": true,
            "description": "Arithmetic overflow in multiplication.",
            "cwe": 190,
            "lines": [
                6
            ],
            "id": "190-1",
            "number": 51,
            "hash": "2e9fbfa27ffb54917346e9dc7f535f6d",
            "line_count": 10,
            "cyclomatic_complexity": 1,
            "nloc": 9,
            "functions": 1,
            "halstead_volume": 235.5603911808226,
            "maintainability_index": 100.0,
            "cl100k_base_tokens": 54,
            "code": "#include <stdio.h>\n\nint main() {\n    int x=77;\n    int y=x*x*x;\n    int z=y*y;\n    unsigned int r= z/1000;\n    printf(\"Result %u\\n\", r);\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-190-2.c",
            "version": 1.1,
            "compile": "gcc CASTLE-190-2.c -o CASTLE-190-2",
            "vulnerable": true,
            "description": "Integer overflow in atoi function.",
            "cwe": 190,
            "lines": [
                6
            ],
            "id": "190-2",
            "number": 52,
            "hash": "135c740bc0fb88efd3c8dd4fe96e9932",
            "line_count": 10,
            "cyclomatic_complexity": 1,
            "nloc": 8,
            "functions": 1,
            "halstead_volume": 178.6167092893615,
            "maintainability_index": 100.0,
            "cl100k_base_tokens": 43,
            "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    long long int APPLE = atoi(\"3000000000\")+1;\n    printf(\"%lld\\n\", APPLE);\n\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-190-3.c",
            "version": 1.1,
            "compile": "gcc CASTLE-190-3.c -o CASTLE-190-3",
            "vulnerable": true,
            "description": "Integer overflow on addition.",
            "cwe": 190,
            "lines": [
                9
            ],
            "id": "190-3",
            "number": 53,
            "hash": "b60a4a744debccf1d699d754c3b2dd50",
            "line_count": 12,
            "cyclomatic_complexity": 1,
            "nloc": 7,
            "functions": 1,
            "halstead_volume": 149.27754454988144,
            "maintainability_index": 100.0,
            "cl100k_base_tokens": 53,
            "code": "#include <stdio.h>\n\n// INT_MAX 2147483647\n\nint main() {\n    int n = 2147483647;\n\n    printf(\"%d\\n\", n);\n    printf(\"%d\\n\", n + 1);\n\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-190-4.c",
            "version": 1.1,
            "compile": "gcc CASTLE-190-4.c -o CASTLE-190-4",
            "vulnerable": true,
            "description": "Integer overflow on addition (INT_MAX=2147483647).",
            "cwe": 190,
            "lines": [
                8
            ],
            "id": "190-4",
            "number": 54,
            "hash": "4a8bd9aef15fe724985aa91422ae0b60",
            "line_count": 11,
            "cyclomatic_complexity": 1,
            "nloc": 7,
            "functions": 1,
            "halstead_volume": 162.53496664211536,
            "maintainability_index": 100.0,
            "cl100k_base_tokens": 46,
            "code": "#include <stdio.h>\n\n\nint main() {\n    int n = 214748364;\n\n    printf(\"%d\\n\", n);\n    printf(\"%d\\n\", n * 10 + 8);\n\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-190-5.c",
            "version": 1.1,
            "compile": "gcc CASTLE-190-5.c -o CASTLE-190-5",
            "vulnerable": true,
            "description": "Integer overflow after set operations.",
            "cwe": 190,
            "lines": [
                13
            ],
            "id": "190-5",
            "number": 55,
            "hash": "a7a2077992ceefcf0cd0035b697cdfc4",
            "line_count": 19,
            "cyclomatic_complexity": 2,
            "nloc": 14,
            "functions": 1,
            "halstead_volume": 416.756269250316,
            "maintainability_index": 96.41826312374147,
            "cl100k_base_tokens": 92,
            "code": "#include <stdio.h>\n#include <math.h>\n\n\nint main() {\n    int a = 101;\n    int b = a*a*a;\n    int c = b*2+15000;\n    int d = c^15;\n    int e = d;\n\n    for (int i = 0; i < 3; i++) {\n        e *= e;\n    }\n\n    printf(\"%d\\n\", e);\n\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-190-6.c",
            "version": 1.1,
            "compile": "gcc CASTLE-190-6.c -o CASTLE-190-6",
            "vulnerable": true,
            "description": "Floating point underflow caused by big division (1.0e-38 close to the minimal possible float).",
            "cwe": 190,
            "lines": [
                6
            ],
            "id": "190-6",
            "number": 56,
            "hash": "3d815e1cd64167412ee70c4b4114d4e8",
            "line_count": 19,
            "cyclomatic_complexity": 2,
            "nloc": 14,
            "functions": 1,
            "halstead_volume": 315.0,
            "maintainability_index": 97.87389353833953,
            "cl100k_base_tokens": 135,
            "code": "#include <stdio.h>\n#include <float.h>\n\nint main() {\n    float chipWithoutMagnification = 1.0e-38;\n    float chipWithMagnification = chipWithoutMagnification / 1.0e38;\n\n    printf(\"Without: %e\\n\", chipWithoutMagnification);\n    printf(\"With: %e\\n\", chipWithMagnification);\n\n    // Is the resut zero?\n    if (chipWithMagnification == 0.0) {\n        printf(\"The result is zero.\\n\");\n    } else {\n        printf(\"The result is %e\\n\", chipWithMagnification);\n    }\n\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-190-7.c",
            "version": 1.1,
            "compile": "gcc CASTLE-190-7.c -o CASTLE-190-7",
            "vulnerable": false,
            "description": "There are no arithmetic overflows in any of these functions.",
            "cwe": 190,
            "lines": [],
            "id": "190-7",
            "number": 57,
            "hash": "e641410b8d833df0e90106068de778ac",
            "line_count": 63,
            "cyclomatic_complexity": 13,
            "nloc": 51,
            "functions": 5,
            "halstead_volume": 2770.1082978214768,
            "maintainability_index": 63.095887935327305,
            "cl100k_base_tokens": 581,
            "code": "#include <stdio.h>\n\n\nvoid printMatrix(int rows, int cols, int mat[rows][cols]) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"%d \", mat[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nvoid addMatrices(int rows, int cols, int mat1[rows][cols], int mat2[rows][cols], int result[rows][cols]) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = mat1[i][j] + mat2[i][j];\n        }\n    }\n}\n\nvoid scalarMult(int rows, int cols, int mat[rows][cols], int scalar) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            mat[i][j] *= scalar;\n        }\n    }\n}\n\nvoid transpose(int rows, int cols, int mat[rows][cols], int result[cols][rows]) {\n    for (int i = 0; i < cols; i++) {\n        for (int j = 0; j < rows; j++) {\n            result[i][j] = mat[j][i];\n        }\n    }\n}\n\nint main() {\n    int mat1[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    int mat2[3][3] = {{9, 8, 7}, {6, 5, 4}, {3, 2, 1}};\n    int sumMat[3][3] = {0};\n    int scalar = 2;\n    int transMat[3][3] = {0};\n\n    printf(\"Matrix 1:\\n\");\n    printMatrix(3, 3, mat1);\n\n    printf(\"\\nMatrix 2:\\n\");\n    printMatrix(3, 3, mat2);\n\n    printf(\"\\nSum of matrices:\\n\");\n    addMatrices(3, 3, mat1, mat2, sumMat);\n    printMatrix(3, 3, sumMat);\n\n    printf(\"\\nScalar multiplication of matrix 1:\\n\");\n    scalarMult(3, 3, mat1, scalar);\n    printMatrix(3, 3, mat1);\n\n    printf(\"\\nTranspose of matrix 2:\\n\");\n    transpose(3, 3, mat2, transMat);\n    printMatrix(3, 3, transMat);\n\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-190-8.c",
            "version": 1.1,
            "compile": "gcc CASTLE-190-8.c -o CASTLE-190-8",
            "vulnerable": false,
            "description": "There is no arithmetic overflow in any of the the functions.",
            "cwe": 190,
            "lines": [],
            "id": "190-8",
            "number": 58,
            "hash": "5ef849aec84904f397b915e5f0976904",
            "line_count": 151,
            "cyclomatic_complexity": 29,
            "nloc": 123,
            "functions": 8,
            "halstead_volume": 5044.617832441147,
            "maintainability_index": 42.03701211647065,
            "cl100k_base_tokens": 967,
            "code": "#include <stdio.h>\n#include <stdlib.h>\n\n\n#define ROW 5\n#define COL 5\n\nint grid[ROW][COL];\nint visited[ROW][COL];\n\n// Define a struct to hold the x, y coordinates of a cell\ntypedef struct {\n    int x;\n    int y;\n} Point;\n\n// Define a queue to hold points\nstruct Queue {\n    Point arr[ROW*COL];\n    int front, rear;\n};\n\n// Create a new queue\nstruct Queue* newQueue() {\n    struct Queue* queue = (struct Queue*)malloc(sizeof(struct Queue));\n    if (queue == NULL) {\n        return NULL;\n    }\n\n    queue->front = queue->rear = -1;\n    return queue;\n}\n\n// Check if the queue is empty\nint isEmpty(struct Queue* queue) {\n    return queue->front == -1;\n}\n\n// Add a point to the queue\nvoid enqueue(struct Queue* queue, Point point) {\n    queue->rear = (queue->rear + 1) % (ROW*COL);\n    queue->arr[queue->rear] = point;\n    if(queue->front == -1) {\n        queue->front++;\n    }\n}\n\ntypedef struct {\n    Point p;\n    int hasValue;\n} OptionalPoint;\n\n// Remove a point from the queue\nOptionalPoint dequeue(struct Queue* queue) {\n    if (isEmpty(queue)) {\n        Point p = {0, 0};\n        OptionalPoint op = {p, 0};\n        return op;\n    }\n\n    OptionalPoint point = { queue->arr[queue->front], 1 };\n    if(queue->front == queue->rear) {\n        queue->front = queue->rear = -1;\n    } else {\n        queue->front = (queue->front + 1) % (ROW*COL);\n    }\n    return point;\n}\n\n// Check if a given point is valid\nint isValid(int x, int y) {\n    if(x < 0 || x >= ROW || y < 0 || y >= COL) {\n        return 0;\n    }\n    if(grid[x][y] == 1) {\n        return 0;\n    }\n    if(visited[x][y] == 1) {\n        return 0;\n    }\n    return 1;\n}\n\n// Find the shortest path between two points on the grid\nvoid findPath(Point start, Point end) {\n    struct Queue* queue = newQueue();\n    if (queue == NULL) {\n        return;\n    }\n\n    visited[start.x][start.y] = 1;\n    enqueue(queue, start);\n    while(!isEmpty(queue)) {\n        OptionalPoint op = dequeue(queue);\n        if (op.hasValue == 0) {\n            break;\n        }\n        Point curr = op.p;\n        if(curr.x == end.x && curr.y == end.y) {\n            printf(\"Path found!\\n\");\n            free(queue);\n            return;\n        }\n        Point up = {curr.x-1, curr.y};\n        Point down = {curr.x+1, curr.y};\n        Point left = {curr.x, curr.y-1};\n        Point right = {curr.x, curr.y+1};\n        if(isValid(up.x, up.y)) {\n            visited[up.x][up.y] = 1;\n            enqueue(queue, up);\n        }\n        if(isValid(down.x, down.y)) {\n            visited[down.x][down.y] = 1;\n            enqueue(queue, down);\n        }\n        if(isValid(left.x, left.y)) {\n            visited[left.x][left.y] = 1;\n            enqueue(queue, left);\n        }\n        if(isValid(right.x, right.y)) {\n            visited[right.x][right.y] = 1;\n            enqueue(queue, right);\n        }\n    }\n    printf(\"No path found.\\n\");\n    free(queue);\n}\n\n// Initialize the grid and visited arrays\nvoid initialize() {\n    for(int i=0; i<ROW; i++) {\n        for(int j=0; j<COL; j++) {\n            grid[i][j] = 0;\n            visited[i][j] = 0;\n        }\n    }\n    grid[1][0] = 1;\n    grid[1][1] = 1;\n    grid[1][2] = 1;\n    grid[2][1] = 1;\n    grid[3][1] = 1;\n    grid[3][2] = 1;\n}\n\nint main() {\n    initialize();\n    Point start = {0, 0};\n    Point end = {4, 4};\n    findPath(start, end);\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-190-9.c",
            "version": 1.1,
            "compile": "gcc CASTLE-190-9.c -o CASTLE-190-9",
            "vulnerable": false,
            "description": "There are not arithmetic overflows in any of the functions.",
            "cwe": 190,
            "lines": [],
            "id": "190-9",
            "number": 59,
            "hash": "847e337e4eb908848fbca6b32a4a0a87",
            "line_count": 51,
            "cyclomatic_complexity": 9,
            "nloc": 36,
            "functions": 5,
            "halstead_volume": 1213.7371787100392,
            "maintainability_index": 73.94940402487477,
            "cl100k_base_tokens": 363,
            "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint isPowerOfTwo(unsigned int n) {\n    return (n && !(n & (n - 1)));\n}\n\nvoid swap(unsigned int* a_ptr, unsigned int* b_ptr) {\n    if (*a_ptr != *b_ptr) {\n        *a_ptr ^= *b_ptr;\n        *b_ptr ^= *a_ptr;\n        *a_ptr ^= *b_ptr;\n    }\n}\n\nint countSetBits(unsigned int n) {\n    int count = 0;\n    while (n) {\n        n &= (n - 1);\n        count++;\n    }\n    return count;\n}\n\n\nint maximum(int x, int y) {\n    return x ^ ((x ^ y) & -(x < y));\n}\n\nint main() {\n    unsigned int x = 15, y = 20;\n\n    // Check if x is power of 2 or not\n    if (isPowerOfTwo(x))\n        printf(\"%u is power of 2\\n\", x);\n    else\n        printf(\"%u is not power of 2\\n\", x);\n\n    // Swap the values of x and y\n    printf(\"Before swap: x = %u, y = %u\\n\", x, y);\n    swap(&x, &y);\n    printf(\"After swap: x = %u, y = %u\\n\", x, y);\n\n    // Count the number of set bits in x\n    printf(\"Number of set bits in %u is %d\\n\", x, countSetBits(x));\n\n    // Get the maximum of two numbers\n    printf(\"The maximum of %d and %d is %d\\n\", 32, 56, maximum(32, 56));\n\n    return 0;\n}"
        },
        {
            "dataset": "CASTLE-Benchmark",
            "name": "CASTLE-190-10.c",
            "version": 1.1,
            "compile": "gcc CASTLE-190-10.c -o CASTLE-190-10",
            "vulnerable": false,
            "description": "No integer overflow in power_mod function.",
            "cwe": 190,
            "lines": [],
            "id": "190-10",
            "number": 60,
            "hash": "711e62b12fde375922f9f9f2bf167c60",
            "line_count": 46,
            "cyclomatic_complexity": 5,
            "nloc": 34,
            "functions": 2,
            "halstead_volume": 1157.174769762185,
            "maintainability_index": 76.04352829705306,
            "cl100k_base_tokens": 357,
            "code": "#include <stdio.h>\n#include <math.h>\n\nlong long power_mod(long long base, long long exp, long long mod) {\n    long long result = 1;\n    base = base % mod;\n\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % mod;\n        }\n        exp = exp >> 1;\n        base = (base * base) % mod;\n    }\n    return result;\n}\n\nint main() {\n    // Settings\n    long long prime = 37199; // modulus\n    long long base = 5;   // generator\n\n    // Private keys\n    long long alice_private = 19945234904;  // Alice (secret)\n    long long bob_private = 2530476561349134275;   // Bob (secret)\n\n    long long alice_public = power_mod(base, alice_private, prime);\n    printf(\"Alice's public key: %lld\\n\", alice_public);\n\n    long long bob_public = power_mod(base, bob_private, prime);\n    printf(\"Bob's public key: %lld\\n\", bob_public);\n\n    long long alice_shared_secret = power_mod(bob_public, alice_private, prime);\n    printf(\"Alice's shared secret: %lld\\n\", alice_shared_secret);\n\n    long long bob_shared_secret = power_mod(alice_public, bob_private, prime);\n    printf(\"Bob's shared secret: %lld\\n\", bob_shared_secret);\n\n    if (alice_shared_secret == bob_shared_secret) {\n        printf(\"Key exchange successful! Shared secret: %lld\\n\", alice_shared_secret);\n    } else {\n        printf(\"Key exchange failed.\\n\");\n    }\n\n    return 0;\n}"
        }
    ],
    "cwes": {
        "89": {
            "name": "Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')",
            "parents": [
                {
                    "74": "Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')"
                },
                {
                    "943": "Improper Neutralization of Special Elements in Data Query Logic"
                }
            ],
            "children": [
                {
                    "564": "SQL Injection: Hibernate"
                }
            ]
        },
        "78": {
            "name": "Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')",
            "parents": [
                {
                    "74": "Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')"
                },
                {
                    "77": "Improper Neutralization of Special Elements used in a Command ('Command Injection')"
                }
            ],
            "children": []
        },
        "22": {
            "name": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
            "parents": [
                {
                    "668": "Exposure of Resource to Wrong Sphere"
                },
                {
                    "706": "Use of Incorrectly-Resolved Name or Reference"
                }
            ],
            "children": [
                {
                    "23": "Relative Path Traversal"
                },
                {
                    "36": "Absolute Path Traversal"
                }
            ]
        },
        "190": {
            "name": "Integer Overflow or Wraparound",
            "parents": [
                {
                    "20": "Improper Input Validation"
                },
                {
                    "682": "Incorrect Calculation"
                }
            ],
            "children": [
                {
                    "680": "Integer Overflow to Buffer Overflow"
                }
            ]
        },
        "134": {
            "name": "Use of Externally-Controlled Format String",
            "parents": [
                {
                    "668": "Exposure of Resource to Wrong Sphere"
                },
                {
                    "20": "Improper Input Validation"
                }
            ],
            "children": []
        }
    },
    "prompt": "You are a professional security analyst reviewing C code for vulnerabilities.\nYou will list the found vulnerabilities in a JSON format using the **EXACT** template below:\n\n```json\n[\n    {\"severity\": string, \"line\": int, \"cwe\": int, \"message\": string, \"line_content\": string},\n    ...\n]\n```\n### Rules:\n1. **DO NOT OMIT** the triple backticks (```json at the beginning and ``` at the end).\n2. **DO NOT RETURN RAW JSON** without enclosing it in triple backticks.\n3. If you did not find any vulnerabilities, return an empty list.\n4. If you don’t know the CWE number, set \"cwe\": 0.\n5. You MUST follow this format EXACTLY. **Any response that does not follow the above format is INVALID.**\n\nYou get 5 points for each vulnerability you find, but get -1 for all false positives you report.\nNow, review the following C code and return your response:\n"
}