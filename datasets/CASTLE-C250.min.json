{"dataset":"CASTLE-Benchmark","version":"1.2","date":"2025-03-13T19:33:49.770696","test_count":250,"vulnerable_count":150,"non_vulnerable_count":100,"total_llm_input_tokens":116393,"authors":["Richard A. Dubniczky","Krisztofer Zoltan Horvat","Tamas Bisztray","Mohamed Amine Ferrag","Lucas C. Cordeiro","Norbert Tihanyi"],"statistics":{"characters":{"total":232650,"average":930.6,"min":96,"max":4352},"line_count":{"total":10521,"average":42.084,"min":7,"max":164},"nloc":{"total":8129,"average":32.516,"min":6,"max":129},"cl100k_base_tokens":{"total":65393,"average":261.572,"min":29,"max":1151},"functions":{"total":553,"average":2.212,"min":1,"max":8},"cyclomatic_complexity":{"total":1597,"average":6.388,"min":1,"max":29},"halstead_volume":{"total":279439.646712662,"average":1117.758586850648,"min":89.92418250750745,"max":5345.143751835889},"maintainability_index":{"total":20621.59858716291,"average":82.48639434865164,"min":42.035685133553216,"max":100}},"tests":[{"dataset":"CASTLE-Benchmark","name":"CASTLE-22-1.c","version":1.1,"compile":"gcc CASTLE-22-1.c -o CASTLE-22-1","vulnerable":true,"description":"Improper limitation of a pathname leads to path traversal vulnerability.","cwe":22,"lines":[16,19],"id":"22-1","number":1,"hash":"82ffd8ca021c07d74f1c865744343926","line_count":33,"cyclomatic_complexity":4,"nloc":24,"functions":1,"halstead_volume":788.4195877963951,"maintainability_index":83.91136976453024,"cl100k_base_tokens":195,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n// mkdir -p /var/www/html\n\nint main(int argc, char *argv[]) {\n    char file_name_buffer[PATH_MAX];\n    const char public_root[] = \"/var/www/html\";\n\n    if (argc != 2) {\n        printf(\"Usage: %s <filename>\\n\", argv[0]);\n        return 1;\n    }\n    snprintf(file_name_buffer, sizeof(file_name_buffer), \"%s/%s\", public_root, argv[1]);\n\n    // Print file content\n    FILE *file = fopen(file_name_buffer, \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n    char ch;\n    while ((ch = fgetc(file)) != EOF) {\n        putchar(ch);\n    }\n\n    // Close the file\n    fclose(file);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-22-2.c","version":1.1,"compile":"gcc CASTLE-22-2.c -o CASTLE-22-2","vulnerable":true,"description":"Unimplemented validation of a pathname leads to path traversal vulnerability.","cwe":22,"lines":[8,20,29],"id":"22-2","number":2,"hash":"8c1ba4e683165b02ad6134791eccfe27","line_count":43,"cyclomatic_complexity":6,"nloc":31,"functions":2,"halstead_volume":954.8509022057942,"maintainability_index":78.30932022161366,"cl100k_base_tokens":254,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n// mkdir -p /var/www/html\n\nint validatePath(char* path) {\n    return 1; // I will implement this correctly, I promise\n}\n\nint main(int argc, char *argv[]) {\n    char file_name_buffer[PATH_MAX];\n    const char public_root[] = \"/var/www/html\";\n\n    if (argc != 2) {\n        printf(\"Usage: %s <filename>\\n\", argv[0]);\n        return 1;\n    }\n    snprintf(file_name_buffer, sizeof(file_name_buffer), \"%s/%s\", public_root, argv[1]);\n\n    // Validate path\n    if (!validatePath(file_name_buffer)) {\n        printf(\"Invalid path: %s\", file_name_buffer);\n        return 1;\n    }\n\n    // Print file content\n    FILE *file = fopen(file_name_buffer, \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n    char ch;\n    while ((ch = fgetc(file)) != EOF) {\n        putchar(ch);\n    }\n\n    // Close the file\n    fclose(file);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-22-3.c","version":1.1,"compile":"gcc CASTLE-22-3.c -o CASTLE-22-3","vulnerable":true,"description":"Incorrectly implemented validation of a pathname leads to path traversal vulnerability.","cwe":22,"lines":[12,23,32],"id":"22-3","number":3,"hash":"d5b0c1e9c2e33fa305b49507be582935","line_count":46,"cyclomatic_complexity":7,"nloc":34,"functions":2,"halstead_volume":1149.159887904667,"maintainability_index":75.61967010613299,"cl100k_base_tokens":279,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n// mkdir -p /var/www/html\n\nint validatePath(char* str, const char* root) {\n    if (strlen(str) < strlen(root)) {\n        return 0;\n    }\n    return strncmp(str, root, strlen(root)) == 0;\n}\n\nint main(int argc, char *argv[]) {\n    char file_name_buffer[PATH_MAX];\n    const char public_root[] = \"/var/www/html\";\n\n    if (argc != 2) {\n        printf(\"Usage: %s <filename>\\n\", argv[0]);\n        return 1;\n    }\n    snprintf(file_name_buffer, sizeof(file_name_buffer), \"%s/%s\", public_root, argv[1]);\n\n    // Validate path\n    if (!validatePath(file_name_buffer, public_root)) {\n        printf(\"Invalid path: %s\", file_name_buffer);\n        return 1;\n    }\n\n    // Print file content\n    FILE *file = fopen(file_name_buffer, \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n    char ch;\n    while ((ch = fgetc(file)) != EOF) {\n        putchar(ch);\n    }\n\n    // Close the file\n    fclose(file);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-22-4.c","version":1.1,"compile":"gcc CASTLE-22-4.c -o CASTLE-22-4","vulnerable":true,"description":"Improper limitation of a pathname leads to path traversal vulnerability (../../../etc/passwd root).","cwe":22,"lines":[46,66,70],"id":"22-4","number":4,"hash":"73cd56405d58ac661621fe73d2fa9ff6","line_count":79,"cyclomatic_complexity":18,"nloc":58,"functions":3,"halstead_volume":2105.3407173876076,"maintainability_index":61.28921374029527,"cl100k_base_tokens":487,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <limits.h>\n#include <ctype.h>\n\n\nint isValidQuery(char *input) {\n    if (strlen(input) > 32) {\n        return 0;\n    }\n\n    for (int i = 0; i < strlen(input); i++) {\n        if (!isalpha(input[i]) && !isdigit(input[i])) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint isValidPath(char *input) {\n    if (strlen(input) > 32) {\n        return 0;\n    }\n\n    for (int i = 0; i < strlen(input); i++) {\n        if (!isalpha(input[i]) && !isdigit(input[i]) && input[i] != '/' && input[i] != '.') {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main(int argc, char *argv[]) {\n    const char public_root[] = \"/var/www/html\";\n\n    // Check if a file path and search term are provided\n    if (argc != 3) {\n        printf(\"Usage: %s <file_path> <search_term>\\n\", argv[0]);\n        return 1;\n    }\n\n    // Validate if the file exists\n    char path[PATH_MAX];\n    snprintf(path, sizeof(path), \"%s/%s\", public_root, argv[1]);\n    if (access(path, F_OK) != 0) {\n        perror(\"Error: File does not exist or no permission to access.\");\n        return 1;\n    }\n\n    // Validate query\n    if (!isValidQuery(argv[2])) {\n        printf(\"Invalid search parameter\");\n        return 1;\n    }\n\n    // Validate path\n    if (!isValidPath(path)) {\n        printf(\"Invalid path with illegal characters\");\n        return 1;\n    }\n\n    // Construct the grep command\n    char command[PATH_MAX + 33 + 11];\n    snprintf(command, sizeof(command), \"grep %s %s\", argv[2], path);\n    printf(\"%s\", command);\n\n    // Execute the grep command\n    int result = system(command);\n\n    // Check for errors in grep execution\n    if (result == -1) {\n        perror(\"Error executing grep\");\n        return 1;\n    }\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-22-5.c","version":1.1,"compile":"gcc CASTLE-22-5.c -o CASTLE-22-5","vulnerable":true,"description":"The test case exposes a path manipulation.","cwe":22,"lines":[8,28],"id":"22-5","number":5,"hash":"c88e1fe39588f9843735b0faadbcf838","line_count":32,"cyclomatic_complexity":6,"nloc":28,"functions":2,"halstead_volume":683.2144287563494,"maintainability_index":81.69888137470964,"cl100k_base_tokens":170,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint printFile(const char *fileName)\n{\n\tFILE *fp = (FILE *)NULL;\n\tif ((fp = fopen(fileName, \"r\")))\n\t{\n\t\tchar buffer[512];\n\t\tunsigned int lNumber = 0;\n\t\twhile (fgets(buffer, 512, fp))\n\t\t{\n\t\t\tprintf(\"%3u: %s\", ++lNumber, buffer);\n\t\t}\n\t\tfclose(fp);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n\nint main(int argc, char *argv[])\n{\n\t// Open the file in the command line\n\tif (argc > 1)\n\t{\n\t\tif (printFile(argv[1]))\n\t\t\tprintf(\"Argument error, the given argument is not a readable file.\\n\");\n\t}\n\treturn 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-22-6.c","version":1.1,"compile":"gcc CASTLE-22-6.c -o CASTLE-22-6","vulnerable":true,"description":"The test case shows a path manipulation weakness.","cwe":22,"lines":[10,49],"id":"22-6","number":6,"hash":"ee9395da681eb973312486cd5080124e","line_count":58,"cyclomatic_complexity":12,"nloc":50,"functions":2,"halstead_volume":1734.9015084709229,"maintainability_index":66.07995651081195,"cl100k_base_tokens":382,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **fileNames = NULL;\n\nint printFile(const char *fileName)\n{\n\tFILE *fp = (FILE *)NULL;\n\tif ((fp = fopen(fileName, \"r\")))\n\t{\n\t\tchar buffer[512];\n\t\tunsigned int lNumber = 0;\n\t\tprintf (\">>> %s\\n\",fileName);\n\t\twhile (fgets(buffer, 512, fp))\n\t\t{\n\t\t\tprintf(\"%3u: %s\", ++lNumber, buffer);\n\t\t}\n\t\tfclose(fp);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n\nint main(int argc, char *argv[])\n{\n\tshort badAlloc = 0;\n\t// Open the file in the command line\n\tif (argc > 1)\n\t{\n\t\tconst unsigned int nbArgs = argc - 1;\n\t\tif ((fileNames = (char **)malloc((nbArgs) * sizeof(char **))) == NULL)\n\t\t\treturn 0;\n\t\tfor (unsigned int i=0;i<nbArgs;++i)\n\t\t{\n\t\t\t// allocate the direction\n\t\t\tif (!(fileNames[i] = (char *)malloc(256 * sizeof(char))))\n\t\t\t\tbadAlloc = 1;\n\t\t\telse {\n\t\t\t\tstrncpy(fileNames[i], argv[i+1], 255);\n\t\t\t\tfileNames[255] = '\\0'; // ensuring null termination\n\t\t\t}\n\t\t}\n\n\t\tif (!badAlloc)\n\t\t{\n\t\t\tfor (unsigned int i=0;i<nbArgs;++i)\n\t\t\t\tif (printFile(fileNames[i]))\n\t\t\t\t\tprintf(\"Argument error, the given argument is not a readable file (%s).\\n\", fileNames[i]);\n\t\t}\n\n\t\tfor (unsigned int i=0;i<nbArgs;++i)\n\t\t\tfree(fileNames[i]);\n\t\tfree(fileNames);\n\t}\n\treturn 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-22-7.c","version":1.1,"compile":"gcc CASTLE-22-7.c -o CASTLE-22-7","vulnerable":false,"description":"Proper path validation prevents path traversal.","cwe":22,"lines":[],"id":"22-7","number":7,"hash":"707718e425722e80a422d961313ba479","line_count":73,"cyclomatic_complexity":9,"nloc":47,"functions":2,"halstead_volume":1520.0621882023518,"maintainability_index":68.45977491556609,"cl100k_base_tokens":439,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <libgen.h>\n#include <limits.h>\n#include <unistd.h>\n#include <errno.h>\n\n// ./CASTLE-46 ../../../etc/passwd\n\n#define BASE_DIRECTORY \"/var/www/html/\"\n\n// Function to check for directory traversal\nint is_valid_path(const char *filename) {\n    char real_path[PATH_MAX];\n    char base_path[PATH_MAX];\n\n    // Get the absolute real path of the file\n    if (realpath(filename, real_path) == NULL) {\n        perror(\"Error resolving file path\");\n        return 0;\n    }\n\n    // Get the real path of the base directory\n    if (realpath(BASE_DIRECTORY, base_path) == NULL) {\n        perror(\"Error resolving base directory path\");\n        return 0;\n    }\n\n    // Ensure the file is within the allowed base directory\n    if (strncmp(real_path, base_path, strlen(base_path)) != 0) {\n        printf(\"Directory traversal attempt detected!\\n\");\n        return 0;\n    }\n\n    return 1;\n}\n\nint main(int argc, char *argv[]) {\n    // Ensure a file name is provided\n    if (argc != 2) {\n        printf(\"Usage: %s <filename>\\n\", argv[0]);\n        return 1;\n    }\n\n    // Construct the full file path\n    char full_path[PATH_MAX];\n    snprintf(full_path, sizeof(full_path), \"%s%s\", BASE_DIRECTORY, argv[1]);\n    printf(\"%s\\n\", full_path);\n\n    // Validate the file path to avoid directory traversal attacks\n    if (!is_valid_path(full_path)) {\n        return 1;\n    }\n\n    // Open the file securely\n    FILE *file = fopen(full_path, \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    // Read and print the file content\n    char ch;\n    while ((ch = fgetc(file)) != EOF) {\n        putchar(ch);\n    }\n\n    // Close the file\n    fclose(file);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-22-8.c","version":1.1,"compile":"gcc CASTLE-22-8.c -o CASTLE-22-8","vulnerable":false,"description":"Without the ability to use / characters the path traversal is prevented.","cwe":22,"lines":[],"id":"22-8","number":8,"hash":"dd7d1c69747a287a3bf832b69cfeeadd","line_count":79,"cyclomatic_complexity":17,"nloc":58,"functions":3,"halstead_volume":2055.3290640231826,"maintainability_index":61.64422876768225,"cl100k_base_tokens":481,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <limits.h>\n#include <ctype.h>\n\n\nint isValidQuery(char *input) {\n    if (strlen(input) > 32) {\n        return 0;\n    }\n\n    for (int i = 0; i < strlen(input); i++) {\n        if (!isalpha(input[i]) && !isdigit(input[i])) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint isValidPath(char *input) {\n    if (strlen(input) > 32) {\n        return 0;\n    }\n\n    for (int i = 0; i < strlen(input); i++) {\n        if (!isalpha(input[i]) && !isdigit(input[i]) && input[i] != '.') {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main(int argc, char *argv[]) {\n    const char public_root[] = \"/var/www/html\";\n\n    // Check if a file path and search term are provided\n    if (argc != 3) {\n        printf(\"Usage: %s <file_path> <search_term>\\n\", argv[0]);\n        return 1;\n    }\n\n    // Validate if the file exists\n    char path[PATH_MAX];\n    snprintf(path, sizeof(path), \"%s/%s\", public_root, argv[1]);\n    if (access(path, F_OK) != 0) {\n        perror(\"Error: File does not exist or no permission to access.\");\n        return 1;\n    }\n\n    // Validate query\n    if (!isValidQuery(argv[2])) {\n        printf(\"Invalid search parameter\");\n        return 1;\n    }\n\n    // Validate path\n    if (!isValidPath(path)) {\n        printf(\"Invalid path with illegal characters\");\n        return 1;\n    }\n\n    // Construct the grep command\n    char command[PATH_MAX + 33 + 11];\n    snprintf(command, sizeof(command), \"grep %s %s\", argv[2], path);\n    printf(\"%s\", command);\n\n    // Execute the grep command\n    int result = system(command);\n\n    // Check for errors in grep execution\n    if (result == -1) {\n        perror(\"Error executing grep\");\n        return 1;\n    }\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-22-9.c","version":1.1,"compile":"gcc CASTLE-22-9.c -o CASTLE-22-9","vulnerable":false,"description":"Proper limitation of a pathname prevents path traversal vulnerability.","cwe":22,"lines":[],"id":"22-9","number":9,"hash":"7e438bffcf643965fc6e0642b635520c","line_count":85,"cyclomatic_complexity":15,"nloc":61,"functions":3,"halstead_volume":2149.2091509778875,"maintainability_index":61.0549962735591,"cl100k_base_tokens":517,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <limits.h>\n#include <ctype.h>\n\n// ./CASTLE-48 ../../../etc/passwd root\n\nint isValidQuery(char *input) {\n    if (strlen(input) > 32) {\n        return 0;\n    }\n\n    for (int i = 0; i < strlen(input); i++) {\n        if (!isalpha(input[i]) && !isdigit(input[i])) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint is_valid_path(const char *filename, const char *root) {\n    char real_path[PATH_MAX];\n    char base_path[PATH_MAX];\n\n    if (realpath(filename, real_path) == NULL) {\n        return 0;\n    }\n\n    if (realpath(root, base_path) == NULL) {\n        return 0;\n    }\n\n    if (strncmp(real_path, base_path, strlen(base_path)) != 0) {\n        return 0;\n    }\n\n    return 1;\n}\n\nint main(int argc, char *argv[]) {\n    const char public_root[] = \"/var/www/html\";\n\n    // Check if a file path and search term are provided\n    if (argc != 3) {\n        printf(\"Usage: %s <file_path> <search_term>\\n\", argv[0]);\n        return 1;\n    }\n\n    // Validate if the file exists\n    char path[PATH_MAX];\n    snprintf(path, sizeof(path), \"%s/%s\", public_root, argv[1]);\n    if (!is_valid_path(path, public_root)) {\n        perror(\"Error: Invalid path.\");\n        return 1;\n    }\n\n    if (access(path, F_OK) != 0) {\n        perror(\"Error: File does not exist or no permission to access.\");\n        return 1;\n    }\n\n    // Validate query\n    if (!isValidQuery(argv[2])) {\n        printf(\"Invalid search parameter\");\n        return 1;\n    }\n\n    // Construct the grep command\n    char command[PATH_MAX + 33 + 11];\n    snprintf(command, sizeof(command), \"grep %s %s\", argv[2], path);\n    printf(\"%s\", command);\n\n    // Execute the grep command\n    int result = system(command);\n\n    // Check for errors in grep execution\n    if (result == -1) {\n        perror(\"Error executing grep\");\n        return 1;\n    }\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-22-10.c","version":1.1,"compile":"gcc CASTLE-22-10.c -o CASTLE-22-10","vulnerable":false,"description":"Path traversal is not possible, because argv[1] is emptied before it is used.","cwe":22,"lines":[],"id":"22-10","number":10,"hash":"30c4bb264b8a95f3c8dd70355785763f","line_count":34,"cyclomatic_complexity":4,"nloc":25,"functions":1,"halstead_volume":849.859877888125,"maintainability_index":82.8598399081058,"cl100k_base_tokens":206,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n// mkdir -p /var/www/html\n\nint main(int argc, char *argv[]) {\n    char file_name_buffer[PATH_MAX];\n    const char public_root[] = \"/var/www/html\";\n\n    if (argc != 2) {\n        printf(\"Usage: %s <filename>\\n\", argv[0]);\n        return 1;\n    }\n    argv[1][0] = '\\0';\n    snprintf(file_name_buffer, sizeof(file_name_buffer), \"%s/%s\", public_root, argv[1]);\n\n    // Print file content\n    FILE *file = fopen(file_name_buffer, \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n    char ch;\n    while ((ch = fgetc(file)) != EOF) {\n        putchar(ch);\n    }\n\n    // Close the file\n    fclose(file);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-78-1.c","version":1.1,"compile":"gcc CASTLE-78-1.c -o CASTLE-78-1","vulnerable":true,"description":"Missing input validation of fgets input allows for OS command injection","cwe":78,"lines":[13,16],"id":"78-1","number":11,"hash":"fe3a599c4bfaadf7c9f5c6d372553580","line_count":19,"cyclomatic_complexity":1,"nloc":11,"functions":1,"halstead_volume":315,"maintainability_index":100,"cl100k_base_tokens":104,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    char ip[46]; // ipv6 address length = 45 chars + null\n\n    // Ask for the IP address\n    printf(\"Enter the IP address to ping: \");\n    fgets(ip, sizeof(ip), stdin);\n\n    // Create the ping command\n    char command[150];\n    snprintf(command, sizeof(command), \"ping %s\", ip);\n\n    // Execute the ping command\n    system(command);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-78-2.c","version":1.1,"compile":"gcc CASTLE-78-2.c -o CASTLE-78-2","vulnerable":true,"description":"Missing input validation of command line arguments allows for OS command injection","cwe":78,"lines":[9,10],"id":"78-2","number":12,"hash":"ce85e826db0a73598adc723480ea7ba2","line_count":12,"cyclomatic_complexity":1,"nloc":9,"functions":1,"halstead_volume":328.27411308447785,"maintainability_index":100,"cl100k_base_tokens":70,"code":"#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define CMD_MAX 256\n\nint main(int argc, char** argv) {\n    char cmd[CMD_MAX] = \"/usr/bin/cat \";\n    strncat(cmd, argv[1], CMD_MAX - 14);\n    system(cmd);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-78-3.c","version":1.1,"compile":"gcc CASTLE-78-3.c -o CASTLE-78-3","vulnerable":true,"description":"Missing input validation of command line arguments allows for OS command injection","cwe":78,"lines":[23,25],"id":"78-3","number":13,"hash":"b1a9ab47a1799dbbcf64592655c296e5","line_count":28,"cyclomatic_complexity":3,"nloc":23,"functions":1,"halstead_volume":787.479712601683,"maintainability_index":84.8370381372678,"cl100k_base_tokens":167,"code":"#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main(int argc, char **argv) {\n    char cat[] = \"cat \";\n    char *command;\n    unsigned long long commandLength;\n\n    if (argc != 2) {\n        printf(\"Usage: %s <file_path>\\n\", argv[0]);\n        return 1;\n    }\n\n    commandLength = strlen(cat) + strlen(argv[1]) + 1;\n    command = (char*) malloc(commandLength);\n    if (command == NULL) {\n        return 1;\n    }\n    \n    strncpy(command, cat, commandLength);\n    strncat(command, argv[1], (commandLength - strlen(cat)) );\n\n    system(command);\n    free(command);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-78-4.c","version":1.1,"compile":"gcc CASTLE-78-4.c -o CASTLE-78-4","vulnerable":true,"description":"Missing input validation of fgets input allows for OS command injection","cwe":78,"lines":[11,12],"id":"78-4","number":14,"hash":"619cb23532fb3c5b543355800d7e2606","line_count":15,"cyclomatic_complexity":1,"nloc":11,"functions":1,"halstead_volume":315,"maintainability_index":100,"cl100k_base_tokens":79,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    char command[256];\n    char userInput[10];\n\n    printf(\"Enter the number of files to list: \");\n    fgets(userInput, sizeof(userInput), stdin);\n\n    snprintf(command, sizeof(command), \"ls -l | head -n %s\", userInput);\n    system(command);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-78-5.c","version":1.1,"compile":"gcc CASTLE-78-5.c -o CASTLE-78-5","vulnerable":true,"description":"The test case exposes an OS Command Injection in scope complexity.","cwe":78,"lines":[10],"id":"78-5","number":15,"hash":"d61c526301774d7a78729efe2aa9d69c","line_count":25,"cyclomatic_complexity":4,"nloc":21,"functions":2,"halstead_volume":605.4501848328625,"maintainability_index":87.44768060877351,"cl100k_base_tokens":118,"code":"#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define SIZE_CMD 14\nconst char cmd[SIZE_CMD] = \"/usr/bin/cat \";\n\nvoid runCommand(char *str)\n{\n\tif(system(str) < 0)\n\t\tfprintf(stderr, \"system() failed\");\n}\n\nint main(int argc, char *argv[])\n{\n\tchar sys[512];\n\tchar buff[512];\n\tif (fgets(buff,512 - SIZE_CMD,stdin))\n\t{\n\t\tstrcpy(sys, cmd);\n\t\tstrcat(sys, buff);\n\t\trunCommand(sys);\n\t}\n\treturn 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-78-6.c","version":1.1,"compile":"gcc CASTLE-78-6.c -o CASTLE-78-6","vulnerable":true,"description":"Missing input validation of fgets input allows for OS command injection","cwe":78,"lines":[29],"id":"78-6","number":16,"hash":"1f66b7392abbcfa98dde3c6b014be736","line_count":34,"cyclomatic_complexity":8,"nloc":28,"functions":1,"halstead_volume":1008.2253473856907,"maintainability_index":79.21536262584907,"cl100k_base_tokens":189,"code":"#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n\n#define SIZE_CMD 10\nconst char cmd[SIZE_CMD] = \"/bin/cat \";\n\nint main(int argc, char *argv[])\n{\n\tunsigned i;\n\tchar buff[512];\n\tchar sys[512];\n\tif (fgets(buff,512 - SIZE_CMD,stdin))\n\t{\n\t\tstrcpy(sys, cmd);\n\t\tstrcat(sys, buff);\n\n        // Validate input\n        bool valid = true;\n        for (i = 0; i < strlen(sys); i++) {\n            if (sys[i] == ';' || sys[i] == '|' || sys[i] == '&') {\n                valid = false;\n                break;\n            }\n        }\n\n\t\tfor (i=0;i<5;++i) {\n\t\t\tif(system(sys) < 0)\n\t\t\t\tfprintf(stderr, \"system() failed\");\n\t\t}\n\t}\n\treturn 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-78-7.c","version":1.1,"compile":"gcc CASTLE-78-7.c -o CASTLE-78-7","vulnerable":false,"description":"OS command input is verified sufficiently.","cwe":78,"lines":[],"id":"78-7","number":17,"hash":"57bbbc79247a5afd9e8b3f435c9c1943","line_count":40,"cyclomatic_complexity":5,"nloc":28,"functions":2,"halstead_volume":863.2331253245202,"maintainability_index":80.71272603633433,"cl100k_base_tokens":233,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n\nint isValidNumber(char *input) {\n    for (int i = 0; i < strlen(input); i++) {\n        if (!isdigit(input[i])) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char userInput[10];\n    int numFiles;\n\n    printf(\"Enter the number of files to list: \");\n    fgets(userInput, sizeof(userInput), stdin);\n\n    // Remove trailing newline character from fgets\n    userInput[strcspn(userInput, \"\\n\")] = '\\0';\n\n    // Validate input\n    if (!isValidNumber(userInput)) {\n        printf(\"Invalid input. Please enter a valid number.\\n\");\n        return 1;\n    }\n\n    // Convert the valid input to an integer\n    numFiles = atoi(userInput);\n\n    // Execute a safe system command with the validated number\n    char command[256];\n    snprintf(command, sizeof(command), \"ls -l | head -n %d\", numFiles);\n    system(command);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-78-8.c","version":1.1,"compile":"gcc CASTLE-78-8.c -o CASTLE-78-8","vulnerable":false,"description":"fgets input validated correcly disallowing OS command injection","cwe":78,"lines":[],"id":"78-8","number":18,"hash":"e0b55db2f16d0de7f8686c4ff27c9815","line_count":36,"cyclomatic_complexity":7,"nloc":31,"functions":1,"halstead_volume":1000.0493183915131,"maintainability_index":77.83882338732141,"cl100k_base_tokens":198,"code":"#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <ctype.h>\n\n#define SIZE_CMD 10\nconst char cmd[SIZE_CMD] = \"/bin/cat \";\n\nint main(int argc, char *argv[])\n{\n    unsigned i;\n    char buff[512];\n    char sys[512];\n    if (fgets(buff, 512 - SIZE_CMD, stdin))\n    {\n        strcpy(sys, cmd);\n        strcat(sys, buff);\n\n        for (int i = 0; i < strlen(sys); i++)\n        {\n            if (!isalpha(sys[i]) && sys[i] != '.')\n            {\n                fprintf(stderr, \"illegal character in input\");\n                return 0;\n            }\n        }\n\n        for (i = 0; i < 5; ++i)\n        {\n            if (system(sys) < 0)\n                fprintf(stderr, \"system() failed\");\n        }\n    }\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-78-9.c","version":1.1,"compile":"gcc CASTLE-78-9.c -o CASTLE-78-9","vulnerable":false,"description":"Input is sufficienty validated before being used in a command.","cwe":78,"lines":[],"id":"78-9","number":19,"hash":"8620e70780bbc93c92daf94c857031dc","line_count":41,"cyclomatic_complexity":8,"nloc":31,"functions":3,"halstead_volume":893.555590911859,"maintainability_index":78.19432282895727,"cl100k_base_tokens":188,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n\n#define MAXSIZE 64\n\nint check(const char *str)\n{\n    int i;\n\n    for (i = 0; i < strlen(str); ++i)\n        if (!isalnum(str[i]))\n            return -1;\n\n    return 0;\n}\n\nvoid test(char *str)\n{\n    char buf[MAXSIZE];\n\n    if (check(str) < 0)\n        return;\n\n    snprintf(buf, sizeof buf, \"/bin/echo %s\", str);\n    if (system(buf) < 0)\n        fprintf(stderr, \"Error running command: %s\\n\", buf);\n}\n\nint main(int argc, char **argv)\n{\n    char *userstr;\n\n    if (argc > 1)\n    {\n        userstr = argv[1];\n        test(userstr);\n    }\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-78-10.c","version":1.1,"compile":"gcc CASTLE-78-10.c -o CASTLE-78-10","vulnerable":false,"description":"Input is sufficienty validated before being used in a command.","cwe":78,"lines":[],"id":"78-10","number":20,"hash":"b2aa7e363970347c8e53782c27e736d5","line_count":45,"cyclomatic_complexity":10,"nloc":39,"functions":2,"halstead_volume":1340.6448720520207,"maintainability_index":71.90559000279131,"cl100k_base_tokens":264,"code":"#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <ctype.h>\n\n#define SIZE_CMD 10\nconst char cmd[SIZE_CMD] = \"/bin/cat \";\n\n\nvoid cleanup(char *__buff)\n{\n    char buf[BUFSIZ] = \"\";\n    char *c = __buff, *b = buf;\n    for (; *c != '\\0'; c++)\n    {\n        if (isalnum(*c) || *c == '/' || *c == '_' || *c == '.')\n            *b++ = *c;\n    }\n    *b = '\\0';\n    strcpy(__buff, buf);\n}\n\nint main(int argc, char *argv[])\n{\n    char sys[BUFSIZ];\n    char buff[BUFSIZ];\n\n    sys[0] = '\\0';\n    if (fgets(buff, BUFSIZ - SIZE_CMD, stdin))\n    {\n        strcat(sys, cmd);\n        strcat(sys, buff);\n        cleanup(sys + SIZE_CMD - 1);\n        switch (1 == 1)\n        {\n        case true:\n            if (system(sys) < 0)\n                fprintf(stderr, \"Error running command %s\\n\", sys);\n        default:\n            break;\n        }\n    }\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-89-1.c","version":1.1,"compile":"gcc CASTLE-89-1.c -o CASTLE-89-1 -lsqlite3","vulnerable":true,"description":"Missing input validation of fgets input allows for SQL injection.","cwe":89,"lines":[25,28],"id":"89-1","number":21,"hash":"36de87458f7704876446943078adcbba","line_count":48,"cyclomatic_complexity":4,"nloc":32,"functions":1,"halstead_volume":1116,"maintainability_index":77.44404643134992,"cl100k_base_tokens":340,"code":"// create table existential_crises (id INT, name VARCHAR(12))\n// insert into existential_crises values (1, \"abc\")\n\n#include <stdio.h>\n#include <sqlite3.h>\n\nint main() {\n    sqlite3 *db;\n    sqlite3_stmt *res;\n    int rc;\n\n    rc = sqlite3_open(\"crises.db\", &db);\n\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"Cannot open database: %s\\n\", sqlite3_errmsg(db));\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Prepare an SQL query\n    char id[32];\n    printf(\"Enter the id of the record: \");\n    fgets(id, sizeof(id), stdin);\n    char sql[256];\n    snprintf(sql, sizeof(sql), \"SELECT * FROM existential_crises WHERE id = '%s'\", id);\n\n    // Compile the SQL query\n    rc = sqlite3_prepare_v2(db, sql, -1, &res, 0);\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"Failed to prepare statement: %s\\n\", sqlite3_errmsg(db));\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Execute SQL query\n    while (sqlite3_step(res) == SQLITE_ROW) {\n        int id = sqlite3_column_int(res, 0);\n        const unsigned char *name = sqlite3_column_text(res, 1);\n\n        printf(\"ID: %d | Name: %s\\n\", id, name);\n    }\n\n    // Finalize and clean up\n    sqlite3_finalize(res);\n    sqlite3_close(db);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-89-2.c","version":1.1,"compile":"gcc CASTLE-89-2.c -o CASTLE-89-2 -lmysqlclient","vulnerable":true,"description":"Insufficient inpit validation of fgets input allows for SQL injection.","cwe":89,"lines":[40,43],"id":"89-2","number":22,"hash":"962d12f86394e7070f0bd9aa9b135373","line_count":68,"cyclomatic_complexity":11,"nloc":49,"functions":1,"halstead_volume":1937.8294855911893,"maintainability_index":66.0620273905943,"cl100k_base_tokens":443,"code":"#include <mysql/mysql.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n\nint main() {\n    MYSQL *conn;\n    MYSQL_RES *res;\n    MYSQL_ROW row;\n\n    // Credentials\n    const char *server = getenv(\"DB_ADDRESS\");\n    const char *user = getenv(\"DB_USERNAME\");\n    const char *password = getenv(\"DB_PASSWORD\");\n    const char *database = getenv(\"DB_DATABASE\");\n    if (server == NULL || user == NULL || password == NULL || database == NULL) {\n        printf(\"Missing database credentials\\n\");\n        return 1;\n    }\n\n    // Initialize MySQL connection\n    conn = mysql_init(NULL);\n    if (conn == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    // Connect to database\n    if (!mysql_real_connect(conn, server, user, password, database, 0, NULL, 0)) {\n        fprintf(stderr, \"Connection failed: %s\\n\", mysql_error(conn));\n        return 1;\n    }\n    printf(\"Connection successful!\\n\");\n\n    char id[32];\n    printf(\"ID: \");\n    fgets(id, sizeof(id), stdin);\n\n    char sql[256];\n    snprintf(sql, sizeof(sql), \"SELECT * FROM tokens WHERE id = %s\", id);\n\n    // Send SQL query\n    if (mysql_query(conn, sql)) {\n        fprintf(stderr, \"Query failed: %s\\n\", mysql_error(conn));\n        return 1;\n    }\n\n    // Store the result\n    res = mysql_store_result(conn);\n\n    // Output the result row by row\n    int num_fields = mysql_num_fields(res);\n    while ((row = mysql_fetch_row(res))) {\n        unsigned long *lengths;\n        lengths = mysql_fetch_lengths(res);\n        for(int i = 0; i < num_fields; i++) {\n            printf(\"[%.*s] \", (int) lengths[i],\n                    row[i] ? row[i] : \"NULL\");\n        }\n        printf(\"\\n\");\n    }\n\n    // Clean up\n    mysql_free_result(res);\n    mysql_close(conn);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-89-3.c","version":1.1,"compile":"gcc CASTLE-89-3.c -o CASTLE-89-3 -lmysqlclient","vulnerable":true,"description":"Missing input validation of fgets input allows for SQL injection.","cwe":89,"lines":[121,122],"id":"89-3","number":23,"hash":"a0ae8f94d78545bcfd76f47c24bcebc3","line_count":138,"cyclomatic_complexity":17,"nloc":106,"functions":3,"halstead_volume":3696.5369976290317,"maintainability_index":48.823497763759335,"cl100k_base_tokens":724,"code":"#include <mysql/mysql.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <termios.h>\n#include <stdint.h>\n\n\nchar *my_memset_s(char *s, int c, size_t n)\n{\n    volatile char *p = s;\n\n    if (p != NULL)\n        while (n--)\n            *p++ = c;\n\n    return s;\n}\n\n\nchar *getpass_r(const char *prompt)\n{\n    struct termios oflags, nflags;\n    char password[64] = {'\\0'};\n    char *ret = NULL;\n\n    \n    if (tcgetattr(fileno(stdin), &oflags))\n        return NULL;\n\n    nflags = oflags;\n    nflags.c_lflag &= ~ECHO;\n    nflags.c_lflag |= ECHONL;\n\n    if (tcsetattr(fileno(stdin), TCSAFLUSH, &nflags))\n        return NULL;\n\n    \n    fprintf(stderr, \"%s\", prompt);\n    ret = fgets(password, sizeof(password), stdin);\n\n    \n    if (tcsetattr(fileno(stdin), TCSAFLUSH, &oflags))\n    {\n        my_memset_s(password, 0, sizeof(password));\n        return NULL;\n    }\n\n    if (ret)\n    {\n        strtok(password, \"\\n\");\n        ret = strdup(password);\n        my_memset_s(password, 0, sizeof(password));\n    }\n\n    return ret;\n}\n\nint main(int argc, char *argv[])\n{\n    MYSQL *conn;\n    MYSQL_RES *res;\n    MYSQL_ROW row;\n\n    size_t arglen, fmtlen;\n\n    char *server = \"localhost\";\n    char *user = \"root\";\n    char *database = \"bank\";\n    char *password;\n    char *query;\n    char *fmtString = \"SELECT * FROM users WHERE firstname LIKE '%s'\";\n\n    if (argc < 2)\n    {\n        printf(\"You should give an entry parameter!\\n\");\n        return -1;\n    }\n\n    // Authenticate\n    conn = mysql_init(NULL);\n    if (!conn)\n        return -1;\n\n    password = getpass_r(\"DB Password: \");\n    if (!password)\n    {\n        mysql_close(conn);\n        return -1;\n    }\n\n    if (!mysql_real_connect(conn, server,\n                            user, password, database, 0, NULL, 0))\n    {\n        my_memset_s(password, 0, strlen(password));\n        free(password);\n        mysql_close(conn);\n        return -1;\n    }\n\n    my_memset_s(password, 0, strlen(password));\n    free(password);\n\n\n    // Send Query\n    arglen = strlen(argv[1]);\n    fmtlen = strlen(fmtString);\n    if (arglen > SIZE_MAX / sizeof *query - fmtlen)\n    {\n        mysql_close(conn);\n        return -1;\n    }\n    query = malloc((arglen + fmtlen) * sizeof *query);\n    if (query == NULL)\n    {\n        mysql_close(conn);\n        return -1;\n    }\n\n    sprintf(query, fmtString, argv[1]);\n    if (mysql_query(conn, query))\n    {\n        free(query);\n        mysql_close(conn);\n        return -1;\n    }\n\n    res = mysql_use_result(conn);\n\n    while ((row = mysql_fetch_row(res)) != NULL)\n        printf(\"%s %s\\n\", row[1], row[2]);\n\n    free(query);\n    mysql_free_result(res);\n    mysql_close(conn);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-89-4.c","version":1.1,"compile":"gcc CASTLE-89-4.c -o CASTLE-89-4 -lmysqlclient","vulnerable":true,"description":"Missing input validation of fgets input allows for SQL injection.","cwe":89,"lines":[123,125],"id":"89-4","number":24,"hash":"927140e4325ab253557eca862449c502","line_count":145,"cyclomatic_complexity":18,"nloc":110,"functions":3,"halstead_volume":3868.015337125457,"maintainability_index":47.75763460134365,"cl100k_base_tokens":754,"code":"#include <mysql/mysql.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdint.h>\n\n\nchar *my_memset_s(char *s, int c, size_t n)\n{\n    volatile char *p = s;\n\n    if (p != NULL)\n        while (n--)\n            *p++ = c;\n\n    return s;\n}\n\nchar *getpass_r(const char *prompt)\n{\n    struct termios oflags, nflags;\n    char password[64] = {'\\0'};\n    char *ret = NULL;\n\n    \n    if (tcgetattr(fileno(stdin), &oflags))\n        return NULL;\n\n    nflags = oflags;\n    nflags.c_lflag &= ~ECHO;\n    nflags.c_lflag |= ECHONL;\n\n    if (tcsetattr(fileno(stdin), TCSAFLUSH, &nflags))\n        return NULL;\n\n    \n    fprintf(stderr, \"%s\", prompt);\n    ret = fgets(password, sizeof(password), stdin);\n\n    \n    if (tcsetattr(fileno(stdin), TCSAFLUSH, &oflags))\n    {\n        my_memset_s(password, 0, sizeof(password));\n        return NULL;\n    }\n\n    if (ret)\n    {\n        strtok(password, \"\\n\");\n        ret = strdup(password);\n        my_memset_s(password, 0, sizeof(password));\n    }\n\n    return ret;\n}\n\nint main(int argc, char *argv[])\n{\n    MYSQL *conn = 0;\n    MYSQL_RES *res = 0;\n    MYSQL_ROW row;\n\n    size_t arglen, fmtlen;\n\n    char *server = \"localhost\";\n    char *user = \"root\";\n    char *database = \"bank\";\n    char *password;\n    char *query;\n    char *fmtString = \"SELECT * FROM users WHERE firstname LIKE '%s'\";\n    unsigned int i;\n\n    if (argc < 2)\n    {\n        printf(\"You should give an entry parameter!\\n\");\n        return -1;\n    }\n\n    conn = mysql_init(NULL);\n    if (!conn)\n        return -1;\n\n    password = getpass_r(\"DB Password: \");\n    if (!password)\n    {\n        mysql_close(conn);\n        return -1;\n    }\n\n    \n    if (!mysql_real_connect(conn, server,\n                            user, password, database, 0, NULL, 0))\n    {\n        my_memset_s(password, 0, strlen(password));\n        free(password);\n        mysql_close(conn);\n        return -1;\n    }\n\n    my_memset_s(password, 0, strlen(password));\n    free(password);\n\n    \n    for (i = 1; i < argc; ++i)\n    {\n        // allocate memory for the query\n        arglen = strlen(argv[i]);\n        fmtlen = strlen(fmtString);\n        if (arglen > SIZE_MAX / sizeof *query - fmtlen)\n        {\n            mysql_close(conn);\n            return -1;\n        }\n        query = malloc((arglen + fmtlen) * sizeof *query);\n        if (query == NULL)\n        {\n            mysql_close(conn);\n            return -1;\n        }\n\n        sprintf(query, fmtString, argv[i]);\n\n        if (mysql_query(conn, query))\n        {\n            free(query);\n            mysql_close(conn);\n            return -1;\n        }\n\n        res = mysql_use_result(conn);\n\n        \n        while ((row = mysql_fetch_row(res)) != NULL)\n            printf(\"%s %s\\n\", row[1], row[2]);\n\n        free(query);\n        mysql_free_result(res);\n    }\n\n    \n    mysql_close(conn);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-89-5.c","version":1.1,"compile":"gcc CASTLE-89-5.c -o CASTLE-89-5 -lmysqlclient","vulnerable":true,"description":"Insufficient input validation of fgets input allows for SQL injection.","cwe":89,"lines":[55,58],"id":"89-5","number":25,"hash":"a8646d369aac6135a8c6ca5a99f3aeb4","line_count":83,"cyclomatic_complexity":15,"nloc":61,"functions":2,"halstead_volume":2325.7288853491555,"maintainability_index":60.644541806970224,"cl100k_base_tokens":523,"code":"#include <mysql/mysql.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n\nint validate_id(const char *id) {\n    for (int i = 0; id[i] != '\\0'; i++) {\n        if (id[i] == '\\'') {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    MYSQL *conn;\n    MYSQL_RES *res;\n    MYSQL_ROW row;\n\n    // Credentials\n    const char *server = getenv(\"DB_ADDRESS\");\n    const char *user = getenv(\"DB_USERNAME\");\n    const char *password = getenv(\"DB_PASSWORD\");\n    const char *database = getenv(\"DB_DATABASE\");\n    if (server == NULL || user == NULL || password == NULL || database == NULL) {\n        printf(\"Missing database credentials\\n\");\n        return 1;\n    }\n\n    // Initialize MySQL connection\n    conn = mysql_init(NULL);\n    if (conn == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    // Connect to database\n    if (!mysql_real_connect(conn, server, user, password, database, 0, NULL, 0)) {\n        fprintf(stderr, \"Connection failed: %s\\n\", mysql_error(conn));\n        return 1;\n    }\n    printf(\"Connection successful!\\n\");\n\n    char id[32];\n    printf(\"ID: \");\n    fgets(id, sizeof(id), stdin);\n\n    // Validate input\n    if (!validate_id(id)) {\n        printf(\"Invalid ID\\n\");\n        return 1;\n    }\n\n    char sql[256];\n    snprintf(sql, sizeof(sql), \"SELECT * FROM tokens WHERE id = %s\", id);\n\n    // Send SQL query\n    if (mysql_query(conn, sql)) {\n        fprintf(stderr, \"Query failed: %s\\n\", mysql_error(conn));\n        return 1;\n    }\n\n    // Store the result\n    res = mysql_store_result(conn);\n\n    // Output the result row by row\n    int num_fields = mysql_num_fields(res);\n    while ((row = mysql_fetch_row(res))) {\n        unsigned long *lengths;\n        lengths = mysql_fetch_lengths(res);\n        for(int i = 0; i < num_fields; i++) {\n            printf(\"[%.*s] \", (int) lengths[i],\n                    row[i] ? row[i] : \"NULL\");\n        }\n        printf(\"\\n\");\n    }\n\n    // Clean up\n    mysql_free_result(res);\n    mysql_close(conn);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-89-6.c","version":1.1,"compile":"gcc CASTLE-89-6.c -o CASTLE-89-6 -lmysqlclient","vulnerable":true,"description":"Insufficient input validation hidden in subfunction allows for SQL injection.","cwe":89,"lines":[126,128],"id":"89-6","number":26,"hash":"1268a38571516615e501aae4cec7987e","line_count":146,"cyclomatic_complexity":19,"nloc":112,"functions":4,"halstead_volume":3901.5801980880674,"maintainability_index":47.19080625394993,"cl100k_base_tokens":767,"code":"#include <mysql/mysql.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdint.h>\n\n\nchar *my_memset_s(char *s, int c, size_t n)\n{\n    volatile char *p = s;\n\n    if (p != NULL)\n        while (n--)\n            *p++ = c;\n\n    return s;\n}\n\nchar *getpass_r(const char *prompt)\n{\n    struct termios oflags, nflags;\n    char password[64] = {'\\0'};\n    char *ret = NULL;\n\n    \n    if (tcgetattr(fileno(stdin), &oflags))\n        return NULL;\n\n    nflags = oflags;\n    nflags.c_lflag &= ~ECHO;\n    nflags.c_lflag |= ECHONL;\n\n    if (tcsetattr(fileno(stdin), TCSAFLUSH, &nflags))\n        return NULL;\n\n    \n    fprintf(stderr, \"%s\", prompt);\n    ret = fgets(password, sizeof(password), stdin);\n\n    \n    if (tcsetattr(fileno(stdin), TCSAFLUSH, &oflags))\n    {\n        my_memset_s(password, 0, sizeof(password));\n        return NULL;\n    }\n\n    if (ret)\n    {\n        strtok(password, \"\\n\");\n        ret = strdup(password);\n        my_memset_s(password, 0, sizeof(password));\n    }\n\n    return ret;\n}\n\nint runSQLCommand(MYSQL *conn, const char *query)\n{\n    if (mysql_query(conn, query))\n        return 1;\n    return 0;\n}\n\nint main(int argc, char *argv[])\n{\n    MYSQL *conn;\n    MYSQL_RES *res;\n    MYSQL_ROW row;\n\n    size_t arglen, fmtlen;\n\n    char *server = \"localhost\";\n    char *user = \"root\";\n    char *database = \"bank\";\n    char *password;\n    char *query;\n    char *fmtString = \"SELECT * FROM users WHERE firstname LIKE '%s'\";\n\n    if (argc < 2)\n    {\n        printf(\"You should give an entry parameter!\\n\");\n        return -1;\n    }\n\n    conn = mysql_init(NULL);\n    if (!conn)\n        return -1;\n\n    password = getpass_r(\"DB Password: \");\n    if (!password)\n    {\n        mysql_close(conn);\n        return -1;\n    }\n\n    if (!mysql_real_connect(conn, server,\n                            user, password, database, 0, NULL, 0))\n    {\n        my_memset_s(password, 0, strlen(password));\n        free(password);\n        mysql_close(conn);\n        return -1;\n    }\n\n    my_memset_s(password, 0, strlen(password));\n    free(password);\n\n\n    arglen = strlen(argv[1]);\n    fmtlen = strlen(fmtString);\n    if (arglen > SIZE_MAX / sizeof *query - fmtlen)\n    {\n        // the operation would cause an integer overflow\n        mysql_close(conn);\n        return -1;\n    }\n    query = malloc((arglen + fmtlen) * sizeof *query);\n    if (query == NULL)\n    {\n        mysql_close(conn);\n        return -1;\n    }\n\n    sprintf(query, fmtString, argv[1]);\n\n    if (runSQLCommand(conn, (const char *)query))\n    {\n        free(query);\n        mysql_close(conn);\n        return -1;\n    }\n\n    res = mysql_use_result(conn);\n\n    \n    while ((row = mysql_fetch_row(res)) != NULL)\n        printf(\"%s %s\\n\", row[1], row[2]);\n\n    \n    free(query);\n    mysql_free_result(res);\n    mysql_close(conn);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-89-7.c","version":1.1,"compile":"gcc CASTLE-89-7.c -o CASTLE-89-7 -lsqlite3","vulnerable":false,"description":"Static SQL query is not vulnerable to injection.","cwe":89,"lines":[],"id":"89-7","number":27,"hash":"dc7463a2cb4cb6d9f1a45abc6822a679","line_count":43,"cyclomatic_complexity":4,"nloc":28,"functions":1,"halstead_volume":925.0175541639455,"maintainability_index":80.58326081816587,"cl100k_base_tokens":320,"code":"// create table students (id INT, name VARCHAR(18), class VARCHAR(5))\n// insert into students values (1, 'Arnold', \"1b\")\n// insert into students values (2, 'Claire', \"3c\")\n\n#include <stdio.h>\n#include <sqlite3.h>\n\nint main() {\n    sqlite3 *db;\n    sqlite3_stmt *res;\n    int rc;\n\n    rc = sqlite3_open(\"students.db\", &db);\n\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"Cannot open database: %s\\n\", sqlite3_errmsg(db));\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Compile the SQL query\n    rc = sqlite3_prepare_v2(db, \"SELECT * FROM students\", -1, &res, 0);\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"Failed to prepare statement: %s\\n\", sqlite3_errmsg(db));\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Execute SQL query\n    while (sqlite3_step(res) == SQLITE_ROW) {\n        int id = sqlite3_column_int(res, 0);\n        const unsigned char *name = sqlite3_column_text(res, 1);\n        const unsigned char *grade = sqlite3_column_text(res, 2);\n\n        printf(\"Name: %s, Grade: %s\\n\", name, grade);\n    }\n\n    // Finalize and clean up\n    sqlite3_finalize(res);\n    sqlite3_close(db);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-89-8.c","version":1.1,"compile":"gcc CASTLE-89-8.c -o CASTLE-89-8 -lmysqlclient","vulnerable":false,"description":"Sufficient ingteger valudation of parameter ID does not allow for SQL injection","cwe":89,"lines":[],"id":"89-8","number":28,"hash":"79980d7644a1cbe4407bfefa1ba8ae9e","line_count":83,"cyclomatic_complexity":16,"nloc":61,"functions":2,"halstead_volume":2377.1714627603374,"maintainability_index":60.3007770863172,"cl100k_base_tokens":532,"code":"#include <mysql/mysql.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n\nint validate_id(const char *id) {\n    for (int i = 0; id[i] != '\\0'; i++) {\n        if (id[i] < '0' || id[i] > '9') {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    MYSQL *conn;\n    MYSQL_RES *res;\n    MYSQL_ROW row;\n\n    // Credentials\n    const char *server = getenv(\"DB_ADDRESS\");\n    const char *user = getenv(\"DB_USERNAME\");\n    const char *password = getenv(\"DB_PASSWORD\");\n    const char *database = getenv(\"DB_DATABASE\");\n    if (server == NULL || user == NULL || password == NULL || database == NULL) {\n        printf(\"Missing database credentials\\n\");\n        return 1;\n    }\n\n    // Initialize MySQL connection\n    conn = mysql_init(NULL);\n    if (conn == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    // Connect to database\n    if (!mysql_real_connect(conn, server, user, password, database, 0, NULL, 0)) {\n        fprintf(stderr, \"Connection failed: %s\\n\", mysql_error(conn));\n        return 1;\n    }\n    printf(\"Connection successful!\\n\");\n\n    char id[32];\n    printf(\"ID: \");\n    fgets(id, sizeof(id), stdin);\n\n    // Validate input\n    if (!validate_id(id)) {\n        printf(\"Invalid ID\\n\");\n        return 1;\n    }\n\n    char sql[256];\n    snprintf(sql, sizeof(sql), \"SELECT * FROM tokens WHERE id = %s\", id);\n\n    // Send SQL query\n    if (mysql_query(conn, sql)) {\n        fprintf(stderr, \"Query failed: %s\\n\", mysql_error(conn));\n        return 1;\n    }\n\n    // Store the result\n    res = mysql_store_result(conn);\n\n    // Output the result row by row\n    int num_fields = mysql_num_fields(res);\n    while ((row = mysql_fetch_row(res))) {\n        unsigned long *lengths;\n        lengths = mysql_fetch_lengths(res);\n        for(int i = 0; i < num_fields; i++) {\n            printf(\"[%.*s] \", (int) lengths[i],\n                    row[i] ? row[i] : \"NULL\");\n        }\n        printf(\"\\n\");\n    }\n\n    // Clean up\n    mysql_free_result(res);\n    mysql_close(conn);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-89-9.c","version":1.1,"compile":"gcc CASTLE-89-9.c -o CASTLE-89-9 -lmysqlclient","vulnerable":false,"description":"Sufficient ingteger valudation of parameter ID does not allow for SQL injection","cwe":89,"lines":[],"id":"89-9","number":29,"hash":"af8f9c17bae8b246839c1e5f07a0238f","line_count":160,"cyclomatic_complexity":20,"nloc":127,"functions":3,"halstead_volume":4496.385777741146,"maintainability_index":44.186817398109554,"cl100k_base_tokens":887,"code":"#include <mysql/mysql.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdint.h>\n\n\nchar *my_memset_s(char *s, int c, size_t n)\n{\n    volatile char *p = s;\n\n    if (p != NULL)\n        while (n--)\n            *p++ = c;\n\n    return s;\n}\n\nchar *getpass_r(const char *prompt)\n{\n    struct termios oflags, nflags;\n    char password[64] = {'\\0'};\n    char *ret = NULL;\n\n    \n    if (tcgetattr(fileno(stdin), &oflags))\n        return NULL;\n\n    nflags = oflags;\n    nflags.c_lflag &= ~ECHO;\n    nflags.c_lflag |= ECHONL;\n\n    if (tcsetattr(fileno(stdin), TCSAFLUSH, &nflags))\n        return NULL;\n\n    \n    fprintf(stderr, \"%s\", prompt);\n    ret = fgets(password, sizeof(password), stdin);\n\n    \n    if (tcsetattr(fileno(stdin), TCSAFLUSH, &oflags))\n    {\n        my_memset_s(password, 0, sizeof(password));\n        return NULL;\n    }\n\n    if (ret)\n    {\n        strtok(password, \"\\n\");\n        ret = strdup(password);\n        my_memset_s(password, 0, sizeof(password));\n    }\n\n    return ret;\n}\n\nint main(int argc, char *argv[])\n{\n    MYSQL *conn = 0;\n    MYSQL_RES *res = 0;\n    MYSQL_ROW row;\n\n    size_t arglen, esclen, fmtlen;\n\n    char *server = \"localhost\";\n    char *user = \"root\";\n    char *database = \"bank\";\n    char *password;\n    char *query;\n    char *fmtString = \"SELECT * FROM users WHERE firstname LIKE '%s'\";\n    char *param_escaped;\n    unsigned int i;\n\n    if (argc < 2)\n    {\n        printf(\"You should give an entry parameter!\\n\");\n        return -1;\n    }\n\n    conn = mysql_init(NULL);\n    if (!conn)\n        return -1;\n\n    password = getpass_r(\"DB Password: \");\n    if (!password)\n    {\n        mysql_close(conn);\n        return -1;\n    }\n\n    \n    if (!mysql_real_connect(conn, server,\n                            user, password, database, 0, NULL, 0))\n    {\n        my_memset_s(password, 0, strlen(password));\n        free(password);\n        mysql_close(conn);\n        return -1;\n    }\n\n    my_memset_s(password, 0, strlen(password));\n    free(password);\n\n    for (i = 1; i < argc; ++i)\n    {\n        arglen = strlen(argv[i]);\n        if (arglen > (SIZE_MAX / sizeof *param_escaped - 1) / 2)\n        {\n            mysql_close(conn);\n            return -1;\n        }\n        param_escaped = malloc((2 * arglen + 1) * sizeof *param_escaped);\n        if (param_escaped == NULL)\n        {\n            mysql_close(conn);\n            return -1;\n        }\n\n        esclen = mysql_real_escape_string(conn, param_escaped, argv[i], arglen);\n\n        fmtlen = strlen(fmtString);\n        if (esclen > SIZE_MAX / sizeof *query - fmtlen)\n        {\n            free(param_escaped);\n            mysql_close(conn);\n            return -1;\n        }\n        query = malloc((esclen + fmtlen + 1) * sizeof *query);\n        if (query == NULL)\n        {\n            free(param_escaped);\n            mysql_close(conn);\n            return -1;\n        }\n\n        sprintf(query, fmtString, param_escaped);\n\n        if (mysql_query(conn, query))\n        {\n            free(param_escaped);\n            free(query);\n            mysql_close(conn);\n            return -1;\n        }\n\n        res = mysql_use_result(conn);\n\n        while ((row = mysql_fetch_row(res)) != NULL)\n            printf(\"%s %s\\n\", row[1], row[2]);\n\n        free(param_escaped);\n        free(query);\n        mysql_free_result(res);\n    }\n\n    mysql_close(conn);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-89-10.c","version":1.1,"compile":"gcc CASTLE-89-10.c -o CASTLE-89-10 -lsqlite3","vulnerable":false,"description":"Static input to SQL query does not allow for SQL injection.","cwe":89,"lines":[],"id":"89-10","number":30,"hash":"362bb4816261bcc6bbd8d777a3c7d012","line_count":46,"cyclomatic_complexity":4,"nloc":30,"functions":1,"halstead_volume":1015.9851824446653,"maintainability_index":78.97780938918794,"cl100k_base_tokens":322,"code":"// create table existential_crises (id INT, name VARCHAR(12))\n// insert into existential_crises values (1, \"abc\")\n\n#include <stdio.h>\n#include <sqlite3.h>\n\nint main() {\n    sqlite3 *db;\n    sqlite3_stmt *res;\n    int rc;\n\n    rc = sqlite3_open(\"crises.db\", &db);\n\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"Cannot open database: %s\\n\", sqlite3_errmsg(db));\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Prepare an SQL query\n    char* id = \"12\";\n    char sql[256];\n    snprintf(sql, sizeof(sql), \"SELECT * FROM existential_crises WHERE id = '%s'\", id);\n\n    // Compile the SQL query\n    rc = sqlite3_prepare_v2(db, sql, -1, &res, 0);\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"Failed to prepare statement: %s\\n\", sqlite3_errmsg(db));\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Execute SQL query\n    while (sqlite3_step(res) == SQLITE_ROW) {\n        int id = sqlite3_column_int(res, 0);\n        const unsigned char *name = sqlite3_column_text(res, 1);\n\n        printf(\"ID: %d | Name: %s\\n\", id, name);\n    }\n\n    // Finalize and clean up\n    sqlite3_finalize(res);\n    sqlite3_close(db);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-125-1.c","version":1.1,"compile":"gcc CASTLE-125-1.c -o CASTLE-125-1","vulnerable":true,"description":"Upper array boundary error violation.","cwe":125,"lines":[7],"id":"125-1","number":31,"hash":"b64ec76c39ffd39688254c7bb33996bd","line_count":11,"cyclomatic_complexity":2,"nloc":8,"functions":1,"halstead_volume":267.52660076089126,"maintainability_index":100,"cl100k_base_tokens":62,"code":"#include <stdio.h>\n\nint main() {\n    int array[5] = {1, 2, 3, 4, 5};\n\n    for(int i=0; i<=5; i++) {\n        printf(\"%d\\n\", array[i]);\n    }\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-125-2.c","version":1.1,"compile":"gcc CASTLE-125-2.c -o CASTLE-125-2","vulnerable":true,"description":"Upper array boundary error violation.","cwe":125,"lines":[8],"id":"125-2","number":32,"hash":"e399e985ad05f322da23cd79fdb296ad","line_count":12,"cyclomatic_complexity":3,"nloc":9,"functions":1,"halstead_volume":348.0631942357333,"maintainability_index":100,"cl100k_base_tokens":76,"code":"#include <stdio.h>\n\nint main() {\n    int nondet[2*10000+3];\n    for(int i=0; i<=20000; i++) { nondet[i]=i;};\n\n    for(int i=0; i<=40000; i++) {\n        printf(\"%d\\n\", nondet[i]);\n    }\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-125-3.c","version":1.1,"compile":"gcc CASTLE-125-3.c -o CASTLE-125-3","vulnerable":true,"description":"Upper array boundary error violation.","cwe":125,"lines":[8],"id":"125-3","number":33,"hash":"3dc968a7abdcdaec93a142e8261f4919","line_count":12,"cyclomatic_complexity":3,"nloc":9,"functions":1,"halstead_volume":381.55971309377543,"maintainability_index":100,"cl100k_base_tokens":83,"code":"#include <stdio.h>\n\nint main() {\n    long long int nondet[2*100000+3];\n    for(long long int i=0; i<=200000; i++) { nondet[i]=i;};\n\n    for(long long int i=0; i<=40000000; i++) {\n        printf(\"%lld\\n\", nondet[i]);\n    }\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-125-4.c","version":1.1,"compile":"gcc CASTLE-125-4.c -o CASTLE-125-4","vulnerable":true,"description":"Reading from negative index of an array","cwe":125,"lines":[13],"id":"125-4","number":34,"hash":"bf41d6249db23c9dfa06178e21699571","line_count":18,"cyclomatic_complexity":3,"nloc":13,"functions":1,"halstead_volume":446.07383864270474,"maintainability_index":97.03530103090179,"cl100k_base_tokens":109,"code":"#include <stdio.h>\n\n#define ARRAY_LEN 200\n\nint main() {\n    int a[ARRAY_LEN];\n    for (int i = 0; i < ARRAY_LEN; ++i) {\n        a[i] = 3 * i + 2;\n    }\n\n    int lastInd = ARRAY_LEN - 1;\n    for (int i = lastInd; i >= lastInd - ARRAY_LEN; --i) {\n        printf(\"%d, \", a[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-125-5.c","version":1.1,"compile":"gcc CASTLE-125-5.c -o CASTLE-125-5","vulnerable":true,"description":"Reading outside of array bounds due to wrong array length calculation","cwe":125,"lines":[9,11],"id":"125-5","number":35,"hash":"a194317a0628d1085fc83031dd62fb3d","line_count":16,"cyclomatic_complexity":3,"nloc":13,"functions":1,"halstead_volume":405,"maintainability_index":97.5376076601691,"cl100k_base_tokens":96,"code":"#include <stdio.h>\n\nint main() {\n    int a[200];\n    for (int i = 0; i < 200; ++i) {\n        a[i] = i * i;\n    }\n\n    int arrayLength = sizeof(a) / sizeof(char);\n    for (int i = 0; i < arrayLength; ++i) {\n        printf(\"%d, \", a[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-125-6.c","version":1.1,"compile":"gcc CASTLE-125-6.c -o CASTLE-125-6","vulnerable":true,"description":"Reading outside of array bounds due to not implemented length calculation","cwe":125,"lines":[41,50],"id":"125-6","number":36,"hash":"d6e7926eed377fe0ceb2434232ca93ab","line_count":55,"cyclomatic_complexity":6,"nloc":48,"functions":3,"halstead_volume":2141.679297372486,"maintainability_index":67.02594692613667,"cl100k_base_tokens":430,"code":"#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\ntypedef struct {\n    char code[4];\n    int population; // Million\n} Country;\n\nCountry* getCountries() {\n    Country* countries = (Country*)malloc(sizeof(Country) * 9);\n    if (countries == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        exit(1); // Indicate error and exit\n    }\n\n    strncpy(countries[0].code, \"HUN\", 4);\n    countries[0].population = 10;\n    strncpy(countries[1].code, \"GER\", 4);\n    countries[1].population = 84;\n    strncpy(countries[2].code, \"FRA\", 4);\n    countries[2].population = 66;\n    strncpy(countries[3].code, \"ITA\", 4);\n    countries[3].population = 59;\n    strncpy(countries[4].code, \"SPA\", 4);\n    countries[4].population = 48;\n    strncpy(countries[5].code, \"POL\", 4);\n    countries[5].population = 38;\n    strncpy(countries[6].code, \"SWE\", 4);\n    countries[6].population = 10;\n    strncpy(countries[7].code, \"GRE\", 4);\n    countries[7].population = 10;\n    strncpy(countries[8].code, \"AUT\", 4);\n    countries[8].population = 9;\n\n    return countries;\n}\n\nint getNumberOfCountries(Country* c) {\n    if (c != NULL) {\n        return 99;\n    }\n    return 0;\n}\n\nint main() {\n    Country* countries = getCountries();\n    int numOfCountries = getNumberOfCountries(countries);\n    for (int i = 0; i < numOfCountries; ++i) {\n        printf(\"%s: %d 000 000\\n\", countries[i].code, countries[i].population);\n    }\n    free(countries);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-125-7.c","version":1.1,"compile":"gcc CASTLE-125-7.c -o CASTLE-125-7","vulnerable":false,"description":"No read out of bounds in any iterations.","cwe":125,"lines":[],"id":"125-7","number":37,"hash":"02f20f78f8c539f0064feab34d62863d","line_count":29,"cyclomatic_complexity":6,"nloc":24,"functions":1,"halstead_volume":834.4204746375301,"maintainability_index":83.15649325234642,"cl100k_base_tokens":198,"code":"#include <stdio.h>\n\nint main() {\n    int a[100];\n    double b[200];\n    for (int i = 0; i < 100; ++i) {\n        a[i] = i * i + 2 * i - 1;\n    }\n    for (int i = 0; i < 200; ++i) {\n        b[i] = i * 0.27;\n    }\n\n    for (int i = 0; i < 200; ++i) {\n        printf(\"%f, \", b[i]);\n    }\n    printf(\"\\n\");\n\n    for (int i = 0; i < 50; ++i) {\n        printf(\"%d, \", a[i]);\n    }\n    printf(\"\\n\");\n\n    for (int i = 0; i < 100; ++i) {\n        printf(\"%f, \", b[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-125-8.c","version":1.1,"compile":"gcc CASTLE-125-8.c -o CASTLE-125-8","vulnerable":false,"description":"Reading is within the multiline string bounds","cwe":125,"lines":[],"id":"125-8","number":38,"hash":"0b33132b9e9ca4a10b7c89084dd2291e","line_count":19,"cyclomatic_complexity":1,"nloc":14,"functions":1,"halstead_volume":239.11075353876595,"maintainability_index":99.53725164792382,"cl100k_base_tokens":187,"code":"#include <stdio.h>\n\n#define MY_SECRET_CHAR 442\n\nint main() {\n    char str[] = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, \"\n                 \"sed do eiusmod tempor incididunt ut labore et dolore magna \"\n                 \"aliqua. Ut enim ad minim veniam, quis nostrud exercitation \"\n                 \"ullamco laboris nisi ut aliquip ex ea commodo consequat. \"\n                 \"Duis aute irure dolor in reprehenderit in voluptate velit \"\n                 \"esse cillum dolore eu fugiat nulla pariatur. Excepteur sint \"\n                 \"occaecat cupidatat non proident, sunt in culpa qui officia \"\n                 \"deserunt mollit anim id est laborum.\";\n\n    printf(\"My secret is hidden in: \\\"%s\\\"\\n\", str);\n    printf(\"My secret is: \\'%c\\'\\n\", str[MY_SECRET_CHAR]);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-125-9.c","version":1.1,"compile":"gcc CASTLE-125-9.c -o CASTLE-125-9","vulnerable":false,"description":"The array is not indexed out of bounds","cwe":125,"lines":[],"id":"125-9","number":39,"hash":"9bedbbf2590794c54063e52049173467","line_count":19,"cyclomatic_complexity":3,"nloc":13,"functions":1,"halstead_volume":435.98905644032214,"maintainability_index":97.15421126486527,"cl100k_base_tokens":109,"code":"#include <stdio.h>\n\n#define INT_MAX 255\n\nint main() {\n    int a[300];\n    for (int i = 0; i < 300; ++i) {\n        a[i] = 350 - 3 * i;\n    }\n\n    for (int i = 0; i < INT_MAX; ++i) {\n        printf(\"%d, \", a[i]);\n    }\n    printf(\"\\n\");\n\n    printf(\"Special elem: %d\\n\", a[INT_MAX]);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-125-10.c","version":1.1,"compile":"gcc CASTLE-125-10.c -o CASTLE-125-10","vulnerable":false,"description":"Number of countries is returned correctly","cwe":125,"lines":[],"id":"125-10","number":40,"hash":"012a9713bbf9f003796abf8b847283b2","line_count":55,"cyclomatic_complexity":6,"nloc":48,"functions":3,"halstead_volume":2134.79405049904,"maintainability_index":67.04269124406684,"cl100k_base_tokens":430,"code":"#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\ntypedef struct {\n    char code[4];\n    int population; // Million\n} Country;\n\nCountry* getCountries() {\n    Country* countries = (Country*)malloc(sizeof(Country) * 9);\n    if (countries == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        exit(1); // Indicate error and exit\n    }\n\n    strncpy(countries[0].code, \"HUN\", 4);\n    countries[0].population = 10;\n    strncpy(countries[1].code, \"GER\", 4);\n    countries[1].population = 84;\n    strncpy(countries[2].code, \"FRA\", 4);\n    countries[2].population = 66;\n    strncpy(countries[3].code, \"ITA\", 4);\n    countries[3].population = 59;\n    strncpy(countries[4].code, \"SPA\", 4);\n    countries[4].population = 48;\n    strncpy(countries[5].code, \"POL\", 4);\n    countries[5].population = 38;\n    strncpy(countries[6].code, \"SWE\", 4);\n    countries[6].population = 10;\n    strncpy(countries[7].code, \"GRE\", 4);\n    countries[7].population = 10;\n    strncpy(countries[8].code, \"AUT\", 4);\n    countries[8].population = 9;\n\n    return countries;\n}\n\nint getNumberOfCountries(Country* c) {\n    if (c != NULL) {\n        return 9;\n    }\n    return 0;\n}\n\nint main() {\n    Country* countries = getCountries();\n    int numOfCountries = getNumberOfCountries(countries);\n    for (int i = 0; i < numOfCountries; ++i) {\n        printf(\"%s: %d 000 000\\n\", countries[i].code, countries[i].population);\n    }\n    free(countries);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-134-1.c","version":1.1,"compile":"gcc CASTLE-134-1.c -o CASTLE-134-1","vulnerable":true,"description":"The format string is sourced fron an input without sanitization","cwe":134,"lines":[9],"id":"134-1","number":41,"hash":"a393a722473344737d6709ef9d2528b0","line_count":11,"cyclomatic_complexity":2,"nloc":9,"functions":1,"halstead_volume":216.22022703449022,"maintainability_index":100,"cl100k_base_tokens":59,"code":"#include <stdio.h>\n\nint main(int argc, char **argv) {\n    if (argc < 2) {\n        printf(\"Usage: %s <text>\\n\", argv[0]);\n        return 1;\n    }\n\n    printf(argv[1]);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-134-2.c","version":1.1,"compile":"gcc CASTLE-134-2.c -o CASTLE-134-2","vulnerable":true,"description":"The format string is sourced fron an input without sanitization","cwe":134,"lines":[9],"id":"134-2","number":42,"hash":"84844035716966faee2d14abac87964c","line_count":11,"cyclomatic_complexity":2,"nloc":9,"functions":1,"halstead_volume":240,"maintainability_index":100,"cl100k_base_tokens":53,"code":"#include <stdio.h>\n\nint main(int argc, char **argv) {\n    char buffer[256];\n    if (fgets(buffer, sizeof(buffer), stdin) == NULL) {\n        return 1;\n    }\n\n    printf(buffer);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-134-3.c","version":1.1,"compile":"gcc CASTLE-134-3.c -o CASTLE-134-3","vulnerable":true,"description":"The format string is sourced fron an input without sanitization","cwe":134,"lines":[4,13],"id":"134-3","number":43,"hash":"59cb34388623a83fbf9007bbd3981486","line_count":15,"cyclomatic_complexity":3,"nloc":12,"functions":2,"halstead_volume":302.627697999753,"maintainability_index":100,"cl100k_base_tokens":65,"code":"#include <stdio.h>\n\nvoid logger(char *msg) {\n    printf(msg);\n}\n\nint main(int argc, char **argv) {\n    char buffer[256];\n    if (fgets(buffer, sizeof(buffer), stdin) == NULL) {\n        return 1;\n    }\n\n    logger(buffer);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-134-4.c","version":1.1,"compile":"gcc CASTLE-134-4.c -o CASTLE-134-4","vulnerable":true,"description":"The format string is sourced fron an input without sanitization","cwe":134,"lines":[6,21,23],"id":"134-4","number":44,"hash":"64a02a9101ef187bf03792687bc34d95","line_count":25,"cyclomatic_complexity":4,"nloc":21,"functions":2,"halstead_volume":749.8694949764811,"maintainability_index":86.33526074848524,"cl100k_base_tokens":156,"code":"#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid logger(char *msg) {\n    printf(msg);\n}\n\nint main(int argc, char **argv) {\n    char buffer[256];\n    if (fgets(buffer, sizeof(buffer), stdin) == NULL) {\n        return 1;\n    }\n\n    char *hello = \"Hello, \";\n    char *combined = (char*)malloc(strlen(hello) + strlen(buffer) + 1);\n    if (combined == NULL) {\n        return 1;\n    }\n    strncpy(combined, hello, sizeof(combined) - 1);\n    strncat(combined, buffer, sizeof(combined) - strlen(buffer) - 1);\n\n    logger(buffer);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-134-5.c","version":1.1,"compile":"gcc CASTLE-134-5.c -o CASTLE-134-5","vulnerable":true,"description":"The format string is sourced fron an input without sanitization","cwe":134,"lines":[6,7],"id":"134-5","number":45,"hash":"b74ce8df5bc39473479bad4be28ab6fb","line_count":10,"cyclomatic_complexity":2,"nloc":9,"functions":1,"halstead_volume":255.15831097164298,"maintainability_index":100,"cl100k_base_tokens":57,"code":"#include <stdio.h>\n\nint main(int argc, char **argv) {\n    if (argc > 1) {\n        char buffer[1024];\n        snprintf(buffer, sizeof(buffer), argv[1]);\n        printf(\"%s\", buffer);\n    }\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-134-6.c","version":1.1,"compile":"gcc CASTLE-134-6.c -o CASTLE-134-6","vulnerable":true,"description":"The dynamic parameter selector of the formal string is sourced from an input without sanitization","cwe":134,"lines":[17,18],"id":"134-6","number":46,"hash":"054c6fb22fb977af45097f144959d395","line_count":21,"cyclomatic_complexity":3,"nloc":17,"functions":1,"halstead_volume":578.6997515755535,"maintainability_index":91.33586817393186,"cl100k_base_tokens":140,"code":"#include <stdio.h>\n\nint main(int argc, char **argv) {\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s <number>\\n\", argv[0]);\n        return 1;\n    }\n\n    int id;\n    if (sscanf(argv[1], \"%9d\", &id) != 1) {\n        fprintf(stderr, \"Invalid number: %s\\n\", argv[1]);\n        return 1;\n    }\n\n    char* prefix = \"%\";\n    char formatter[1024];\n    snprintf(formatter, sizeof(formatter), \"%s%d$d\\n\", prefix, id);\n    printf(formatter, id);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-134-7.c","version":1.1,"compile":"gcc CASTLE-134-7.c -o CASTLE-134-7","vulnerable":false,"description":"The format string not sourced from outside the program","cwe":134,"lines":[],"id":"134-7","number":47,"hash":"cf8a8d7bee07a0f61de2ef482ffcb1f0","line_count":11,"cyclomatic_complexity":2,"nloc":9,"functions":1,"halstead_volume":228.23460010384647,"maintainability_index":100,"cl100k_base_tokens":62,"code":"#include <stdio.h>\n\nint main(int argc, char **argv) {\n    if (argc < 2) {\n        printf(\"Usage: %s <text>\\n\", argv[0]);\n        return 1;\n    }\n\n    printf(\"%s\", argv[1]);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-134-8.c","version":1.1,"compile":"gcc CASTLE-134-8.c -o CASTLE-134-8","vulnerable":false,"description":"The format string is sourced fron an input without sanitization","cwe":134,"lines":[],"id":"134-8","number":48,"hash":"8b3f8c99c466c2283ea9ddb22db35e9e","line_count":15,"cyclomatic_complexity":3,"nloc":12,"functions":2,"halstead_volume":315.36542508798107,"maintainability_index":100,"cl100k_base_tokens":69,"code":"#include <stdio.h>\n\nvoid logger(char *msg) {\n    printf(\"%s\\n\", msg);\n}\n\nint main(int argc, char **argv) {\n    char buffer[256];\n    if (fgets(buffer, sizeof(buffer), stdin) == NULL) {\n        return 1;\n    }\n\n    logger(buffer);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-134-9.c","version":1.1,"compile":"gcc CASTLE-134-9.c -o CASTLE-134-9","vulnerable":false,"description":"The format string is not sourced fron an input without sanitization","cwe":134,"lines":[],"id":"134-9","number":49,"hash":"e059cda837f5b34eac018e31546a0276","line_count":10,"cyclomatic_complexity":2,"nloc":9,"functions":1,"halstead_volume":264.97209216286,"maintainability_index":100,"cl100k_base_tokens":60,"code":"#include <stdio.h>\n\nint main(int argc, char **argv) {\n    if (argc > 1) {\n        char buffer[1024];\n        snprintf(buffer, sizeof(buffer), \"%s\", argv[1]);\n        printf(\"%s\", buffer);\n    }\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-134-10.c","version":1.1,"compile":"gcc CASTLE-134-10.c -o CASTLE-134-10","vulnerable":false,"description":"The format string is sourced fron an input with sufficient sanitization","cwe":134,"lines":[],"id":"134-10","number":50,"hash":"701a3abf402193dca58b665b53336e68","line_count":28,"cyclomatic_complexity":6,"nloc":23,"functions":2,"halstead_volume":613.1066573880208,"maintainability_index":85.44859135290397,"cl100k_base_tokens":141,"code":"#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\n\nint isValidText(char *input) {\n    for (int i = 0; i < strlen(input); i++) {\n        if (!isalpha(input[i])) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main(int argc, char **argv) {\n    if (argc < 2) {\n        printf(\"Usage: %s <text>\\n\", argv[0]);\n        return 1;\n    }\n\n    if (!isValidText(argv[1])) {\n        printf(\"Invalid parameter!\");\n        return 1;\n    }\n\n    printf(argv[1]);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-190-1.c","version":1.1,"compile":"gcc CASTLE-190-1.c -o CASTLE-190-1","vulnerable":true,"description":"Arithmetic overflow in multiplication.","cwe":190,"lines":[6],"id":"190-1","number":51,"hash":"2e9fbfa27ffb54917346e9dc7f535f6d","line_count":10,"cyclomatic_complexity":1,"nloc":9,"functions":1,"halstead_volume":235.5603911808226,"maintainability_index":100,"cl100k_base_tokens":54,"code":"#include <stdio.h>\n\nint main() {\n    int x=77;\n    int y=x*x*x;\n    int z=y*y;\n    unsigned int r= z/1000;\n    printf(\"Result %u\\n\", r);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-190-2.c","version":1.1,"compile":"gcc CASTLE-190-2.c -o CASTLE-190-2","vulnerable":true,"description":"Integer overflow in atoi function.","cwe":190,"lines":[6],"id":"190-2","number":52,"hash":"135c740bc0fb88efd3c8dd4fe96e9932","line_count":10,"cyclomatic_complexity":1,"nloc":8,"functions":1,"halstead_volume":178.6167092893615,"maintainability_index":100,"cl100k_base_tokens":43,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    long long int APPLE = atoi(\"3000000000\")+1;\n    printf(\"%lld\\n\", APPLE);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-190-3.c","version":1.1,"compile":"gcc CASTLE-190-3.c -o CASTLE-190-3","vulnerable":true,"description":"Integer overflow on addition.","cwe":190,"lines":[9],"id":"190-3","number":53,"hash":"b60a4a744debccf1d699d754c3b2dd50","line_count":12,"cyclomatic_complexity":1,"nloc":7,"functions":1,"halstead_volume":149.27754454988144,"maintainability_index":100,"cl100k_base_tokens":53,"code":"#include <stdio.h>\n\n// INT_MAX 2147483647\n\nint main() {\n    int n = 2147483647;\n\n    printf(\"%d\\n\", n);\n    printf(\"%d\\n\", n + 1);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-190-4.c","version":1.1,"compile":"gcc CASTLE-190-4.c -o CASTLE-190-4","vulnerable":true,"description":"Integer overflow on addition (INT_MAX=2147483647).","cwe":190,"lines":[8],"id":"190-4","number":54,"hash":"4a8bd9aef15fe724985aa91422ae0b60","line_count":11,"cyclomatic_complexity":1,"nloc":7,"functions":1,"halstead_volume":162.53496664211536,"maintainability_index":100,"cl100k_base_tokens":46,"code":"#include <stdio.h>\n\n\nint main() {\n    int n = 214748364;\n\n    printf(\"%d\\n\", n);\n    printf(\"%d\\n\", n * 10 + 8);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-190-5.c","version":1.1,"compile":"gcc CASTLE-190-5.c -o CASTLE-190-5","vulnerable":true,"description":"Integer overflow after set operations.","cwe":190,"lines":[13],"id":"190-5","number":55,"hash":"a7a2077992ceefcf0cd0035b697cdfc4","line_count":19,"cyclomatic_complexity":2,"nloc":14,"functions":1,"halstead_volume":416.756269250316,"maintainability_index":96.41826312374147,"cl100k_base_tokens":92,"code":"#include <stdio.h>\n#include <math.h>\n\n\nint main() {\n    int a = 101;\n    int b = a*a*a;\n    int c = b*2+15000;\n    int d = c^15;\n    int e = d;\n\n    for (int i = 0; i < 3; i++) {\n        e *= e;\n    }\n\n    printf(\"%d\\n\", e);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-190-6.c","version":1.1,"compile":"gcc CASTLE-190-6.c -o CASTLE-190-6","vulnerable":true,"description":"Floating point underflow caused by big division (1.0e-38 close to the minimal possible float).","cwe":190,"lines":[6],"id":"190-6","number":56,"hash":"3d815e1cd64167412ee70c4b4114d4e8","line_count":19,"cyclomatic_complexity":2,"nloc":14,"functions":1,"halstead_volume":315,"maintainability_index":97.87389353833953,"cl100k_base_tokens":135,"code":"#include <stdio.h>\n#include <float.h>\n\nint main() {\n    float chipWithoutMagnification = 1.0e-38;\n    float chipWithMagnification = chipWithoutMagnification / 1.0e38;\n\n    printf(\"Without: %e\\n\", chipWithoutMagnification);\n    printf(\"With: %e\\n\", chipWithMagnification);\n\n    // Is the resut zero?\n    if (chipWithMagnification == 0.0) {\n        printf(\"The result is zero.\\n\");\n    } else {\n        printf(\"The result is %e\\n\", chipWithMagnification);\n    }\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-190-7.c","version":1.1,"compile":"gcc CASTLE-190-7.c -o CASTLE-190-7","vulnerable":false,"description":"There are no arithmetic overflows in any of these functions.","cwe":190,"lines":[],"id":"190-7","number":57,"hash":"e641410b8d833df0e90106068de778ac","line_count":63,"cyclomatic_complexity":13,"nloc":51,"functions":5,"halstead_volume":2770.1082978214768,"maintainability_index":63.095887935327305,"cl100k_base_tokens":581,"code":"#include <stdio.h>\n\n\nvoid printMatrix(int rows, int cols, int mat[rows][cols]) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"%d \", mat[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nvoid addMatrices(int rows, int cols, int mat1[rows][cols], int mat2[rows][cols], int result[rows][cols]) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = mat1[i][j] + mat2[i][j];\n        }\n    }\n}\n\nvoid scalarMult(int rows, int cols, int mat[rows][cols], int scalar) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            mat[i][j] *= scalar;\n        }\n    }\n}\n\nvoid transpose(int rows, int cols, int mat[rows][cols], int result[cols][rows]) {\n    for (int i = 0; i < cols; i++) {\n        for (int j = 0; j < rows; j++) {\n            result[i][j] = mat[j][i];\n        }\n    }\n}\n\nint main() {\n    int mat1[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    int mat2[3][3] = {{9, 8, 7}, {6, 5, 4}, {3, 2, 1}};\n    int sumMat[3][3] = {0};\n    int scalar = 2;\n    int transMat[3][3] = {0};\n\n    printf(\"Matrix 1:\\n\");\n    printMatrix(3, 3, mat1);\n\n    printf(\"\\nMatrix 2:\\n\");\n    printMatrix(3, 3, mat2);\n\n    printf(\"\\nSum of matrices:\\n\");\n    addMatrices(3, 3, mat1, mat2, sumMat);\n    printMatrix(3, 3, sumMat);\n\n    printf(\"\\nScalar multiplication of matrix 1:\\n\");\n    scalarMult(3, 3, mat1, scalar);\n    printMatrix(3, 3, mat1);\n\n    printf(\"\\nTranspose of matrix 2:\\n\");\n    transpose(3, 3, mat2, transMat);\n    printMatrix(3, 3, transMat);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-190-8.c","version":1.1,"compile":"gcc CASTLE-190-8.c -o CASTLE-190-8","vulnerable":false,"description":"There is no arithmetic overflow in any of the the functions.","cwe":190,"lines":[],"id":"190-8","number":58,"hash":"5ef849aec84904f397b915e5f0976904","line_count":151,"cyclomatic_complexity":29,"nloc":123,"functions":8,"halstead_volume":5044.617832441147,"maintainability_index":42.03701211647065,"cl100k_base_tokens":967,"code":"#include <stdio.h>\n#include <stdlib.h>\n\n\n#define ROW 5\n#define COL 5\n\nint grid[ROW][COL];\nint visited[ROW][COL];\n\n// Define a struct to hold the x, y coordinates of a cell\ntypedef struct {\n    int x;\n    int y;\n} Point;\n\n// Define a queue to hold points\nstruct Queue {\n    Point arr[ROW*COL];\n    int front, rear;\n};\n\n// Create a new queue\nstruct Queue* newQueue() {\n    struct Queue* queue = (struct Queue*)malloc(sizeof(struct Queue));\n    if (queue == NULL) {\n        return NULL;\n    }\n\n    queue->front = queue->rear = -1;\n    return queue;\n}\n\n// Check if the queue is empty\nint isEmpty(struct Queue* queue) {\n    return queue->front == -1;\n}\n\n// Add a point to the queue\nvoid enqueue(struct Queue* queue, Point point) {\n    queue->rear = (queue->rear + 1) % (ROW*COL);\n    queue->arr[queue->rear] = point;\n    if(queue->front == -1) {\n        queue->front++;\n    }\n}\n\ntypedef struct {\n    Point p;\n    int hasValue;\n} OptionalPoint;\n\n// Remove a point from the queue\nOptionalPoint dequeue(struct Queue* queue) {\n    if (isEmpty(queue)) {\n        Point p = {0, 0};\n        OptionalPoint op = {p, 0};\n        return op;\n    }\n\n    OptionalPoint point = { queue->arr[queue->front], 1 };\n    if(queue->front == queue->rear) {\n        queue->front = queue->rear = -1;\n    } else {\n        queue->front = (queue->front + 1) % (ROW*COL);\n    }\n    return point;\n}\n\n// Check if a given point is valid\nint isValid(int x, int y) {\n    if(x < 0 || x >= ROW || y < 0 || y >= COL) {\n        return 0;\n    }\n    if(grid[x][y] == 1) {\n        return 0;\n    }\n    if(visited[x][y] == 1) {\n        return 0;\n    }\n    return 1;\n}\n\n// Find the shortest path between two points on the grid\nvoid findPath(Point start, Point end) {\n    struct Queue* queue = newQueue();\n    if (queue == NULL) {\n        return;\n    }\n\n    visited[start.x][start.y] = 1;\n    enqueue(queue, start);\n    while(!isEmpty(queue)) {\n        OptionalPoint op = dequeue(queue);\n        if (op.hasValue == 0) {\n            break;\n        }\n        Point curr = op.p;\n        if(curr.x == end.x && curr.y == end.y) {\n            printf(\"Path found!\\n\");\n            free(queue);\n            return;\n        }\n        Point up = {curr.x-1, curr.y};\n        Point down = {curr.x+1, curr.y};\n        Point left = {curr.x, curr.y-1};\n        Point right = {curr.x, curr.y+1};\n        if(isValid(up.x, up.y)) {\n            visited[up.x][up.y] = 1;\n            enqueue(queue, up);\n        }\n        if(isValid(down.x, down.y)) {\n            visited[down.x][down.y] = 1;\n            enqueue(queue, down);\n        }\n        if(isValid(left.x, left.y)) {\n            visited[left.x][left.y] = 1;\n            enqueue(queue, left);\n        }\n        if(isValid(right.x, right.y)) {\n            visited[right.x][right.y] = 1;\n            enqueue(queue, right);\n        }\n    }\n    printf(\"No path found.\\n\");\n    free(queue);\n}\n\n// Initialize the grid and visited arrays\nvoid initialize() {\n    for(int i=0; i<ROW; i++) {\n        for(int j=0; j<COL; j++) {\n            grid[i][j] = 0;\n            visited[i][j] = 0;\n        }\n    }\n    grid[1][0] = 1;\n    grid[1][1] = 1;\n    grid[1][2] = 1;\n    grid[2][1] = 1;\n    grid[3][1] = 1;\n    grid[3][2] = 1;\n}\n\nint main() {\n    initialize();\n    Point start = {0, 0};\n    Point end = {4, 4};\n    findPath(start, end);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-190-9.c","version":1.1,"compile":"gcc CASTLE-190-9.c -o CASTLE-190-9","vulnerable":false,"description":"There are not arithmetic overflows in any of the functions.","cwe":190,"lines":[],"id":"190-9","number":59,"hash":"847e337e4eb908848fbca6b32a4a0a87","line_count":51,"cyclomatic_complexity":9,"nloc":36,"functions":5,"halstead_volume":1213.7371787100392,"maintainability_index":73.94940402487477,"cl100k_base_tokens":363,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint isPowerOfTwo(unsigned int n) {\n    return (n && !(n & (n - 1)));\n}\n\nvoid swap(unsigned int* a_ptr, unsigned int* b_ptr) {\n    if (*a_ptr != *b_ptr) {\n        *a_ptr ^= *b_ptr;\n        *b_ptr ^= *a_ptr;\n        *a_ptr ^= *b_ptr;\n    }\n}\n\nint countSetBits(unsigned int n) {\n    int count = 0;\n    while (n) {\n        n &= (n - 1);\n        count++;\n    }\n    return count;\n}\n\n\nint maximum(int x, int y) {\n    return x ^ ((x ^ y) & -(x < y));\n}\n\nint main() {\n    unsigned int x = 15, y = 20;\n\n    // Check if x is power of 2 or not\n    if (isPowerOfTwo(x))\n        printf(\"%u is power of 2\\n\", x);\n    else\n        printf(\"%u is not power of 2\\n\", x);\n\n    // Swap the values of x and y\n    printf(\"Before swap: x = %u, y = %u\\n\", x, y);\n    swap(&x, &y);\n    printf(\"After swap: x = %u, y = %u\\n\", x, y);\n\n    // Count the number of set bits in x\n    printf(\"Number of set bits in %u is %d\\n\", x, countSetBits(x));\n\n    // Get the maximum of two numbers\n    printf(\"The maximum of %d and %d is %d\\n\", 32, 56, maximum(32, 56));\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-190-10.c","version":1.1,"compile":"gcc CASTLE-190-10.c -o CASTLE-190-10","vulnerable":false,"description":"No integer overflow in power_mod function.","cwe":190,"lines":[],"id":"190-10","number":60,"hash":"711e62b12fde375922f9f9f2bf167c60","line_count":46,"cyclomatic_complexity":5,"nloc":34,"functions":2,"halstead_volume":1157.174769762185,"maintainability_index":76.04352829705306,"cl100k_base_tokens":357,"code":"#include <stdio.h>\n#include <math.h>\n\nlong long power_mod(long long base, long long exp, long long mod) {\n    long long result = 1;\n    base = base % mod;\n\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % mod;\n        }\n        exp = exp >> 1;\n        base = (base * base) % mod;\n    }\n    return result;\n}\n\nint main() {\n    // Settings\n    long long prime = 37199; // modulus\n    long long base = 5;   // generator\n\n    // Private keys\n    long long alice_private = 19945234904;  // Alice (secret)\n    long long bob_private = 2530476561349134275;   // Bob (secret)\n\n    long long alice_public = power_mod(base, alice_private, prime);\n    printf(\"Alice's public key: %lld\\n\", alice_public);\n\n    long long bob_public = power_mod(base, bob_private, prime);\n    printf(\"Bob's public key: %lld\\n\", bob_public);\n\n    long long alice_shared_secret = power_mod(bob_public, alice_private, prime);\n    printf(\"Alice's shared secret: %lld\\n\", alice_shared_secret);\n\n    long long bob_shared_secret = power_mod(alice_public, bob_private, prime);\n    printf(\"Bob's shared secret: %lld\\n\", bob_shared_secret);\n\n    if (alice_shared_secret == bob_shared_secret) {\n        printf(\"Key exchange successful! Shared secret: %lld\\n\", alice_shared_secret);\n    } else {\n        printf(\"Key exchange failed.\\n\");\n    }\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-253-1.c","version":1.1,"compile":"gcc CASTLE-253-1.c -o CASTLE-253-1","vulnerable":true,"description":"Incorrect check of function return value.","cwe":253,"lines":[6,11,12],"id":"253-1","number":61,"hash":"2b36043d478a73383334c3f52c24e7bf","line_count":17,"cyclomatic_complexity":2,"nloc":13,"functions":1,"halstead_volume":306.05280269303705,"maintainability_index":99.22428065571393,"cl100k_base_tokens":81,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int* p = (int*)malloc(sizeof(int));\n    if (p < 0) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1;\n    }\n\n    *p = 7;\n    printf(\"Value: %d\\n\", *p);\n\n    free(p);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-253-2.c","version":1.1,"compile":"gcc CASTLE-253-2.c -o CASTLE-253-2","vulnerable":true,"description":"Incorrect check of function return value behind a layer of abstraction","cwe":253,"lines":[9,14,19,20],"id":"253-2","number":62,"hash":"ad7e16fa742b099e1507545e1bf2ef19","line_count":25,"cyclomatic_complexity":4,"nloc":19,"functions":3,"halstead_volume":441.1183394572671,"maintainability_index":90.71565998647723,"cl100k_base_tokens":111,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint* getIntPtr() {\n    return malloc(sizeof(int));\n}\n\nint checkIntPtr(int* p) {\n    return (long long)p % 2 == 1;\n}\n\nint main() {\n    int* p = getIntPtr();\n    if (checkIntPtr(p)) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1;\n    }\n\n    *p = 7;\n    printf(\"Value: %d\\n\", *p);\n\n    free(p);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-253-3.c","version":1.1,"compile":"gcc CASTLE-253-3.c -o CASTLE-253-3","vulnerable":true,"description":"Incorrect check of fgets return value. Should check for NULL.","cwe":253,"lines":[10],"id":"253-3","number":63,"hash":"24eef1267f08594ee75da7a80561a5c6","line_count":22,"cyclomatic_complexity":3,"nloc":19,"functions":2,"halstead_volume":372.23460010384645,"maintainability_index":91.82856217261399,"cl100k_base_tokens":94,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid echo()\n{\n    char dataBuffer[100] = \"\";\n    char * data = dataBuffer;\n    printf(\"Please enter a string: \");\n\n    if (fgets(data, 100, stdin) < 0)\n    {\n        printf(\"fgets failed!\\n\");\n        exit(1);\n    }\n    printf(\"%s\\n\", data);\n}\n\nint main()\n{\n    echo();\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-253-4.c","version":1.1,"compile":"gcc CASTLE-253-4.c -o CASTLE-253-4","vulnerable":true,"description":"Incorrect check of snprintf return value. Should check for -1.","cwe":253,"lines":[11],"id":"253-4","number":64,"hash":"f701546d35f2c2c7e25c638541a8387f","line_count":18,"cyclomatic_complexity":2,"nloc":13,"functions":1,"halstead_volume":359.45228222839756,"maintainability_index":98.38799694903017,"cl100k_base_tokens":97,"code":"#include <stdio.h>\n#include <string.h>\n\n#define SRC_STRING \"random string that definitely has no issues\"\n\nint main()\n{\n    char dataBuffer[100] = \"\";\n    char * data = dataBuffer;\n\n    if (snprintf(data, 100 - strlen(SRC_STRING) -1, \"%s\\n\", SRC_STRING) == 0)\n    {\n        printf(\"snprintf failed!\");\n    }\n\n    printf(\"%s\\n\", data);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-253-5.c","version":1.1,"compile":"gcc CASTLE-253-5.c -o CASTLE-253-5","vulnerable":true,"description":"Incorrect check of file open success. Should check for NULL.","cwe":253,"lines":[8,15],"id":"253-5","number":65,"hash":"3abdb841c646a303a5061b1a98085d39","line_count":26,"cyclomatic_complexity":4,"nloc":19,"functions":2,"halstead_volume":547.4540504081483,"maintainability_index":89.59264017124151,"cl100k_base_tokens":119,"code":"#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_FILE_SIZE 1024\n\nvoid readFile(const char *filename) {\n    FILE *file = fopen(filename, \"r\");\n    if (file == -1) {\n        perror(\"Error opening file\\n\");\n        return;\n    }\n\n    char buffer[MAX_FILE_SIZE];\n\n    while (fgets(buffer, sizeof(buffer), file) != NULL) {\n        printf(\"%s\", buffer);\n    }\n\n    fclose(file);\n}\n\nint main() {\n    const char *filename = \"example.txt\";\n    readFile(filename);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-253-6.c","version":1.1,"compile":"gcc CASTLE-253-6.c -o CASTLE-253-6","vulnerable":true,"description":"Incorrect check of file open success. Should check for NULL.","cwe":253,"lines":[5,9,16],"id":"253-6","number":66,"hash":"c0c2a36e7f97bf1f18ee247fc8683d81","line_count":27,"cyclomatic_complexity":4,"nloc":19,"functions":2,"halstead_volume":572.914959539121,"maintainability_index":89.35625461375393,"cl100k_base_tokens":127,"code":"#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_FILE_SIZE 1024\n#define FILE_OPEN_ERROR -1\n\nvoid readFile(const char *filename) {\n    FILE *file = fopen(filename, \"r\");\n    if (file == FILE_OPEN_ERROR) {\n        perror(\"Error opening file\\n\");\n        return;\n    }\n\n    char buffer[MAX_FILE_SIZE];\n\n    while (fgets(buffer, sizeof(buffer), file) != NULL) {\n        printf(\"%s\", buffer);\n    }\n\n    fclose(file);\n}\n\nint main() {\n    const char *filename = \"example.txt\";\n    readFile(filename);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-253-7.c","version":1.1,"compile":"gcc CASTLE-253-7.c -o CASTLE-253-7","vulnerable":false,"description":"Correct check of function return value.","cwe":253,"lines":[],"id":"253-7","number":67,"hash":"d64ab23711a88a6784235370a028597e","line_count":19,"cyclomatic_complexity":2,"nloc":13,"functions":1,"halstead_volume":361.20986172877406,"maintainability_index":98.36263296509156,"cl100k_base_tokens":89,"code":"#include <stdio.h>\n#include <stdlib.h>\n\n#define IsNegative(x) x == NULL\n\nint main() {\n    int* p = (int*)malloc(sizeof(int));\n    if (IsNegative(p)) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1;\n    }\n\n    *p = 7;\n    printf(\"Value: %d\\n\", *p);\n\n    free(p);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-253-8.c","version":1.1,"compile":"gcc CASTLE-253-8.c -o CASTLE-253-8","vulnerable":false,"description":"File open null condition checked correctly.","cwe":253,"lines":[],"id":"253-8","number":68,"hash":"e60975e0b16c6b33af6da25726599a33","line_count":26,"cyclomatic_complexity":4,"nloc":19,"functions":2,"halstead_volume":536.156400069231,"maintainability_index":89.70107380715741,"cl100k_base_tokens":118,"code":"#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_FILE_SIZE 1024\n\nvoid readFile(const char *filename) {\n    FILE *file = fopen(filename, \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\\n\");\n        return;\n    }\n\n    char buffer[MAX_FILE_SIZE];\n\n    while (fgets(buffer, sizeof(buffer), file) != NULL) {\n        printf(\"%s\", buffer);\n    }\n\n    fclose(file);\n}\n\nint main() {\n    const char *filename = \"example.txt\";\n    readFile(filename);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-253-9.c","version":1.1,"compile":"gcc CASTLE-253-9.c -o CASTLE-253-9","vulnerable":false,"description":"Malloc is null checked correctly.","cwe":253,"lines":[],"id":"253-9","number":69,"hash":"d420806b6bbc85608f3693691a18b3bf","line_count":17,"cyclomatic_complexity":2,"nloc":13,"functions":1,"halstead_volume":312.11436755437313,"maintainability_index":99.12229805587953,"cl100k_base_tokens":80,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int* p = (int*)malloc(sizeof(int));\n    if (p == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1;\n    }\n\n    *p = 7;\n    printf(\"Value: %d\\n\", *p);\n\n    free(p);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-253-10.c","version":1.1,"compile":"gcc CASTLE-253-10.c -o CASTLE-253-10","vulnerable":false,"description":"Fgets is null checked correctly.","cwe":253,"lines":[],"id":"253-10","number":70,"hash":"d0f61be955b62db7f503c88ba5079c9b","line_count":22,"cyclomatic_complexity":3,"nloc":19,"functions":2,"halstead_volume":377.85078096793814,"maintainability_index":91.75069187414853,"cl100k_base_tokens":93,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid echo()\n{\n    char dataBuffer[100] = \"\";\n    char * data = dataBuffer;\n    printf(\"Please enter a string: \");\n\n    if (fgets(data, 100, stdin) == NULL)\n    {\n        printf(\"fgets failed!\\n\");\n        exit(1);\n    }\n    printf(\"%s\\n\", data);\n}\n\nint main()\n{\n    echo();\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-327-1.c","version":1.1,"compile":"gcc CASTLE-327-1.c -o CASTLE-327-1 -lsqlite3 -lssl -lcrypto","vulnerable":true,"description":"Password is hashed with MD5.","cwe":327,"lines":[24,32,38,44],"id":"327-1","number":71,"hash":"fdc6cbd5b7c272b1f31bba371494c9be","line_count":162,"cyclomatic_complexity":24,"nloc":128,"functions":6,"halstead_volume":5202.857516810066,"maintainability_index":42.380900688777984,"cl100k_base_tokens":1141,"code":"// create table users (username VARCHAR(32), password VARCHAR(32), salt VARCHAR(32));\n\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n#include <sqlite3.h>\n#include <openssl/evp.h>\n#include <openssl/err.h>\n#include <openssl/rand.h>\n\nvoid bufferToHexString(unsigned char* buffer, char* string, unsigned int len) {\n    for (unsigned int i = 0; i < len; i++) {\n        sprintf(string + (i * 2), \"%02x\", buffer[i]);\n    }\n    string[len * 2] = '\\0';\n}\n\nint md5(const char *str, char outputBuffer[33]) {\n    EVP_MD_CTX *mdctx;\n    const EVP_MD *md;\n    unsigned char hash[EVP_MAX_MD_SIZE];\n    unsigned int hashLen;\n\n    md = EVP_md5();\n    mdctx = EVP_MD_CTX_new();\n\n    if (!mdctx) {\n        printf(\"Error creating EVP_MD_CTX\\n\");\n        return 0;\n    }\n\n    if (1 != EVP_DigestInit_ex(mdctx, md, NULL)) {\n        printf(\"Error initializing digest\\n\");\n        EVP_MD_CTX_free(mdctx);\n        return 0;\n    }\n\n    if (1 != EVP_DigestUpdate(mdctx, str, strlen(str))) {\n        printf(\"Error updating digest\\n\");\n        EVP_MD_CTX_free(mdctx);\n        return 0;\n    }\n\n    if (1 != EVP_DigestFinal_ex(mdctx, hash, &hashLen)) {\n        printf(\"Error finalizing digest\\n\");\n        EVP_MD_CTX_free(mdctx);\n        return 0;\n    }\n\n    bufferToHexString(hash, outputBuffer, hashLen);\n    EVP_MD_CTX_free(mdctx);\n    return 1;\n}\n\nint generateSalt(char outSalt[33]) {\n    unsigned char randBytes[16];\n    int result = RAND_bytes(randBytes, 16);\n    if (result != 1) {\n        printf(\"RAND_bytes failed\\n\");\n        return 0;\n    }\n    bufferToHexString(randBytes, outSalt, 16);\n    return 1;\n}\n\nint isValidUsername(char *input) {\n    for (size_t i = 0; i < strlen(input); i++) {\n        if (!isalpha(input[i])) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint isValidPassword(char *input) {\n    for (size_t i = 0; i < strlen(input); i++) {\n        if (!isalpha(input[i]) && !isdigit(input[i])) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    sqlite3 *db;\n    sqlite3_stmt *res;\n    int rc;\n\n    rc = sqlite3_open(\"users.db\", &db);\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"Cannot open database: %s\\n\", sqlite3_errmsg(db));\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Read user data\n    char username[32];\n    printf(\"Username: \");\n    fgets(username, sizeof(username), stdin);\n    username[strcspn(username, \"\\n\")] = '\\0'; // Remove trailing newline\n\n    char password[32];\n    printf(\"Password: \");\n    fgets(password, sizeof(password), stdin);\n    password[strcspn(password, \"\\n\")] = '\\0'; // Remove trailing newline\n\n    if (isValidUsername(username) == 0 || isValidPassword(password) == 0) {\n        fprintf(stderr, \"Username or password is not valid\\n\");\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Generating salt and hashing salted password\n    char salt[33];\n    if (generateSalt(salt) == 0) {\n        fprintf(stderr, \"Failed to generate salt\\n\");\n        sqlite3_close(db);\n        return 1;\n    }\n    printf(\"Salt: %s\\n\", salt);\n\n    char saltedPassword[65];\n    strncpy(saltedPassword, password, 33); // To always allow null termination\n    strncat(saltedPassword, salt, 32);\n\n    char passwordDigest[33];\n    if (md5(saltedPassword, passwordDigest) == 0) {\n        fprintf(stderr, \"Failed to hash password\\n\");\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Prepare an SQL query\n    const char *sql = \"INSERT INTO users (username, password, salt) VALUES (?, ?, ?);\";\n\n    // Compile the SQL query\n    rc = sqlite3_prepare_v2(db, sql, -1, &res, 0);\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"Failed to prepare statement: %s\\n\", sqlite3_errmsg(db));\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Bind values\n    sqlite3_bind_text(res, 1, username, -1, SQLITE_STATIC);\n    sqlite3_bind_text(res, 2, passwordDigest, -1, SQLITE_STATIC);\n    sqlite3_bind_text(res, 3, salt, -1, SQLITE_STATIC);\n\n    rc = sqlite3_step(res);\n\n    if (rc != SQLITE_DONE) {\n        fprintf(stderr, \"Execution failed: %s\\n\", sqlite3_errmsg(db));\n    } else {\n        printf(\"Record inserted successfully.\\n\");\n    }\n\n    // Finalize and clean up\n    sqlite3_finalize(res);\n    sqlite3_close(db);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-327-2.c","version":1.1,"compile":"gcc CASTLE-327-2.c -o CASTLE-327-2 -lsqlite3 -lssl -lcrypto","vulnerable":true,"description":"Password is hashed with MD5 missdirected by function names.","cwe":327,"lines":[11,26,34,40,46],"id":"327-2","number":72,"hash":"9a186016cb188f738f3306fc3a836a00","line_count":164,"cyclomatic_complexity":24,"nloc":128,"functions":6,"halstead_volume":5246.659570597225,"maintainability_index":42.33730594428309,"cl100k_base_tokens":1151,"code":"// create table users (username VARCHAR(32), password VARCHAR(32), salt VARCHAR(32));\n\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n#include <sqlite3.h>\n#include <openssl/evp.h>\n#include <openssl/err.h>\n#include <openssl/rand.h>\n\n#define EVP_sha_256 EVP_md5\n\nvoid bufferToHexString(unsigned char* buffer, char* string, unsigned int len) {\n    for (unsigned int i = 0; i < len; i++) {\n        sprintf(string + (i * 2), \"%02x\", buffer[i]);\n    }\n    string[len * 2] = '\\0';\n}\n\nint sha256(const char *str, char outputBuffer[65]) {\n    EVP_MD_CTX *mdctx;\n    const EVP_MD *md;\n    unsigned char hash[EVP_MAX_MD_SIZE];\n    unsigned int hashLen;\n\n    md = EVP_sha_256();\n    mdctx = EVP_MD_CTX_new();\n\n    if (!mdctx) {\n        printf(\"Error creating EVP_MD_CTX\\n\");\n        return 0;\n    }\n\n    if (1 != EVP_DigestInit_ex(mdctx, md, NULL)) {\n        printf(\"Error initializing digest\\n\");\n        EVP_MD_CTX_free(mdctx);\n        return 0;\n    }\n\n    if (1 != EVP_DigestUpdate(mdctx, str, strlen(str))) {\n        printf(\"Error updating digest\\n\");\n        EVP_MD_CTX_free(mdctx);\n        return 0;\n    }\n\n    if (1 != EVP_DigestFinal_ex(mdctx, hash, &hashLen)) {\n        printf(\"Error finalizing digest\\n\");\n        EVP_MD_CTX_free(mdctx);\n        return 0;\n    }\n\n    bufferToHexString(hash, outputBuffer, hashLen);\n    EVP_MD_CTX_free(mdctx);\n    return 1;\n}\n\nint generateSalt(char outSalt[33]) {\n    unsigned char randBytes[16];\n    int result = RAND_bytes(randBytes, 16);\n    if (result != 1) {\n        printf(\"RAND_bytes failed\\n\");\n        return 0;\n    }\n    bufferToHexString(randBytes, outSalt, 16);\n    return 1;\n}\n\nint isValidUsername(char *input) {\n    for (size_t i = 0; i < strlen(input); i++) {\n        if (!isalpha(input[i])) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint isValidPassword(char *input) {\n    for (size_t i = 0; i < strlen(input); i++) {\n        if (!isalpha(input[i]) && !isdigit(input[i])) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    sqlite3 *db;\n    sqlite3_stmt *res;\n    int rc;\n\n    rc = sqlite3_open(\"users.db\", &db);\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"Cannot open database: %s\\n\", sqlite3_errmsg(db));\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Read user data\n    char username[32];\n    printf(\"Username: \");\n    fgets(username, sizeof(username), stdin);\n    username[strcspn(username, \"\\n\")] = '\\0'; // Remove trailing newline\n\n    char password[32];\n    printf(\"Password: \");\n    fgets(password, sizeof(password), stdin);\n    password[strcspn(password, \"\\n\")] = '\\0'; // Remove trailing newline\n\n    if (isValidUsername(username) == 0 || isValidPassword(password) == 0) {\n        fprintf(stderr, \"Username or password is not valid\\n\");\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Generating salt and hashing salted password\n    char salt[33];\n    if (generateSalt(salt) == 0) {\n        fprintf(stderr, \"Failed to generate salt\\n\");\n        sqlite3_close(db);\n        return 1;\n    }\n    printf(\"Salt: %s\\n\", salt);\n\n    char saltedPassword[65];\n    strncpy(saltedPassword, password, 33); // To always allow null termination\n    strncat(saltedPassword, salt, 32);\n\n    char passwordDigest[65];\n    if (sha256(saltedPassword, passwordDigest) == 0) {\n        fprintf(stderr, \"Failed to hash password\\n\");\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Prepare an SQL query\n    const char *sql = \"INSERT INTO users (username, password, salt) VALUES (?, ?, ?);\";\n\n    // Compile the SQL query\n    rc = sqlite3_prepare_v2(db, sql, -1, &res, 0);\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"Failed to prepare statement: %s\\n\", sqlite3_errmsg(db));\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Bind values\n    sqlite3_bind_text(res, 1, username, -1, SQLITE_STATIC);\n    sqlite3_bind_text(res, 2, passwordDigest, -1, SQLITE_STATIC);\n    sqlite3_bind_text(res, 3, salt, -1, SQLITE_STATIC);\n\n    rc = sqlite3_step(res);\n\n    if (rc != SQLITE_DONE) {\n        fprintf(stderr, \"Execution failed: %s\\n\", sqlite3_errmsg(db));\n    } else {\n        printf(\"Record inserted successfully.\\n\");\n    }\n\n    // Finalize and clean up\n    sqlite3_finalize(res);\n    sqlite3_close(db);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-327-3.c","version":1.1,"compile":"gcc CASTLE-327-3.c -o CASTLE-327-3 -lssl -lcrypto","vulnerable":true,"description":"Sensitive data is encrypted with DES.","cwe":327,"lines":[16,19,28],"id":"327-3","number":73,"hash":"af5ea805b539082019de980aafb73897","line_count":80,"cyclomatic_complexity":11,"nloc":60,"functions":4,"halstead_volume":2693.576766692719,"maintainability_index":61.06876683133626,"cl100k_base_tokens":557,"code":"#include <openssl/des.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n// echo \"18812f545d4d12ac\" > key.txt\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nvoid des_encrypt(const char* plaintext, char* ciphertext, const unsigned char key[8])\n{\n    DES_cblock desKey;\n    memcpy(desKey, key, 8);\n    DES_set_odd_parity(&desKey);\n\n    DES_key_schedule schedule;\n    DES_set_key_unchecked(&desKey, &schedule);\n\n    const size_t plaintextLength = strlen(plaintext);\n    for (size_t i = 0; i < plaintextLength; i += 8) {\n        DES_cblock input;\n        memset(input, '0', 8); // '0' for padding\n        memcpy(input, plaintext + i, min(8, plaintextLength - i));\n\n        DES_cblock output;\n        DES_ecb_encrypt(&input, &output, &schedule, DES_ENCRYPT);\n\n        for (int j = 0; j < 8; j++) {\n            sprintf(ciphertext + 2 * i + 2 * j, \"%02x\", output[j]);\n        }\n    }\n}\n\nint read_key(const char *filename, unsigned char key[8]) {\n    FILE *file = fopen(filename, \"r\");\n    if (!file) {\n        fprintf(stderr, \"Could not open file: %s\\n\", filename);\n        return 0;\n    }\n\n    char key_hex[17];\n\n    if (fscanf(file, \"%16s\", key_hex) != 1) {\n        fprintf(stderr, \"Invalid format in file: %s\\n\", filename);\n        fclose(file);\n        return 0;\n    }\n\n    fclose(file);\n\n    for (int i = 0; i < 8; i++) {\n        sscanf(key_hex + 2 * i, \"%2hhx\", &key[i]);\n    }\n\n    return 1;\n}\n\nint main() {\n    char sensitiveText[1024];\n    printf(\"Sensitive text: \");\n    fgets(sensitiveText, sizeof(sensitiveText), stdin);\n    sensitiveText[strcspn(sensitiveText, \"\\n\")] = '\\0';\n\n    unsigned char key[8];\n    if (!read_key(\"key.txt\", key)) {\n        return 1;\n    }\n\n    char ciphertext[2048];\n    des_encrypt(sensitiveText, ciphertext, key);\n\n    printf(\"Encrypted: %s\\n\", ciphertext);\n\n    memset(key, 0, sizeof(key));\n    memset(sensitiveText, 0, sizeof(sensitiveText));\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-327-4.c","version":1.1,"compile":"gcc CASTLE-327-4.c -o CASTLE-327-4 -lssl -lcrypto","vulnerable":true,"description":"RSA is used without padding.","cwe":327,"lines":[65],"id":"327-4","number":74,"hash":"11a43275a9ffcd658255789a71604dd5","line_count":157,"cyclomatic_complexity":24,"nloc":129,"functions":5,"halstead_volume":5345.143751835889,"maintainability_index":42.11453171712047,"cl100k_base_tokens":1135,"code":"// openssl genrsa -out rsa.pem 2048\n// openssl rsa -in rsa.pem -outform PEM -pubout -out rsa.pem.pub\n\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/decoder.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid cleanUp(BIO* bio, EVP_PKEY* pkey, OSSL_DECODER_CTX* dctx, EVP_PKEY_CTX* ctx) {\n    BIO_free_all(bio);\n    OSSL_DECODER_CTX_free(dctx);\n    EVP_PKEY_free(pkey);\n    EVP_PKEY_CTX_free(ctx);\n}\n\nvoid bufferToHexString(unsigned char* buffer, char* string, unsigned int len) {\n    for (unsigned int i = 0; i < len; i++) {\n        sprintf(string + (i * 2), \"%02x\", buffer[i]);\n    }\n    string[len * 2] = '\\0';\n}\n\nchar* rsa_encrypt(const char* plaintext, const char* key) {\n    BIO* bio = NULL;\n    EVP_PKEY* pkey = NULL;\n    OSSL_DECODER_CTX* dctx = NULL;\n    EVP_PKEY_CTX* ctx = NULL;\n\n    const size_t inLength = strlen(plaintext);\n    const size_t keyLength = strlen(key);\n    if (inLength == 0 || keyLength == 0) {\n        return NULL;\n    }\n\n    bio = BIO_new_mem_buf(key, keyLength);\n    if (bio == NULL) {\n        cleanUp(bio, pkey, dctx, ctx);\n        return NULL;\n    }\n\n    dctx = OSSL_DECODER_CTX_new_for_pkey(&pkey, \"PEM\", NULL, \"RSA\", EVP_PKEY_PUBLIC_KEY, NULL, NULL);\n    if (dctx == NULL) {\n        cleanUp(bio, pkey, dctx, ctx);\n        return NULL;\n    }\n\n    if (!OSSL_DECODER_from_bio(dctx, bio)) {\n        cleanUp(bio, pkey, dctx, ctx);\n        return NULL;\n    }\n\n    ctx = EVP_PKEY_CTX_new(pkey, NULL);\n    if (ctx == NULL) {\n        cleanUp(bio, pkey, dctx, ctx);\n        return NULL;\n    }\n\n    if (EVP_PKEY_encrypt_init(ctx) <= 0) {\n        cleanUp(bio, pkey, dctx, ctx);\n        return NULL;\n    }\n\n    if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_NO_PADDING) <= 0) {\n        cleanUp(bio, pkey, dctx, ctx);\n        return NULL;\n    }\n\n    size_t length;\n    if (EVP_PKEY_encrypt(ctx, NULL, &length, (unsigned char*)plaintext, inLength) <= 0) {\n        cleanUp(bio, pkey, dctx, ctx);\n        return NULL; \n    }\n\n    unsigned char* ciphertext = (unsigned char*)malloc(length);\n    if (ciphertext == NULL) {\n        cleanUp(bio, pkey, dctx, ctx);\n        return NULL;\n    }\n\n    if (EVP_PKEY_encrypt(ctx, ciphertext, &length, (unsigned char*)plaintext, inLength) <= 0) {\n        cleanUp(bio, pkey, dctx, ctx);\n        free(ciphertext);\n        return NULL; \n    }\n\n    char* hexCiphertext = (char*)malloc(length * 2 + 1);\n    if (hexCiphertext == NULL) {\n        cleanUp(bio, pkey, dctx, ctx);\n        free(ciphertext);\n        return NULL;\n    }\n\n    bufferToHexString(ciphertext, hexCiphertext, length);\n    free(ciphertext);\n    cleanUp(bio, pkey, dctx, ctx);\n    return hexCiphertext;\n}\n\nchar* readKey(const char* filename) {\n    FILE* file = fopen(filename, \"r\");\n    if (file == NULL) {\n        return NULL;\n    }\n\n    fseek(file, 0, SEEK_END);\n    const size_t length = ftell(file);\n    if (length == 0xFFFFFFFFFFFFFFFF) {\n        fclose(file);\n        return NULL;\n    }\n\n    char* buffer = (char*)malloc(length + 1);\n    if (buffer == NULL) {\n        fclose(file);\n        return NULL;\n    }\n\n    rewind(file);\n    const size_t read = fread(buffer, 1, length, file);\n    if (read != length) {\n        fclose(file);\n        free(buffer);\n        return NULL;\n    }\n\n    buffer[length] = '\\0';\n    fclose(file);\n    return buffer;\n}\n\nint main() {\n    char* key = readKey(\"rsa.pem.pub\");\n    if (key == NULL) {\n        return 1;\n    }\n\n    char sensitiveText[1024];\n    printf(\"Sensitive text: \");\n    fgets(sensitiveText, sizeof(sensitiveText), stdin);\n    sensitiveText[strcspn(sensitiveText, \"\\n\")] = '\\0';\n\n    char* ciphertext = rsa_encrypt(sensitiveText, key);\n    if (ciphertext == NULL) {\n        free(key);\n        return 1;\n    }\n\n    printf(\"Encrypted: %s\\n\", ciphertext);\n    memset(sensitiveText, 0, sizeof(sensitiveText));\n    memset(key, 0, strlen(key));\n    free(key);\n    free(ciphertext);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-327-5.c","version":1.1,"compile":"gcc CASTLE-327-5.c -o CASTLE-327-5 -lssl -lcrypto","vulnerable":true,"description":"RSA is used with non-OAEP padding (CWE-780).","cwe":327,"lines":[65],"id":"327-5","number":75,"hash":"4ec47d13012b6563eb546f7a2c8f004c","line_count":156,"cyclomatic_complexity":24,"nloc":129,"functions":5,"halstead_volume":5345.143751835889,"maintainability_index":42.11453171712047,"cl100k_base_tokens":1137,"code":"// openssl genrsa -out rsa.pem 2048\n// openssl rsa -in rsa.pem -outform PEM -pubout -out rsa.pem.pub\n\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/decoder.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid cleanUp(BIO* bio, EVP_PKEY* pkey, OSSL_DECODER_CTX* dctx, EVP_PKEY_CTX* ctx) {\n    BIO_free_all(bio);\n    OSSL_DECODER_CTX_free(dctx);\n    EVP_PKEY_free(pkey);\n    EVP_PKEY_CTX_free(ctx);\n}\n\nvoid bufferToHexString(unsigned char* buffer, char* string, unsigned int len) {\n    for (unsigned int i = 0; i < len; i++) {\n        sprintf(string + (i * 2), \"%02x\", buffer[i]);\n    }\n    string[len * 2] = '\\0';\n}\n\nchar* rsa_encrypt(const char* plaintext, const char* key) {\n    BIO* bio = NULL;\n    EVP_PKEY* pkey = NULL;\n    OSSL_DECODER_CTX* dctx = NULL;\n    EVP_PKEY_CTX* ctx = NULL;\n\n    const size_t inLength = strlen(plaintext);\n    const size_t keyLength = strlen(key);\n    if (inLength == 0 || keyLength == 0) {\n        return NULL;\n    }\n\n    bio = BIO_new_mem_buf(key, keyLength);\n    if (bio == NULL) {\n        cleanUp(bio, pkey, dctx, ctx);\n        return NULL;\n    }\n\n    dctx = OSSL_DECODER_CTX_new_for_pkey(&pkey, \"PEM\", NULL, \"RSA\", EVP_PKEY_PUBLIC_KEY, NULL, NULL);\n    if (dctx == NULL) {\n        cleanUp(bio, pkey, dctx, ctx);\n        return NULL;\n    }\n\n    if (!OSSL_DECODER_from_bio(dctx, bio)) {\n        cleanUp(bio, pkey, dctx, ctx);\n        return NULL;\n    }\n\n    ctx = EVP_PKEY_CTX_new(pkey, NULL);\n    if (ctx == NULL) {\n        cleanUp(bio, pkey, dctx, ctx);\n        return NULL;\n    }\n\n    if (EVP_PKEY_encrypt_init(ctx) <= 0) {\n        cleanUp(bio, pkey, dctx, ctx);\n        return NULL;\n    }\n\n    if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_PADDING) <= 0) {\n        cleanUp(bio, pkey, dctx, ctx);\n        return NULL;\n    }\n\n    size_t length;\n    if (EVP_PKEY_encrypt(ctx, NULL, &length, (unsigned char*)plaintext, inLength) <= 0) {\n        cleanUp(bio, pkey, dctx, ctx);\n        return NULL; \n    }\n\n    unsigned char* ciphertext = (unsigned char*)malloc(length);\n    if (ciphertext == NULL) {\n        cleanUp(bio, pkey, dctx, ctx);\n        return NULL;\n    }\n\n    if (EVP_PKEY_encrypt(ctx, ciphertext, &length, (unsigned char*)plaintext, inLength) <= 0) {\n        cleanUp(bio, pkey, dctx, ctx);\n        free(ciphertext);\n        return NULL; \n    }\n\n    char* hexCiphertext = (char*)malloc(length * 2 + 1);\n    if (hexCiphertext == NULL) {\n        cleanUp(bio, pkey, dctx, ctx);\n        free(ciphertext);\n        return NULL;\n    }\n\n    bufferToHexString(ciphertext, hexCiphertext, length);\n    free(ciphertext);\n    cleanUp(bio, pkey, dctx, ctx);\n    return hexCiphertext;\n}\n\nchar* readKey(const char* filename) {\n    FILE* file = fopen(filename, \"r\");\n    if (file == NULL) {\n        return NULL;\n    }\n\n    fseek(file, 0, SEEK_END);\n    const size_t length = ftell(file);\n    if (length == 0xFFFFFFFFFFFFFFFF) {\n        fclose(file);\n        return NULL;\n    }\n\n    char* buffer = (char*)malloc(length + 1);\n    if (buffer == NULL) {\n        fclose(file);\n        return NULL;\n    }\n\n    rewind(file);\n    const size_t read = fread(buffer, 1, length, file);\n    if (read != length) {\n        fclose(file);\n        free(buffer);\n        return NULL;\n    }\n\n    buffer[length] = '\\0';\n    fclose(file);\n    return buffer;\n}\n\nint main() {\n    char* key = readKey(\"rsa.pem.pub\");\n    if (key == NULL) {\n        return 1;\n    }\n\n    char sensitiveText[1024];\n    printf(\"Sensitive text: \");\n    fgets(sensitiveText, sizeof(sensitiveText), stdin);\n    sensitiveText[strcspn(sensitiveText, \"\\n\")] = '\\0';\n\n    char* ciphertext = rsa_encrypt(sensitiveText, key);\n    if (ciphertext == NULL) {\n        free(key);\n        return 1;\n    }\n\n    printf(\"Encrypted: %s\\n\", ciphertext);\n    memset(sensitiveText, 0, sizeof(sensitiveText));\n    memset(key, 0, strlen(key));\n    free(key);\n    free(ciphertext);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-327-6.c","version":1.1,"compile":"gcc CASTLE-327-6.c -o CASTLE-327-6 -lssl -lcrypto","vulnerable":true,"description":"HMAC used with MD5.","cwe":327,"lines":[22],"id":"327-6","number":76,"hash":"371328cd19be80de8109a166cdc72e4a","line_count":82,"cyclomatic_complexity":12,"nloc":63,"functions":4,"halstead_volume":2765.909211107329,"maintainability_index":59.91056905218227,"cl100k_base_tokens":581,"code":"// echo \"d25b859e5277340274873697196ba955\" > key.txt\n\n#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n\nvoid bufferToHexString(unsigned char* buffer, char* string, unsigned int len) {\n    for (unsigned int i = 0; i < len; i++) {\n        sprintf(string + (i * 2), \"%02x\", buffer[i]);\n    }\n    string[len * 2] = '\\0';\n}\n\nchar* createHMAC(const char* data, const unsigned char* key, size_t keyLen) {\n    const size_t dataLen = strlen(data);\n\n    unsigned char* hmac = NULL;\n    unsigned int hmacLen = 0;\n    hmac = HMAC(EVP_md5(), key, keyLen, (unsigned char*)data, dataLen, hmac, &hmacLen);\n    if (hmac == NULL) {\n        return NULL;\n    }\n\n    char* hexHmac = (char*)malloc(2 * hmacLen + 1);\n    if (hexHmac == NULL) {\n        return NULL;\n    }\n\n    bufferToHexString(hmac, hexHmac, hmacLen);\n    return hexHmac;\n}\n\nint read_key(const char *filename, unsigned char key[16]) {\n    FILE *file = fopen(filename, \"r\");\n    if (!file) {\n        fprintf(stderr, \"Could not open file: %s\\n\", filename);\n        return 0;\n    }\n\n    char key_hex[33];\n\n    if (fscanf(file, \"%32s\", key_hex) != 1) {\n        fprintf(stderr, \"Invalid format in file: %s\\n\", filename);\n        fclose(file);\n        return 0;\n    }\n\n    fclose(file);\n\n    for (int i = 0; i < 16; i++) {\n        sscanf(key_hex + 2 * i, \"%2hhx\", &key[i]);\n    }\n\n    return 1;\n}\n\nint main() {\n    char sensitiveText[1024];\n    printf(\"Sensitive text: \");\n    fgets(sensitiveText, sizeof(sensitiveText), stdin);\n    sensitiveText[strcspn(sensitiveText, \"\\n\")] = '\\0';\n\n    unsigned char key[16];\n    if (!read_key(\"key.txt\", key)) {\n        return 1;\n    }\n\n    char* hmac = createHMAC(sensitiveText, key, 16);\n    if (hmac == NULL) {\n        return 1;\n    }\n\n    printf(\"HMAC: %s\\n\", hmac);\n    free(hmac);\n    memset(sensitiveText, 0, sizeof(sensitiveText));\n    memset(key, 0, sizeof(key));\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-327-7.c","version":1.1,"compile":"gcc CASTLE-327-7.c -o CASTLE-327-7 -lsqlite3 -lssl -lcrypto","vulnerable":false,"description":"Password is hashed with SHA256.","cwe":327,"lines":[],"id":"327-7","number":77,"hash":"b4d9f68845655c4ebd5d817cbeed660b","line_count":163,"cyclomatic_complexity":24,"nloc":128,"functions":6,"halstead_volume":5202.857516810066,"maintainability_index":42.380900688777984,"cl100k_base_tokens":1134,"code":"// create table users (username VARCHAR(32), password VARCHAR(32), salt VARCHAR(32));\n\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n#include <sqlite3.h>\n#include <openssl/evp.h>\n#include <openssl/err.h>\n#include <openssl/rand.h>\n\n\nvoid bufferToHexString(unsigned char* buffer, char* string, unsigned int len) {\n    for (unsigned int i = 0; i < len; i++) {\n        sprintf(string + (i * 2), \"%02x\", buffer[i]);\n    }\n    string[len * 2] = '\\0';\n}\n\nint sha256(const char *str, char outputBuffer[65]) {\n    EVP_MD_CTX *mdctx;\n    const EVP_MD *md;\n    unsigned char hash[EVP_MAX_MD_SIZE];\n    unsigned int hashLen;\n\n    md = EVP_sha256();\n    mdctx = EVP_MD_CTX_new();\n\n    if (!mdctx) {\n        printf(\"Error creating EVP_MD_CTX\\n\");\n        return 0;\n    }\n\n    if (1 != EVP_DigestInit_ex(mdctx, md, NULL)) {\n        printf(\"Error initializing digest\\n\");\n        EVP_MD_CTX_free(mdctx);\n        return 0;\n    }\n\n    if (1 != EVP_DigestUpdate(mdctx, str, strlen(str))) {\n        printf(\"Error updating digest\\n\");\n        EVP_MD_CTX_free(mdctx);\n        return 0;\n    }\n\n    if (1 != EVP_DigestFinal_ex(mdctx, hash, &hashLen)) {\n        printf(\"Error finalizing digest\\n\");\n        EVP_MD_CTX_free(mdctx);\n        return 0;\n    }\n\n    bufferToHexString(hash, outputBuffer, hashLen);\n    EVP_MD_CTX_free(mdctx);\n    return 1;\n}\n\nint generateSalt(char outSalt[33]) {\n    unsigned char randBytes[16];\n    int result = RAND_bytes(randBytes, 16);\n    if (result != 1) {\n        printf(\"RAND_bytes failed\\n\");\n        return 0;\n    }\n    bufferToHexString(randBytes, outSalt, 16);\n    return 1;\n}\n\nint isValidUsername(char *input) {\n    for (size_t i = 0; i < strlen(input); i++) {\n        if (!isalpha(input[i])) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint isValidPassword(char *input) {\n    for (size_t i = 0; i < strlen(input); i++) {\n        if (!isalpha(input[i]) && !isdigit(input[i])) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    sqlite3 *db;\n    sqlite3_stmt *res;\n    int rc;\n\n    rc = sqlite3_open(\"users.db\", &db);\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"Cannot open database: %s\\n\", sqlite3_errmsg(db));\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Read user data\n    char username[32];\n    printf(\"Username: \");\n    fgets(username, sizeof(username), stdin);\n    username[strcspn(username, \"\\n\")] = '\\0'; // Remove trailing newline\n\n    char password[32];\n    printf(\"Password: \");\n    fgets(password, sizeof(password), stdin);\n    password[strcspn(password, \"\\n\")] = '\\0'; // Remove trailing newline\n\n    if (isValidUsername(username) == 0 || isValidPassword(password) == 0) {\n        fprintf(stderr, \"Username or password is not valid\\n\");\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Generating salt and hashing salted password\n    char salt[33];\n    if (generateSalt(salt) == 0) {\n        fprintf(stderr, \"Failed to generate salt\\n\");\n        sqlite3_close(db);\n        return 1;\n    }\n    printf(\"Salt: %s\\n\", salt);\n\n    char saltedPassword[65];\n    strncpy(saltedPassword, password, 32);\n    strncat(saltedPassword, salt, 32);\n\n    char passwordDigest[65];\n    if (sha256(saltedPassword, passwordDigest) == 0) {\n        fprintf(stderr, \"Failed to hash password\\n\");\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Prepare an SQL query\n    const char *sql = \"INSERT INTO users (username, password, salt) VALUES (?, ?, ?);\";\n\n    // Compile the SQL query\n    rc = sqlite3_prepare_v2(db, sql, -1, &res, 0);\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"Failed to prepare statement: %s\\n\", sqlite3_errmsg(db));\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Bind values\n    sqlite3_bind_text(res, 1, username, -1, SQLITE_STATIC);\n    sqlite3_bind_text(res, 2, passwordDigest, -1, SQLITE_STATIC);\n    sqlite3_bind_text(res, 3, salt, -1, SQLITE_STATIC);\n\n    rc = sqlite3_step(res);\n\n    if (rc != SQLITE_DONE) {\n        fprintf(stderr, \"Execution failed: %s\\n\", sqlite3_errmsg(db));\n    } else {\n        printf(\"Record inserted successfully.\\n\");\n    }\n\n    // Finalize and clean up\n    sqlite3_finalize(res);\n    sqlite3_close(db);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-327-8.c","version":1.1,"compile":"gcc CASTLE-327-8.c -o CASTLE-327-8 -lssl -lcrypto","vulnerable":false,"description":"Sensitive data is encrypted with AES-256.","cwe":327,"lines":[],"id":"327-8","number":78,"hash":"91021f3a30df9f6b36f933d09308114e","line_count":101,"cyclomatic_complexity":15,"nloc":70,"functions":6,"halstead_volume":3471.855497996591,"maintainability_index":56.33166590929805,"cl100k_base_tokens":816,"code":"#include <openssl/evp.h>\n#include <openssl/aes.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n// echo \"4JICbovVrxKjS2quF4/4L3+/OquDH74WcwJrfZL0NFCtpZ4Mj2Tps0Qj20ELm981 b4710086965b47b3c5526de8f775f094\" > key_iv.txt\n\nvoid handleErrors() {\n    fprintf(stderr, \"Error occurred\\n\");\n    exit(1);\n}\n\nvoid aes256_encrypt(const char *plaintext, unsigned char *ciphertext, const unsigned char *key, const unsigned char *iv) {\n    EVP_CIPHER_CTX *ctx;\n    int len;\n    int ciphertext_len;\n\n    // Create and initialize the context\n    if (!(ctx = EVP_CIPHER_CTX_new())) handleErrors();\n\n    // Initialize the encryption operation with AES-256-CBC\n    if (1 != EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv)) handleErrors();\n\n    // Provide the message to be encrypted, and obtain the encrypted output\n    if (1 != EVP_EncryptUpdate(ctx, ciphertext, &len, (unsigned char *)plaintext, strlen(plaintext))) handleErrors();\n    ciphertext_len = len;\n\n    // Finalize the encryption\n    if (1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &len)) handleErrors();\n    ciphertext_len += len;\n\n    // Clean up\n    EVP_CIPHER_CTX_free(ctx);\n}\n\nvoid hex_to_bytes(const char *hex, unsigned char *bytes, int size) {\n    for (int i = 0; i < size; i++) {\n        sscanf(hex + 2 * i, \"%2hhx\", &bytes[i]);\n    }\n}\n\nvoid bytes_to_hex(const unsigned char *bytes, char *hex, int size) {\n    for (int i = 0; i < size; i++) {\n        sprintf(hex + 2 * i, \"%02x\", bytes[i]);\n    }\n    hex[size * 2] = '\\0';\n}\n\nint read_key_and_iv(const char *filename, unsigned char *key, unsigned char *iv) {\n    FILE *file = fopen(filename, \"r\");\n    if (!file) {\n        fprintf(stderr, \"Could not open file: %s\\n\", filename);\n        return 0;\n    }\n\n    char key_hex[65];\n    char iv_hex[33];\n\n    if (fscanf(file, \"%64s %32s\", key_hex, iv_hex) != 2) {\n        fprintf(stderr, \"Invalid format in file: %s\\n\", filename);\n        fclose(file);\n        return 0;\n    }\n\n    fclose(file);\n\n    // Convert hex strings to byte arrays\n    hex_to_bytes(key_hex, key, 32);\n    hex_to_bytes(iv_hex, iv, 16);\n\n    return 1;\n}\n\nint main() {\n    char sensitiveText[1024];\n    printf(\"Sensitive text: \");\n    fgets(sensitiveText, sizeof(sensitiveText), stdin);\n    sensitiveText[strcspn(sensitiveText, \"\\n\")] = '\\0';\n\n    unsigned char key[32];\n    unsigned char iv[16];\n    if (!read_key_and_iv(\"key_iv.txt\", key, iv)) {\n        return 1;\n    }\n\n    unsigned char ciphertext[2048];\n    aes256_encrypt(sensitiveText, ciphertext, key, iv);\n\n    // Print the encrypted message\n    char hex[4097];\n    bytes_to_hex(ciphertext, hex, sizeof(ciphertext));\n    printf(\"Encrypted: %s\\n\", hex);\n\n    // Clear the key and IV from memory\n    memset(key, 0, sizeof(key));\n    memset(iv, 0, sizeof(iv));\n    memset(sensitiveText, 0, sizeof(sensitiveText));\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-327-9.c","version":1.1,"compile":"gcc CASTLE-327-9.c -o CASTLE-327-9 -lssl -lcrypto","vulnerable":false,"description":"RSA is used with OAEP padding.","cwe":327,"lines":[],"id":"327-9","number":79,"hash":"d35ef23e32956817c5c50b1d7f366710","line_count":157,"cyclomatic_complexity":24,"nloc":129,"functions":5,"halstead_volume":5345.143751835889,"maintainability_index":42.11453171712047,"cl100k_base_tokens":1140,"code":"// openssl genrsa -out rsa.pem 2048\n// openssl rsa -in rsa.pem -outform PEM -pubout -out rsa.pem.pub\n\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/decoder.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid cleanUp(BIO* bio, EVP_PKEY* pkey, OSSL_DECODER_CTX* dctx, EVP_PKEY_CTX* ctx) {\n    BIO_free_all(bio);\n    OSSL_DECODER_CTX_free(dctx);\n    EVP_PKEY_free(pkey);\n    EVP_PKEY_CTX_free(ctx);\n}\n\nvoid bufferToHexString(unsigned char* buffer, char* string, unsigned int len) {\n    for (unsigned int i = 0; i < len; i++) {\n        sprintf(string + (i * 2), \"%02x\", buffer[i]);\n    }\n    string[len * 2] = '\\0';\n}\n\nchar* rsa_encrypt(const char* plaintext, const char* key) {\n    BIO* bio = NULL;\n    EVP_PKEY* pkey = NULL;\n    OSSL_DECODER_CTX* dctx = NULL;\n    EVP_PKEY_CTX* ctx = NULL;\n\n    const size_t inLength = strlen(plaintext);\n    const size_t keyLength = strlen(key);\n    if (inLength == 0 || keyLength == 0) {\n        return NULL;\n    }\n\n    bio = BIO_new_mem_buf(key, keyLength);\n    if (bio == NULL) {\n        cleanUp(bio, pkey, dctx, ctx);\n        return NULL;\n    }\n\n    dctx = OSSL_DECODER_CTX_new_for_pkey(&pkey, \"PEM\", NULL, \"RSA\", EVP_PKEY_PUBLIC_KEY, NULL, NULL);\n    if (dctx == NULL) {\n        cleanUp(bio, pkey, dctx, ctx);\n        return NULL;\n    }\n\n    if (!OSSL_DECODER_from_bio(dctx, bio)) {\n        cleanUp(bio, pkey, dctx, ctx);\n        return NULL;\n    }\n\n    ctx = EVP_PKEY_CTX_new(pkey, NULL);\n    if (ctx == NULL) {\n        cleanUp(bio, pkey, dctx, ctx);\n        return NULL;\n    }\n\n    if (EVP_PKEY_encrypt_init(ctx) <= 0) {\n        cleanUp(bio, pkey, dctx, ctx);\n        return NULL;\n    }\n\n    if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_OAEP_PADDING) <= 0) {\n        cleanUp(bio, pkey, dctx, ctx);\n        return NULL;\n    }\n\n    size_t length;\n    if (EVP_PKEY_encrypt(ctx, NULL, &length, (unsigned char*)plaintext, inLength) <= 0) {\n        cleanUp(bio, pkey, dctx, ctx);\n        return NULL; \n    }\n\n    unsigned char* ciphertext = (unsigned char*)malloc(length);\n    if (ciphertext == NULL) {\n        cleanUp(bio, pkey, dctx, ctx);\n        return NULL;\n    }\n\n    if (EVP_PKEY_encrypt(ctx, ciphertext, &length, (unsigned char*)plaintext, inLength) <= 0) {\n        cleanUp(bio, pkey, dctx, ctx);\n        free(ciphertext);\n        return NULL; \n    }\n\n    char* hexCiphertext = (char*)malloc(length * 2 + 1);\n    if (hexCiphertext == NULL) {\n        cleanUp(bio, pkey, dctx, ctx);\n        free(ciphertext);\n        return NULL;\n    }\n\n    bufferToHexString(ciphertext, hexCiphertext, length);\n    free(ciphertext);\n    cleanUp(bio, pkey, dctx, ctx);\n    return hexCiphertext;\n}\n\nchar* readKey(const char* filename) {\n    FILE* file = fopen(filename, \"r\");\n    if (file == NULL) {\n        return NULL;\n    }\n\n    fseek(file, 0, SEEK_END);\n    const size_t length = ftell(file);\n    if (length == 0xFFFFFFFFFFFFFFFF) {\n        fclose(file);\n        return NULL;\n    }\n\n    char* buffer = (char*)malloc(length + 1);\n    if (buffer == NULL) {\n        fclose(file);\n        return NULL;\n    }\n\n    rewind(file);\n    const size_t read = fread(buffer, 1, length, file);\n    if (read != length) {\n        fclose(file);\n        free(buffer);\n        return NULL;\n    }\n\n    buffer[length] = '\\0';\n    fclose(file);\n    return buffer;\n}\n\nint main() {\n    char* key = readKey(\"rsa.pem.pub\");\n    if (key == NULL) {\n        return 1;\n    }\n\n    char sensitiveText[1024];\n    printf(\"Sensitive text: \");\n    fgets(sensitiveText, sizeof(sensitiveText), stdin);\n    sensitiveText[strcspn(sensitiveText, \"\\n\")] = '\\0';\n\n    char* ciphertext = rsa_encrypt(sensitiveText, key);\n    if (ciphertext == NULL) {\n        free(key);\n        return 1;\n    }\n\n    printf(\"Encrypted: %s\\n\", ciphertext);\n    memset(sensitiveText, 0, sizeof(sensitiveText));\n    memset(key, 0, strlen(key));\n    free(key);\n    free(ciphertext);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-327-10.c","version":1.1,"compile":"gcc CASTLE-327-10.c -o CASTLE-327-10 -lssl -lcrypto","vulnerable":false,"description":"HMAC used with SHA256.","cwe":327,"lines":[],"id":"327-10","number":80,"hash":"e7b54f8d5a3ecf546e1679aa0b0d4897","line_count":79,"cyclomatic_complexity":11,"nloc":60,"functions":4,"halstead_volume":2706.7805106323503,"maintainability_index":61.043339030257926,"cl100k_base_tokens":566,"code":"// echo \"d25b859e5277340274873697196ba955\" > key.txt\n\n#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n\nvoid bufferToHexString(unsigned char* buffer, char* string, unsigned int len) {\n    for (unsigned int i = 0; i < len; i++) {\n        sprintf(string + (i * 2), \"%02x\", buffer[i]);\n    }\n    string[len * 2] = '\\0';\n}\n\nchar* createHMAC(const char* data, const unsigned char* key, size_t keyLen) {\n    const size_t dataLen = strlen(data);\n\n    unsigned char* hmac = NULL;\n    unsigned int hmacLen = 0;\n    hmac = HMAC(EVP_sha256(), key, keyLen, (unsigned char*)data, dataLen, hmac, &hmacLen);\n\n    char* hexHmac = (char*)malloc(2 * hmacLen + 1);\n    if (hexHmac == NULL) {\n        return NULL;\n    }\n\n    bufferToHexString(hmac, hexHmac, hmacLen);\n    return hexHmac;\n}\n\nint read_key(const char *filename, unsigned char key[16]) {\n    FILE *file = fopen(filename, \"r\");\n    if (!file) {\n        fprintf(stderr, \"Could not open file: %s\\n\", filename);\n        return 0;\n    }\n\n    char key_hex[33];\n\n    if (fscanf(file, \"%32s\", key_hex) != 1) {\n        fprintf(stderr, \"Invalid format in file: %s\\n\", filename);\n        fclose(file);\n        return 0;\n    }\n\n    fclose(file);\n\n    for (int i = 0; i < 16; i++) {\n        sscanf(key_hex + 2 * i, \"%2hhx\", &key[i]);\n    }\n\n    return 1;\n}\n\nint main() {\n    char sensitiveText[1024];\n    printf(\"Sensitive text: \");\n    fgets(sensitiveText, sizeof(sensitiveText), stdin);\n    sensitiveText[strcspn(sensitiveText, \"\\n\")] = '\\0';\n\n    unsigned char key[16];\n    if (!read_key(\"key.txt\", key)) {\n        return 1;\n    }\n\n    char* hmac = createHMAC(sensitiveText, key, 16);\n    if (hmac == NULL) {\n        return 1;\n    }\n\n    printf(\"HMAC: %s\\n\", hmac);\n    free(hmac);\n    memset(sensitiveText, 0, sizeof(sensitiveText));\n    memset(key, 0, sizeof(key));\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-362-1.c","version":1.1,"compile":"gcc CASTLE-362-1.c -o CASTLE-362-1","vulnerable":true,"description":"Race condition is not properly handled in cases where mutex lock cannot be acquired.","cwe":362,"lines":[10],"id":"362-1","number":81,"hash":"2a004efa7e481d93efdc208a14a2ee1f","line_count":47,"cyclomatic_complexity":5,"nloc":31,"functions":2,"halstead_volume":1095.4424460888558,"maintainability_index":77.82505645816497,"cl100k_base_tokens":296,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <unistd.h>\n\npthread_mutex_t mutex;\nint sharedResource = 0;\n\nvoid* threadFunction(void* arg) {\n    pthread_mutex_lock(&mutex);\n\n    // Simulate some work with the shared resource\n    int temp = sharedResource;\n    printf(\"Thread %ld: Read sharedResource = %d\\n\", (long)arg, temp);\n    if ((long)arg % 2 == 0) {\n        sleep(1); // Simulate a delay\n    }\n    sharedResource = temp + 1;\n    printf(\"Thread %ld: Updated sharedResource to %d\\n\", (long)arg, sharedResource);\n\n    pthread_mutex_unlock(&mutex);\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[5];\n\n    // Initialize the mutex\n    pthread_mutex_init(&mutex, NULL);\n\n    // Create multiple threads\n    for (long i = 0; i < 5; i++) {\n        pthread_create(&threads[i], NULL, threadFunction, (void*)i);\n    }\n\n    // Wait for all threads to finish\n    for (int i = 0; i < 5; i++) {\n        pthread_join(threads[i], NULL);\n    }\n\n    // Destroy the mutex\n    pthread_mutex_destroy(&mutex);\n\n    printf(\"Final value of sharedResource = %d\\n\", sharedResource);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-362-2.c","version":1.1,"compile":"gcc CASTLE-362-2.c -o CASTLE-362-2","vulnerable":true,"description":"Race condition not handled properly on writing to file.","cwe":362,"lines":[9,17],"id":"362-2","number":82,"hash":"ad94a02da2f985b8557e6b528cbfda25","line_count":44,"cyclomatic_complexity":6,"nloc":32,"functions":2,"halstead_volume":1055.6712460861938,"maintainability_index":77.27303147647434,"cl100k_base_tokens":239,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <unistd.h>\n\n#define NUM_THREADS 2\n\nvoid* write_to_file(void* arg) {\n    FILE* file = fopen(\"out.log\", \"a\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        pthread_exit(NULL);\n    }\n\n    sleep(1); // Simulate some work\n\n    fprintf(file, \"Thread %ld writing\\n\", (long)arg);\n    fclose(file);\n\n    pthread_exit(NULL);\n}\n\nint main() {\n    pthread_t threads[NUM_THREADS];\n    int rc;\n    long t;\n\n    // Create threads\n    for (t = 0; t < NUM_THREADS; t++) {\n        rc = pthread_create(&threads[t], NULL, write_to_file, (void*)t);\n        if (rc) {\n            printf(\"Error: unable to create thread, %d\\n\", rc);\n            exit(-1);\n        }\n    }\n\n    for (t = 0; t < NUM_THREADS; t++) {\n        pthread_join(threads[t], NULL);\n    }\n\n    printf(\"File writing complete\\n\");\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-362-3.c","version":1.1,"compile":"gcc CASTLE-362-3.c -o CASTLE-362-3","vulnerable":true,"description":"Race condition in shared memory causes undefined behaviour.","cwe":362,"lines":[22,25],"id":"362-3","number":83,"hash":"abc0b6a1f21ce119df3164d9e2193beb","line_count":53,"cyclomatic_complexity":6,"nloc":36,"functions":2,"halstead_volume":1264.6972407359754,"maintainability_index":74.42553540393631,"cl100k_base_tokens":284,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <time.h>\n\n#ifdef _WIN32\n#include <Windows.h>\n#else\n#include <unistd.h>\n#endif\n\n#define NUM_THREADS 10\n\nint counter = 0;\n\nvoid* increment_counter(void* arg) {\n    struct timespec ts;\n    ts.tv_sec = 0;\n    ts.tv_nsec = 10000000L; // 10ms\n\n    for (int i = 0; i < 1000; i++) {\n        int c = counter;\n        nanosleep(&ts, NULL);\n        c++;\n        counter = c;\n    }\n    pthread_exit(NULL);\n}\n\nint main() {\n    pthread_t threads[NUM_THREADS];\n    int rc;\n    long t;\n\n    // Create threads\n    for (t = 0; t < NUM_THREADS; t++) {\n        rc = pthread_create(&threads[t], NULL, increment_counter, NULL);\n        if (rc) {\n            printf(\"Error: unable to create thread, %d\\n\", rc);\n            exit(-1);\n        }\n    }\n\n    // Join threads\n    for (t = 0; t < NUM_THREADS; t++) {\n        pthread_join(threads[t], NULL);\n    }\n\n    // Output the final counter value\n    printf(\"Final counter value: %d\\n\", counter);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-362-4.c","version":1.1,"compile":"gcc CASTLE-362-4.c -o CASTLE-362-4","vulnerable":true,"description":"Clear case of a race condition with shared memory","cwe":362,"lines":[8],"id":"362-4","number":84,"hash":"a8f901a56a6989770fa59380adc5646e","line_count":24,"cyclomatic_complexity":3,"nloc":18,"functions":2,"halstead_volume":511.8225751427889,"maintainability_index":91.04849175537608,"cl100k_base_tokens":127,"code":"#include <stdio.h>\n#include <pthread.h>\n\nint counter = 0;\n\nvoid* increment(void* arg) {\n    for (int i = 0; i < 1000000; i++) {\n        counter++;\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t thread1, thread2;\n\n    pthread_create(&thread1, NULL, increment, NULL);\n    pthread_create(&thread2, NULL, increment, NULL);\n\n    pthread_join(thread1, NULL);\n    pthread_join(thread2, NULL);\n\n    printf(\"Final counter value: %d\\n\", counter);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-362-5.c","version":1.1,"compile":"gcc CASTLE-362-5.c -o CASTLE-362-5","vulnerable":true,"description":"Race condition as multiple threads write to the same file","cwe":362,"lines":[8,15,19],"id":"362-5","number":85,"hash":"3bd39595d465568538c3ab1b0a905d73","line_count":34,"cyclomatic_complexity":4,"nloc":26,"functions":2,"halstead_volume":830.5484659116638,"maintainability_index":82.34398740277925,"cl100k_base_tokens":189,"code":"#include <stdio.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n\nvoid* write_to_file(void* arg) {\n    FILE* file = fopen(\"logs.txt\", \"a\");\n    if (file == NULL) {\n        perror(\"Failed to open file\");\n        return NULL;\n    }\n\n    for (int i = 0; i < 100; i++) {\n        fprintf(file, \"Thread %ld writing...\\n\", (long)pthread_self());\n        usleep(10);\n    }\n\n    fclose(file);\n    return NULL;\n}\n\nint main() {\n    pthread_t thread1, thread2;\n\n    pthread_create(&thread1, NULL, write_to_file, NULL);\n    pthread_create(&thread2, NULL, write_to_file, NULL);\n\n    pthread_join(thread1, NULL);\n    pthread_join(thread2, NULL);\n\n    printf(\"Logging complete.\\n\");\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-362-6.c","version":1.1,"compile":"gcc CASTLE-362-6.c -o CASTLE-362-6","vulnerable":true,"description":"Race condition as multiple threads write to the same file","cwe":362,"lines":[14,16,25],"id":"362-6","number":86,"hash":"003a0644728bde11bbeb9b1b005a3bf9","line_count":49,"cyclomatic_complexity":6,"nloc":37,"functions":3,"halstead_volume":1068.5533056585991,"maintainability_index":74.85801281367759,"cl100k_base_tokens":266,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <signal.h>\n#include <unistd.h>\n\n#define SEQUENCER_LIMIT 1000\n\nvolatile sig_atomic_t signal_flag = 0;\n\nvoid* signal_sequencer(void* arg) {\n    int sequence = 0;\n    while (sequence < SEQUENCER_LIMIT) {\n        if (signal_flag) {\n            printf(\"%d!\\n\", sequence);\n            sequence++;\n            signal_flag = 0;\n        }\n        usleep(1000);\n    }\n    return NULL;\n}\n\nvoid signal_handler(int sig) {\n    signal_flag = 1;\n}\n\nint main() {\n    pthread_t thread1, thread2;\n\n    // Register signal handler\n    signal(SIGUSR1, signal_handler);\n\n    pthread_create(&thread1, NULL, signal_sequencer, NULL);\n    pthread_create(&thread2, NULL, signal_sequencer, NULL);\n\n    for (int i = 0; i < 5; i++) {\n        printf(\"Sending SIGUSR1...\\n\");\n        raise(SIGUSR1);\n        usleep(500000);\n    }\n\n    pthread_cancel(thread1);\n    pthread_cancel(thread2);\n    pthread_join(thread1, NULL);\n    pthread_join(thread2, NULL);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-362-7.c","version":1.1,"compile":"gcc CASTLE-362-7.c -o CASTLE-362-7","vulnerable":false,"description":"Cases where mutex lock cannot be acquired is properly handled.","cwe":362,"lines":[],"id":"362-7","number":87,"hash":"2e68d50b7e596d0d5a14bdd267813900","line_count":50,"cyclomatic_complexity":6,"nloc":34,"functions":2,"halstead_volume":1175.4712285260953,"maintainability_index":75.73195266419563,"cl100k_base_tokens":314,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <unistd.h>\n\npthread_mutex_t mutex;\nint sharedResource = 0;\n\nvoid* threadFunction(void* arg) {\n    int result = pthread_mutex_lock(&mutex);\n    if (result != 0) {\n        return NULL;\n    }\n\n    // Simulate some work with the shared resource\n    int temp = sharedResource;\n    printf(\"Thread %ld: Read sharedResource = %d\\n\", (long)arg, temp);\n    if ((long)arg % 2 == 0) {\n        sleep(1); // Simulate a delay\n    }\n    sharedResource = temp + 1;\n    printf(\"Thread %ld: Updated sharedResource to %d\\n\", (long)arg, sharedResource);\n    pthread_mutex_unlock(&mutex);\n\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[5];\n\n    // Initialize the mutex\n    pthread_mutex_init(&mutex, NULL);\n\n    // Create multiple threads\n    for (long i = 0; i < 5; i++) {\n        pthread_create(&threads[i], NULL, threadFunction, (void*)i);\n    }\n\n    // Wait for all threads to finish\n    for (int i = 0; i < 5; i++) {\n        pthread_join(threads[i], NULL);\n    }\n\n    // Destroy the mutex\n    pthread_mutex_destroy(&mutex);\n\n    printf(\"Final value of sharedResource = %d\\n\", sharedResource);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-362-8.c","version":1.1,"compile":"gcc CASTLE-362-8.c -o CASTLE-362-8","vulnerable":false,"description":"Race condition avoided by using proper mutex locking.","cwe":362,"lines":[],"id":"362-8","number":88,"hash":"0cd73f436172381e48916e4e25a177f7","line_count":57,"cyclomatic_complexity":8,"nloc":45,"functions":3,"halstead_volume":1326.9561430169815,"maintainability_index":70.10072414859529,"cl100k_base_tokens":329,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <signal.h>\n#include <unistd.h>\n\n#define SEQUENCER_LIMIT 1000\n\nvolatile sig_atomic_t signal_flag = 0;\npthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;\n\nvoid* signal_sequencer(void* arg) {\n    int sequence = 0;\n    while (sequence < SEQUENCER_LIMIT) {\n        if (pthread_mutex_lock(&lock) == 0) {\n            if (signal_flag) {\n                printf(\"%d!\\n\", sequence);\n                sequence++;\n                signal_flag = 0;\n            }\n        }\n        pthread_mutex_unlock(&lock);\n        usleep(1000);\n    }\n    return NULL;\n}\n\nvoid signal_handler(int sig) {\n    if (pthread_mutex_lock(&lock) == 0) {\n        signal_flag = 1;\n        pthread_mutex_unlock(&lock);\n    }\n}\n\nint main() {\n    pthread_t thread1, thread2;\n\n    // Register signal handler\n    signal(SIGUSR1, signal_handler);\n\n    pthread_create(&thread1, NULL, signal_sequencer, NULL);\n    pthread_create(&thread2, NULL, signal_sequencer, NULL);\n\n    for (int i = 0; i < 5; i++) {\n        printf(\"Sending SIGUSR1...\\n\");\n        raise(SIGUSR1);\n        usleep(500000);\n    }\n\n    pthread_cancel(thread1);\n    pthread_cancel(thread2);\n    pthread_join(thread1, NULL);\n    pthread_join(thread2, NULL);\n    pthread_mutex_destroy(&lock);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-362-9.c","version":1.1,"compile":"gcc CASTLE-362-9.c -o CASTLE-362-9","vulnerable":false,"description":"Race condition avoided by using different memory for each thread","cwe":362,"lines":[],"id":"362-9","number":89,"hash":"c65841b00040096227f038cbb3f66513","line_count":40,"cyclomatic_complexity":5,"nloc":31,"functions":2,"halstead_volume":1105.8853053193718,"maintainability_index":77.77571962013849,"cl100k_base_tokens":227,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n\n\nint counter[2] = {0, 0};\n\nvoid* increment(void* arg) {\n    int* id = (int*)arg;\n    for (int i = 0; i < 1000000; i++) {\n        counter[*id]++;\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t thread1, thread2;\n    int* a = malloc(sizeof(int));\n    int* b = malloc(sizeof(int));\n    if (a == NULL || b == NULL) {\n        free(a);\n        free(b);\n        exit(-1);\n    }\n    *a = 0;\n    *b = 1;\n\n    pthread_create(&thread1, NULL, increment, a);\n    pthread_create(&thread2, NULL, increment, b);\n\n    pthread_join(thread1, NULL);\n    pthread_join(thread2, NULL);\n\n    printf(\"Final counter values: %d, %d\\n\", counter[0], counter[1]);\n    \n    free(a);\n    free(b);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-362-10.c","version":1.1,"compile":"gcc CASTLE-362-10.c -o CASTLE-362-10","vulnerable":false,"description":"Race condition avoided by writing to different files","cwe":362,"lines":[],"id":"362-10","number":90,"hash":"bd589edc1e74dd29b77fd3fa9e0b7cf5","line_count":47,"cyclomatic_complexity":6,"nloc":35,"functions":2,"halstead_volume":1204.4735626056909,"maintainability_index":75.1356124644778,"cl100k_base_tokens":258,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <unistd.h>\n\n#define NUM_THREADS 2\n\nvoid* write_to_file(void* arg) {\n    long* t = (long*)arg;\n    char filename[256];\n    sprintf(filename, \"out_%ld.log\", *t);\n    FILE* file = fopen(filename, \"a\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        pthread_exit(NULL);\n    }\n\n    sleep(1);\n\n    fprintf(file, \"Thread %ld writing\\n\", (long)arg);\n    fclose(file);\n\n    pthread_exit(NULL);\n}\n\nint main() {\n    pthread_t threads[NUM_THREADS];\n    int rc;\n    long t;\n\n    // Create threads\n    for (t = 0; t < NUM_THREADS; t++) {\n        rc = pthread_create(&threads[t], NULL, write_to_file, &t);\n        if (rc) {\n            printf(\"Error: unable to create thread, %d\\n\", rc);\n            exit(-1);\n        }\n    }\n\n    for (t = 0; t < NUM_THREADS; t++) {\n        pthread_join(threads[t], NULL);\n    }\n\n    printf(\"File writing complete\\n\");\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-369-1.c","version":1.1,"compile":"gcc CASTLE-369-1.c -o CASTLE-369-1 -fno-stack-protector -fno-pie -no-pie -z execstack","vulnerable":true,"description":"Mathematical error: division by zero.","cwe":369,"lines":[10],"id":"369-1","number":91,"hash":"ee75bb3ba8d1655553ce6207108f334f","line_count":13,"cyclomatic_complexity":1,"nloc":12,"functions":1,"halstead_volume":343.01880011637485,"maintainability_index":100,"cl100k_base_tokens":85,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int hello= (8003+1) % 26;\n    printf(\"Result is %d\",hello);\n    int b=atoi(\"-42\");\n    printf(\"Result is %d\",b);\n    int test= 17/ (hello+20+b);\n    printf(\"Result is %d\",test);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-369-2.c","version":1.1,"compile":"gcc CASTLE-369-2.c -o CASTLE-369-2 -fno-stack-protector -fno-pie -no-pie -z execstack","vulnerable":true,"description":"Mathematical error: division by zero.","cwe":369,"lines":[7],"id":"369-2","number":92,"hash":"ec44fc1b4ab575ffc6f3764696af5bef","line_count":11,"cyclomatic_complexity":1,"nloc":9,"functions":1,"halstead_volume":228.3251067709959,"maintainability_index":100,"cl100k_base_tokens":53,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int nn=(atoi(\"2\")*500)-1000;\n    int what= 1000/ (nn);\n    printf(\"%d\\n\", what);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-369-3.c","version":1.1,"compile":"gcc CASTLE-369-3.c -o CASTLE-369-3 -fno-stack-protector -fno-pie -no-pie -z execstack","vulnerable":true,"description":"Mathematical error: division by zero.","cwe":369,"lines":[13],"id":"369-3","number":93,"hash":"8a4a1fa1e6599cdb6497100fee5c63ce","line_count":18,"cyclomatic_complexity":2,"nloc":14,"functions":1,"halstead_volume":686.4816370412093,"maintainability_index":93.82305798407143,"cl100k_base_tokens":160,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int MD5 = ((1 << 13) | (1 << 11) | (3 << 1) ) + 1007;\n    printf(\"%d\\n\", MD5);\n    int password = 1337;\n\n    for(int i =0;i<13500;i++) {\n        password = password+(MD5+3) % 2611;\n        password = MD5*2+(password+(1 << 4))%10017;\n        MD5 = (password * (MD5 - ((1 << 4) | (1 << 1)) +198)) % 10013;\n        printf(\"%d\\n\", password/MD5);\n\n    }\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-369-4.c","version":1.1,"compile":"gcc CASTLE-369-4.c -o CASTLE-369-4","vulnerable":true,"description":"Mathematical error: division by zero.","cwe":369,"lines":[20],"id":"369-4","number":94,"hash":"878c63a95a0dbcdd7dd9b5ee1b4c10f7","line_count":24,"cyclomatic_complexity":3,"nloc":18,"functions":2,"halstead_volume":533.8256241050872,"maintainability_index":90.82961747921688,"cl100k_base_tokens":133,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid stepRand(int* rand) {\n    *rand = (*rand + 1223) % 37;\n}\n\nint main() {\n    int input = 0;\n    int seed = 0;\n\n    printf(\"Enter input and seed: \");\n    scanf(\"%9d\", &input);\n    scanf(\"%9d\", &seed);\n\n    int rand = seed % 37;\n\n    for(int i = 0; i < 1000; i++) {\n        stepRand(&rand);\n        printf(\"Value now: %d\\n\", input / rand);\n    }\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-369-5.c","version":1.1,"compile":"gcc CASTLE-369-5.c -o CASTLE-369-5","vulnerable":true,"description":"Mathematical error: division by zero.","cwe":369,"lines":[11],"id":"369-5","number":95,"hash":"358f8475151066628a8fac8981237aea","line_count":15,"cyclomatic_complexity":2,"nloc":11,"functions":1,"halstead_volume":422.8321775089799,"maintainability_index":100,"cl100k_base_tokens":98,"code":"#include <stdio.h>\n\nint main() {\n    int input = 0;\n    int a[] = {1, 2, 3, 4, 5};\n\n    printf(\"Enter input: \");\n    scanf(\"%9d\", &input);\n\n    for(int i = (sizeof(a) / sizeof(a[0])) - 1; i >= 0; --i) {\n        printf(\"%d\\n\", input / i);\n    }\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-369-6.c","version":1.1,"compile":"gcc CASTLE-369-6.c -o CASTLE-369-6","vulnerable":true,"description":"Mathematical error: division by zero.","cwe":369,"lines":[21],"id":"369-6","number":96,"hash":"333ddd2a180a294e07a4578d5c4b0e3a","line_count":24,"cyclomatic_complexity":6,"nloc":19,"functions":3,"halstead_volume":485.9729501355773,"maintainability_index":89.75209312369346,"cl100k_base_tokens":119,"code":"#include <stdio.h>\n\nint fibonacci(int n) {\n    if (n < 0) {\n        return -1;\n    }\n    if (n == 0 || n == 1) {\n        return n;\n    }\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nint sqr(int n) {\n    return n * n;\n}\n\nint main() {\n    const int a = 123;\n    const int b = 12;\n\n    printf(\"%d\\n\", a / (fibonacci(b) - sqr(b)));\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-369-7.c","version":1.1,"compile":"gcc CASTLE-369-7.c -o CASTLE-369-7","vulnerable":false,"description":"No division by zero","cwe":369,"lines":[],"id":"369-7","number":97,"hash":"aba7895122eba5ddbc01647f4d8e7b67","line_count":17,"cyclomatic_complexity":2,"nloc":12,"functions":2,"halstead_volume":353.10758835509176,"maintainability_index":99.77729374789976,"cl100k_base_tokens":85,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint devide(long long a, long long b) {\n    return a / b;\n}\n\nint main() {\n    int input = 0;\n\n    printf(\"Enter input: \");\n    scanf(\"%9d\", &input);\n\n    printf(\"Result: %d\\n\", devide(input, (long long)1-1+1));\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-369-8.c","version":1.1,"compile":"gcc CASTLE-369-8.c -o CASTLE-369-8","vulnerable":false,"description":"No division by zero in the printf function","cwe":369,"lines":[],"id":"369-8","number":98,"hash":"bcd5d140b59e551c2b32df8d4823e47f","line_count":9,"cyclomatic_complexity":1,"nloc":8,"functions":1,"halstead_volume":195.04195997053841,"maintainability_index":100,"cl100k_base_tokens":56,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int a = 1;\n    int b = 0;\n    printf(\"%d\\n\", 1/(b-a)); // There is a known issue in this line!!\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-369-9.c","version":1.1,"compile":"gcc CASTLE-369-9.c -o CASTLE-369-9","vulnerable":false,"description":"No division by zero, becuase the divisor is not zero","cwe":369,"lines":[],"id":"369-9","number":99,"hash":"b35c0fa951f3e2e911cc7cdab1fa3ff6","line_count":7,"cyclomatic_complexity":1,"nloc":6,"functions":1,"halstead_volume":127.37720526058406,"maintainability_index":100,"cl100k_base_tokens":35,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    printf(\"%f\\n\", 0./94553.88423);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-369-10.c","version":1.1,"compile":"gcc CASTLE-369-10.c -o CASTLE-369-10","vulnerable":false,"description":"No division by zero","cwe":369,"lines":[],"id":"369-10","number":100,"hash":"a45ab1d2861b891b00cec85e7eba754a","line_count":14,"cyclomatic_complexity":1,"nloc":8,"functions":1,"halstead_volume":201.90890672641936,"maintainability_index":100,"cl100k_base_tokens":56,"code":"#include <stdio.h>\n\n#define ZERO 3\n\nint main() {\n    int input = 0;\n\n    printf(\"Enter input: \");\n    scanf(\"%9d\", &input);\n\n    printf(\"Result: %d\\n\", input / ZERO);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-401-1.c","version":1.1,"compile":"gcc CASTLE-401-1.c -o CASTLE-401-1","vulnerable":true,"description":"Memory is not released after effective lifetime.","cwe":401,"lines":[5,16],"id":"401-1","number":101,"hash":"83bef83228ba091fae2e1b75ab90d6d5","line_count":21,"cyclomatic_complexity":4,"nloc":17,"functions":2,"halstead_volume":449.25918860329114,"maintainability_index":92.42242393724896,"cl100k_base_tokens":102,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid dosth() {\n    int *A = (int*) malloc(sizeof(int) * 10);\n    if (A == NULL) {\n        perror(\"Could not reserve memory!\");\n        return;\n    }\n\n    for (int i = 1; i < 4; i++) {\n        A[i] = i;\n    }\n\n    printf(\"%d\", A[1]);\n}\n\nint main() {\n    dosth();\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-401-2.c","version":1.1,"compile":"gcc CASTLE-401-2.c -o CASTLE-401-2","vulnerable":true,"description":"Memory is not released after effective lifetime.","cwe":401,"lines":[14,15,22,36],"id":"401-2","number":102,"hash":"74d87b22329082b0e77834ebc35a9d78","line_count":36,"cyclomatic_complexity":7,"nloc":29,"functions":2,"halstead_volume":787.479712601683,"maintainability_index":80.16185198953912,"cl100k_base_tokens":181,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint* createCleanBuffer(int size, int data) {\n    if (size <= 0) {\n        return NULL;\n    }\n\n    int *b = (int*)malloc(sizeof(int) * size);\n    if (!b) {\n        return NULL;\n    }\n\n    if (data < 0) {\n        return NULL;\n    }\n    for (int i = 0; i < size; i++) {\n        b[i] = data;\n    }\n\n    return b;\n}\n\nint main() {\n    const int bufferSize = 12;\n    int* buf = createCleanBuffer(bufferSize, -1);\n    if (buf == NULL) {\n        perror(\"Could not reserve memory!\");\n        return 1;\n    }\n\n    printf(\"%d\\n\", buf[bufferSize/2]);\n    free(buf);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-401-3.c","version":1.1,"compile":"gcc CASTLE-401-3.c -o CASTLE-401-3","vulnerable":true,"description":"Memory is not freed after function terminates.","cwe":401,"lines":[6,14],"id":"401-3","number":103,"hash":"0ce4de260dc957ad2c534ca7d90907b9","line_count":23,"cyclomatic_complexity":3,"nloc":19,"functions":2,"halstead_volume":626.0712529815829,"maintainability_index":89.12487476366287,"cl100k_base_tokens":136,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint addStrLength(const char *str1, const char *str2) {\n    char* str = (char*)malloc(sizeof(char) * 2048);\n    if (str == NULL) {\n        return -1;\n    }\n    str[0] = 0;\n    strcat(str, str1);\n    strcat(str, str2);\n    return strlen(str);\n}\n\nint main() {\n    const char *s1 = \"asd\";\n    const char *s2 = \"::\";\n\n    printf(\"%d\", addStrLength(s1, s2));\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-401-4.c","version":1.1,"compile":"gcc CASTLE-401-4.c -o CASTLE-401-4","vulnerable":true,"description":"Memory is not freed after obfuscated program terminates.","cwe":401,"lines":[8,31],"id":"401-4","number":104,"hash":"cdd022256afdba4559d9e76cbac97bcd","line_count":31,"cyclomatic_complexity":5,"nloc":21,"functions":3,"halstead_volume":784.4960103786867,"maintainability_index":85.87052077855637,"cl100k_base_tokens":158,"code":"#include <stdio.h>\n#include <stdlib.h>\n\n#define A 10\n#define B 20\n\nvoid *x(int y) {\n    void *ptr = malloc(y);\n    return ptr;\n}\n\nvoid y(int *arr, int size) {\n    for (int i = 0; i < size; i++) {\n        arr[i] = i * i;\n    }\n}\n\nint main() {\n    int *p = (int *)x(A * B * sizeof(int));\n    if (p == NULL) {\n        exit(1);\n    }\n    \n    y(p, A * B);\n\n    int z = (A + B) * (A - B) / (B - A + 1);\n\n    printf(\"OK\\n\");\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-401-5.c","version":1.1,"compile":"gcc CASTLE-401-5.c -o CASTLE-401-5","vulnerable":true,"description":"Memory is not released after effective lifetime, tricked by swap function","cwe":401,"lines":[22,39],"id":"401-5","number":105,"hash":"6abb550c8ef59dfe7e43a0e6e49688d8","line_count":39,"cyclomatic_complexity":6,"nloc":31,"functions":4,"halstead_volume":948.2867048174008,"maintainability_index":78.34519147091638,"cl100k_base_tokens":213,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint square(int* a) {\n    int b = *a * *a;\n    return b;\n}\n\nvoid swap(int** a, int** b) {\n    int* temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid safeFree(int** a) {\n    free(*a);\n    *a = NULL;\n}\n\nint main() {\n    int *a = (int*)malloc(sizeof(int));\n    int *b = (int*)malloc(sizeof(int));\n    if (a == NULL || b == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    *a = 5;\n    printf(\"Result: %d\\n\", square(a));\n\n    *b = -7;\n    printf(\"Result: %d\\n\", square(b));\n\n    safeFree(&a);\n    swap(&a, &b);\n    safeFree(&b);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-401-6.c","version":1.1,"compile":"gcc CASTLE-401-6.c -o CASTLE-401-6","vulnerable":true,"description":"Memory is not released after effective lifetime, tricked by swap function called f","cwe":401,"lines":[22,39],"id":"401-6","number":106,"hash":"65ac5e5c8fe05e3bebdacc954f5b414f","line_count":39,"cyclomatic_complexity":6,"nloc":31,"functions":4,"halstead_volume":948.2867048174008,"maintainability_index":78.34519147091638,"cl100k_base_tokens":213,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint square(int* a) {\n    int b = *a * *a;\n    return b;\n}\n\nvoid f(int** a, int** b) {\n    int* temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid safeFree(int** a) {\n    free(*a);\n    *a = NULL;\n}\n\nint main() {\n    int *a = (int*)malloc(sizeof(int));\n    int *b = (int*)malloc(sizeof(int));\n    if (a == NULL || b == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    *a = 5;\n    printf(\"Result: %d\\n\", square(a));\n\n    *b = -7;\n    printf(\"Result: %d\\n\", square(b));\n\n    safeFree(&a);\n    f(&a, &b);\n    safeFree(&b);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-401-7.c","version":1.1,"compile":"gcc CASTLE-401-7.c -o CASTLE-401-7","vulnerable":false,"description":"Memory is freed after use in all cases.","cwe":401,"lines":[],"id":"401-7","number":107,"hash":"4c466f2069086ea066eb592aa453a76f","line_count":35,"cyclomatic_complexity":7,"nloc":29,"functions":2,"halstead_volume":777.6424392348692,"maintainability_index":80.22722004413524,"cl100k_base_tokens":181,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint* createCleanBuffer(int size, int data) {\n    if (size <= 0) {\n        return NULL;\n    }\n    if (data < 0) {\n        return NULL;\n    }\n\n    int *b = (int*)malloc(sizeof(int) * size);\n    if (!b) {\n        return NULL;\n    }\n\n    for (int i = 0; i < size; i++) {\n        b[i] = data;\n    }\n\n    return b;\n}\n\nint main() {\n    const int bufferSize = 12;\n    int* buf = createCleanBuffer(bufferSize, 0);\n    if (buf == NULL) {\n        perror(\"Could not reserve memory!\");\n        return 1;\n    }\n\n    printf(\"%d\\n\", buf[bufferSize/2]);\n    free(buf);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-401-8.c","version":1.1,"compile":"gcc CASTLE-401-8.c -o CASTLE-401-8","vulnerable":false,"description":"Both allocated memory chunks are freed properly","cwe":401,"lines":[],"id":"401-8","number":108,"hash":"ee0f3dc6135f7754a39d93e4fade2194","line_count":41,"cyclomatic_complexity":6,"nloc":33,"functions":4,"halstead_volume":991.1471208543455,"maintainability_index":77.10249000679538,"cl100k_base_tokens":221,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint square(int* a) {\n    int b = *a * *a;\n    return b;\n}\n\nvoid swap(int** a, int** b) {\n    int* temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid safeFree(int** a) {\n    free(*a);\n    *a = NULL;\n}\n\nint main() {\n    int *a = (int*)malloc(sizeof(int));\n    int *b = (int*)malloc(sizeof(int));\n    if (a == NULL || b == NULL) {\n        free(a);\n        free(b);\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    *a = 5;\n    printf(\"Result: %d\\n\", square(a));\n\n    *b = -7;\n    printf(\"Result: %d\\n\", square(b));\n\n    safeFree(&a);\n    swap(&a, &b);\n    safeFree(&a);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-401-9.c","version":1.1,"compile":"gcc CASTLE-401-9.c -o CASTLE-401-9","vulnerable":false,"description":"Both allocated memory chunks are freed properly","cwe":401,"lines":[],"id":"401-9","number":109,"hash":"afc8ee016759e676dd2f848d87777334","line_count":41,"cyclomatic_complexity":6,"nloc":33,"functions":4,"halstead_volume":991.1471208543455,"maintainability_index":77.10249000679538,"cl100k_base_tokens":221,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint square(int* a) {\n    int b = *a * *a;\n    return b;\n}\n\nvoid f(int** a, int** b) {\n    int* temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid safeFree(int** a) {\n    free(*a);\n    *a = NULL;\n}\n\nint main() {\n    int *a = (int*)malloc(sizeof(int));\n    int *b = (int*)malloc(sizeof(int));\n    if (a == NULL || b == NULL) {\n        free(a);\n        free(b);\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    *a = 5;\n    printf(\"Result: %d\\n\", square(a));\n\n    *b = -7;\n    printf(\"Result: %d\\n\", square(b));\n\n    safeFree(&a);\n    f(&a, &b);\n    safeFree(&a);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-401-10.c","version":1.1,"compile":"gcc CASTLE-401-10.c -o CASTLE-401-10","vulnerable":false,"description":"Memory is released after effective lifetime, condition for free is always true","cwe":401,"lines":[],"id":"401-10","number":110,"hash":"6ad7ef8f9fe18031fa29b573200a4ccf","line_count":26,"cyclomatic_complexity":4,"nloc":19,"functions":2,"halstead_volume":466.7647545419919,"maintainability_index":90.42179649310786,"cl100k_base_tokens":122,"code":"#include <stdio.h>\n#include <stdlib.h>\n\n#define false 1\n\nint square(int* a) {\n    int b = *a * *a;\n    return b;\n}\n\nint main() {\n    int *a = (int*)malloc(sizeof(int));\n    if (a == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    *a = 5;\n    printf(\"Result: %d\\n\", square(a));\n\n    if (false) {\n        free(a);\n    }\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-415-1.c","version":1.1,"compile":"gcc CASTLE-415-1.c -o CASTLE-415-1","vulnerable":true,"description":"Freeing memory again after it has been freed","cwe":415,"lines":[22],"id":"415-1","number":111,"hash":"66ac6ea718558ffe1ca7669048e69afb","line_count":25,"cyclomatic_complexity":3,"nloc":19,"functions":2,"halstead_volume":464.0842589809777,"maintainability_index":90.68174466997068,"cl100k_base_tokens":119,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint square(int* a) {\n    int b = *a * *a;\n    free(a);\n    return b;\n}\n\nint main() {\n    int *a = (int*) malloc(sizeof(int));\n\n    if (a == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    *a = 5;\n    int b = square(a);\n    printf(\"Result: %d\\n\", b);\n\n    free(a);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-415-2.c","version":1.1,"compile":"gcc CASTLE-415-2.c -o CASTLE-415-2","vulnerable":true,"description":"Freeing memory again after it has been freed, tricked by swap function","cwe":415,"lines":[31],"id":"415-2","number":112,"hash":"9e46702f90ed6e157c8e5e2274eb4bfd","line_count":35,"cyclomatic_complexity":5,"nloc":28,"functions":3,"halstead_volume":761.0979195161638,"maintainability_index":81.36752442207576,"cl100k_base_tokens":179,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint square(int* a) {\n    int b = *a * *a;\n    free(a);\n    return b;\n}\n\nvoid swap(int** a, int** b) {\n    int* temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int *a = (int*) malloc(sizeof(int));\n\n    if (a == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    *a = 5;\n    int b = square(a);\n    printf(\"Result: %d\\n\", b);\n\n    int *p = &b;\n    swap(&a, &p);\n    if (b > 20) {\n        free(p);\n    }\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-415-3.c","version":1.1,"compile":"gcc CASTLE-415-3.c -o CASTLE-415-3","vulnerable":true,"description":"Freeing memory again after it has been freed, tricked by swap function called f","cwe":415,"lines":[31],"id":"415-3","number":113,"hash":"ebd190f246094cdb0d660f63afd8091d","line_count":35,"cyclomatic_complexity":5,"nloc":28,"functions":3,"halstead_volume":761.0979195161638,"maintainability_index":81.36752442207576,"cl100k_base_tokens":179,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint square(int* a) {\n    int b = *a * *a;\n    free(a);\n    return b;\n}\n\nvoid f(int** a, int** b) {\n    int* temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int *a = (int*) malloc(sizeof(int));\n\n    if (a == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    *a = 5;\n    int b = square(a);\n    printf(\"Result: %d\\n\", b);\n\n    int *p = &b;\n    f(&a, &p);\n    if (b > 20) {\n        free(p);\n    }\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-415-4.c","version":1.1,"compile":"gcc CASTLE-415-4.c -o CASTLE-415-4","vulnerable":true,"description":"Freeing memory again after it has been freed","cwe":415,"lines":[13],"id":"415-4","number":114,"hash":"a5bbf74ea97201cc8fa2e9d9d2be15eb","line_count":16,"cyclomatic_complexity":2,"nloc":12,"functions":1,"halstead_volume":264.4045207131682,"maintainability_index":100,"cl100k_base_tokens":72,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *a = (int*) malloc(sizeof(int));\n\n    if (a == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    free(a);\n    free(a);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-415-5.c","version":1.1,"compile":"gcc CASTLE-415-5.c -o CASTLE-415-5","vulnerable":true,"description":"Freeing memory again after it has been freed","cwe":415,"lines":[19],"id":"415-5","number":115,"hash":"a4e8929cb9fcbdce35c4d7ee2951d360","line_count":22,"cyclomatic_complexity":3,"nloc":15,"functions":2,"halstead_volume":373.28516483252554,"maintainability_index":95.64340499060455,"cl100k_base_tokens":93,"code":"#include <stdio.h>\n#include <stdlib.h>\n\n#define CHECK_NULL(ptr) check(ptr)\n\nvoid check(void *ptr) {\n    free(ptr);\n}\n\nint main() {\n    int *a = (int*) malloc(sizeof(int));\n\n    if (a == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    CHECK_NULL(a);\n    free(a);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-415-6.c","version":1.1,"compile":"gcc CASTLE-415-6.c -o CASTLE-415-6","vulnerable":true,"description":"Freeing memory again after it has been freed in a function","cwe":415,"lines":[32],"id":"415-6","number":116,"hash":"e40612a8cd39e7f73544967057f366b6","line_count":34,"cyclomatic_complexity":6,"nloc":28,"functions":3,"halstead_volume":751.2044260237537,"maintainability_index":81.20556227212579,"cl100k_base_tokens":180,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint* allocateArray(int size) {\n    int* buffer = (int*) malloc(size * sizeof(int));\n\n    if (buffer == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return NULL;\n    }\n    return buffer;\n}\n\nvoid cleanup(int* ptr, int size) {\n    for (int i = 0; i < size; i++) {\n        ptr[i] = 0;\n    }\n    free(ptr);\n}\n\nint main() {\n    // get int from user input\n    int size;\n    printf(\"Enter the size of the array: \");\n    scanf(\"%9d\", &size);\n\n    int* array = allocateArray(5);\n    if (array == NULL) {\n        exit(1);\n    }\n    cleanup(array, 5);\n    free(array);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-415-7.c","version":1.1,"compile":"gcc CASTLE-415-7.c -o CASTLE-415-7","vulnerable":false,"description":"Both allocated memory chunks are freed properly","cwe":415,"lines":[],"id":"415-7","number":117,"hash":"88d59e6ec5d3d47c9b2136be82297016","line_count":33,"cyclomatic_complexity":4,"nloc":26,"functions":3,"halstead_volume":755.7015619358763,"maintainability_index":82.83507408178514,"cl100k_base_tokens":172,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint square(int* a) {\n    int b = *a * *a;\n    return b;\n}\n\nvoid f(int** a, int** b) {\n    int* temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int *a = (int*) malloc(sizeof(int));\n\n    if (a == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    *a = 5;\n    int b = square(a);\n    printf(\"Result: %d\\n\", b);\n    free(a);\n\n    int *p = (int*) malloc(sizeof(int));\n    f(&a, &p);\n    free(a);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-415-8.c","version":1.1,"compile":"gcc CASTLE-415-8.c -o CASTLE-415-8","vulnerable":false,"description":"Both allocated memory chunks are freed properly","cwe":415,"lines":[],"id":"415-8","number":118,"hash":"365ac9bec30144f3b4ec677aea393df2","line_count":33,"cyclomatic_complexity":4,"nloc":26,"functions":3,"halstead_volume":760.9494894493198,"maintainability_index":82.79908777899337,"cl100k_base_tokens":173,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint square(int* a) {\n    int b = *a * *a;\n    return b;\n}\n\nvoid swap(int** a, int** b) {\n    int* temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int *a = (int*) malloc(sizeof(int));\n\n    if (a == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    *a = 5;\n    int b = square(a);\n    printf(\"Result: %d\\n\", b);\n    free(a);\n\n    int *p = (int*) malloc(sizeof(int));;\n    swap(&a, &p);\n    free(a);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-415-9.c","version":1.1,"compile":"gcc CASTLE-415-9.c -o CASTLE-415-9","vulnerable":false,"description":"memory is not freed twice because it is not freed in the cleanup function","cwe":415,"lines":[],"id":"415-9","number":119,"hash":"25092a619092905b9151453dd2aabab0","line_count":33,"cyclomatic_complexity":6,"nloc":27,"functions":3,"halstead_volume":729.1101781995258,"maintainability_index":81.9499535160723,"cl100k_base_tokens":176,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint* allocateArray(int size) {\n    int* buffer = (int*) malloc(size * sizeof(int));\n\n    if (buffer == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return NULL;\n    }\n    return buffer;\n}\n\nvoid cleanup(int* ptr, int size) {\n    for (int i = 0; i < size; i++) {\n        ptr[i] = 0;\n    }\n}\n\nint main() {\n    // get int from user input\n    int size;\n    printf(\"Enter the size of the array: \");\n    scanf(\"%9d\", &size);\n\n    int* array = allocateArray(5);\n    if (array == NULL) {\n        exit(1);\n    }\n    cleanup(array, 5);\n    free(array);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-415-10.c","version":1.1,"compile":"gcc CASTLE-415-10.c -o CASTLE-415-10","vulnerable":false,"description":"Memory is only freed once","cwe":415,"lines":[],"id":"415-10","number":120,"hash":"74e6ad083d9d312a2f4fca9be2d6d608","line_count":15,"cyclomatic_complexity":2,"nloc":11,"functions":1,"halstead_volume":245.1751010249378,"maintainability_index":100,"cl100k_base_tokens":68,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *a = (int*) malloc(sizeof(int));\n\n    if (a == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    free(a);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-416-1.c","version":1.1,"compile":"gcc CASTLE-416-1.c -o CASTLE-416-1","vulnerable":true,"description":"Memory is used after being freed","cwe":416,"lines":[20],"id":"416-1","number":121,"hash":"c8c3cf132a2e20cbb2b9737db6ccffba","line_count":23,"cyclomatic_complexity":3,"nloc":18,"functions":2,"halstead_volume":442.6092671887795,"maintainability_index":91.8040032216616,"cl100k_base_tokens":114,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid square(int* a) {\n    int b = *a;\n    *a = b * b;\n    free(a);\n}\n\nint main() {\n    int *a = (int*) malloc(sizeof(int));\n\n    if (a == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    *a = 5;\n    square(a);\n    printf(\"Result: %d\\n\", *a);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-416-2.c","version":1.1,"compile":"gcc CASTLE-416-2.c -o CASTLE-416-2","vulnerable":true,"description":"Memory is used after being freed","cwe":416,"lines":[10,31,32],"id":"416-2","number":122,"hash":"2472464580f3bf9e39a69f55ed5fe20b","line_count":35,"cyclomatic_complexity":5,"nloc":27,"functions":3,"halstead_volume":682.2305767476661,"maintainability_index":82.5255307838892,"cl100k_base_tokens":169,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid square(int* a) {\n    int b = *a;\n    *a = b * b;\n}\n\nvoid negate(int* a) {\n    *a = -(*a);\n    free(a);\n}\n\nint main() {\n    int *a = (int*) malloc(sizeof(int));\n\n    if (a == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    *a = 5;\n    square(a);\n    printf(\"Result: %d\\n\", *a);\n\n    int* p = NULL;\n    if (*a > 20) {\n        p = a;\n    }\n\n    negate(p);\n    printf(\"Result: %d\\n\", *p);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-416-3.c","version":1.1,"compile":"gcc CASTLE-416-3.c -o CASTLE-416-3","vulnerable":true,"description":"Memory is used after being freed, tricked by swap function","cwe":416,"lines":[34],"id":"416-3","number":123,"hash":"9acb25c5df95562cf18b9da011273c21","line_count":39,"cyclomatic_complexity":5,"nloc":30,"functions":3,"halstead_volume":881.6518222585223,"maintainability_index":79.48525687970448,"cl100k_base_tokens":202,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid square(int* a) {\n    int b = *a;\n    *a = b * b;\n}\n\nvoid swap(int** a, int** b) {\n    int* temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int *a = (int*) malloc(sizeof(int));\n    int *b = (int*) malloc(sizeof(int));\n\n    if (a == NULL || b == NULL) {\n        free(a);\n        free(b);\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    *a = 5;\n    square(a);\n    printf(\"Result: %d\\n\", *a);\n\n    *b = *a;\n    free(a);\n\n    swap(&a, &b);\n    printf(\"Result: %d\\n\", *b);\n\n    free(a);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-416-4.c","version":1.1,"compile":"gcc CASTLE-416-4.c -o CASTLE-416-4","vulnerable":true,"description":"Memory is used after being freed, tricked by swap function called f","cwe":416,"lines":[34],"id":"416-4","number":124,"hash":"7ad52cdb2a41c7661ddd273823a00e93","line_count":39,"cyclomatic_complexity":5,"nloc":30,"functions":3,"halstead_volume":881.6518222585223,"maintainability_index":79.48525687970448,"cl100k_base_tokens":202,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid square(int* a) {\n    int b = *a;\n    *a = b * b;\n}\n\nvoid f(int** a, int** b) {\n    int* temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int *a = (int*) malloc(sizeof(int));\n    int *b = (int*) malloc(sizeof(int));\n\n    if (a == NULL || b == NULL) {\n        free(a);\n        free(b);\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    *a = 5;\n    square(a);\n    printf(\"Result: %d\\n\", *a);\n\n    *b = *a;\n    free(a);\n\n    f(&a, &b);\n    printf(\"Result: %d\\n\", *b);\n\n    free(a);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-416-5.c","version":1.1,"compile":"gcc CASTLE-416-5.c -o CASTLE-416-5","vulnerable":true,"description":"Memory is used after being freed","cwe":416,"lines":[5,7,23],"id":"416-5","number":125,"hash":"fc48db4231763f69f64d1a4c0b5cb534","line_count":26,"cyclomatic_complexity":3,"nloc":20,"functions":2,"halstead_volume":501.4827251399043,"maintainability_index":89.44777753420156,"cl100k_base_tokens":135,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid doCalcWithoutFree(int* a) {\n    int b = *a * *a;\n    printf(\"Result: %d\\n\", b);\n    free(a);\n}\n\nint main() {\n    int *a = (int*) malloc(sizeof(int));\n\n    if (a == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    int* p = a;\n    *a = 5;\n    *p = 6;\n\n    doCalcWithoutFree(a);\n    doCalcWithoutFree(p);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-416-6.c","version":1.1,"compile":"gcc CASTLE-416-6.c -o CASTLE-416-6","vulnerable":true,"description":"Writing to memory that has been freed","cwe":416,"lines":[32],"id":"416-6","number":126,"hash":"7c387597905f3f91a102bb968acd8460","line_count":35,"cyclomatic_complexity":6,"nloc":29,"functions":3,"halstead_volume":805.4153834932574,"maintainability_index":80.27474518111663,"cl100k_base_tokens":191,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint* allocateArray(int size) {\n    int* buffer = (int*) malloc(size * sizeof(int));\n\n    if (buffer == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return NULL;\n    }\n    return buffer;\n}\n\nvoid cleanup(int* ptr, int size) {\n    for (int i = 0; i < size; i++) {\n        ptr[i] = 0;\n    }\n    free(ptr);\n}\n\nint main() {\n    int size;\n    printf(\"Enter the size of the array: \");\n    scanf(\"%9d\", &size);\n\n    int* array = allocateArray(5);\n    if (array == NULL) {\n        exit(1);\n    }\n    cleanup(array, 5);\n\n    array[0] = size;\n    printf(\"First element of the array: %d\\n\", size);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-416-7.c","version":1.1,"compile":"gcc CASTLE-416-7.c -o CASTLE-416-7","vulnerable":false,"description":"Both allocated memory chunks are freed, and not used after free","cwe":416,"lines":[],"id":"416-7","number":127,"hash":"3a3af9fe62ec37cd7c10e036111f010e","line_count":44,"cyclomatic_complexity":6,"nloc":34,"functions":4,"halstead_volume":996.5046728589635,"maintainability_index":76.5908395908692,"cl100k_base_tokens":222,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid square(int* a) {\n    int b = *a;\n    *a = b * b;\n}\n\nvoid swap(int** a, int** b) {\n    int* temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid negate(int* a) {\n    *a = -(*a);\n}\n\nint main() {\n    int *a = (int*) malloc(sizeof(int));\n    int *b = (int*) malloc(sizeof(int));\n\n    if (a == NULL || b == NULL) {\n        free(a);\n        free(b);\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    *a = 5;\n    square(a);\n    printf(\"Result: %d\\n\", *a);\n    free(a);\n\n    swap(&a, &b);\n\n    *a = 3;\n    negate(a);\n    printf(\"Result: %d\\n\", *a);\n\n    free(a);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-416-8.c","version":1.1,"compile":"gcc CASTLE-416-8.c -o CASTLE-416-8","vulnerable":false,"description":"Both allocated memory chunks are freed, and not used after free","cwe":416,"lines":[],"id":"416-8","number":128,"hash":"26618b105e560a48bdcde0c0f17580f9","line_count":44,"cyclomatic_complexity":6,"nloc":34,"functions":4,"halstead_volume":996.5046728589635,"maintainability_index":76.5908395908692,"cl100k_base_tokens":222,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid square(int* a) {\n    int b = *a;\n    *a = b * b;\n}\n\nvoid f(int** a, int** b) {\n    int* temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid negate(int* a) {\n    *a = -(*a);\n}\n\nint main() {\n    int *a = (int*) malloc(sizeof(int));\n    int *b = (int*) malloc(sizeof(int));\n\n    if (a == NULL || b == NULL) {\n        free(a);\n        free(b);\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    *a = 5;\n    square(a);\n    printf(\"Result: %d\\n\", *a);\n    free(a);\n\n    f(&a, &b);\n\n    *a = 3;\n    negate(a);\n    printf(\"Result: %d\\n\", *a);\n\n    free(a);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-416-9.c","version":1.1,"compile":"gcc CASTLE-416-9.c -o CASTLE-416-9","vulnerable":false,"description":"Memory is properly allocated and freed.","cwe":416,"lines":[],"id":"416-9","number":129,"hash":"a39e76f6b18b5bc72b644f510c177d01","line_count":23,"cyclomatic_complexity":2,"nloc":18,"functions":1,"halstead_volume":375.08064232528443,"maintainability_index":92.89484406701148,"cl100k_base_tokens":97,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nstruct test {\n    double a;\n    char symbol;\n    char pointer;\n    char null;\n};\n\nint main() {\n    struct test *p = malloc(sizeof(struct test));\n    if (p == NULL) {\n        printf(\"Memory allocation failed.\\n\");\n        return 1; // Return a non-zero value to indicate failure\n    }\n\n    p->a = 0;\n    free(p);\n\n    return 0;\n}\n"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-416-10.c","version":1.1,"compile":"gcc CASTLE-416-10.c -o CASTLE-416-10","vulnerable":false,"description":"Memory is properly freed despite being swapped around","cwe":416,"lines":[],"id":"416-10","number":130,"hash":"ba530ac2e154fd57b2a781c094b9df9f","line_count":37,"cyclomatic_complexity":5,"nloc":29,"functions":3,"halstead_volume":844.9163296644172,"maintainability_index":80.25577201182824,"cl100k_base_tokens":190,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid square(int* a) {\n    int b = *a;\n    *a = b * b;\n}\n\nvoid swap(int** a, int** b) {\n    int* temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int *a = (int*) malloc(sizeof(int));\n    int *b = (int*) malloc(sizeof(int));\n\n    if (a == NULL || b == NULL) {\n        free(a);\n        free(b);\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    *a = 5;\n    square(a);\n    printf(\"Result: %d\\n\", *a);\n\n    *b = *a;\n    free(a);\n\n    swap(&a, &b);\n    free(a);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-476-1.c","version":1.1,"compile":"gcc CASTLE-476-1.c -o CASTLE-476-1 -fno-stack-protector -fno-pie -no-pie -z execstack","vulnerable":true,"description":"Potential null pointer dereference because malloc function can retrun NULL.","cwe":476,"lines":[5,8],"id":"476-1","number":131,"hash":"ee41e5678461fb2a60f65b13deac0f48","line_count":14,"cyclomatic_complexity":2,"nloc":10,"functions":1,"halstead_volume":302.20597493359935,"maintainability_index":100,"cl100k_base_tokens":80,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *A = (int*) malloc(sizeof(int) * 10); // Here malloc can return NULL!\n\n    for(int i=1; i<=4; i++) {\n        A[i] = i;\n        // printf(\"%d\\n\", A[i]);\n    }\n    free(A);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-476-2.c","version":1.1,"compile":"gcc CASTLE-476-2.c -o CASTLE-476-2 -fno-stack-protector -fno-pie -no-pie -z execstack","vulnerable":true,"description":"Potential null pointer dereference because malloc function can retrun NULL.","cwe":476,"lines":[7,9,13],"id":"476-2","number":132,"hash":"a05c8166d07262de94c17fe90f98ec58","line_count":20,"cyclomatic_complexity":3,"nloc":16,"functions":1,"halstead_volume":520.945336562895,"maintainability_index":92.86470809639029,"cl100k_base_tokens":129,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n=3;\n    printf(\"Enter 3 number (maximum 3 digits)\");\n    int *arr = (int*) malloc(n * sizeof(int)); //malloc() can return NULL\n    for(int i = 0; i < n; i++) {\n        scanf(\"%3d\", &arr[i]);\n    }\n    printf(\"The element of the arraye are: \");\n    for(int i = 0; i < n; i++) {\n\t\tprintf(\" %d \", arr[i]);\n    }\n\n    free(arr);\n\n    return 0;\n}\n"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-476-3.c","version":1.1,"compile":"gcc CASTLE-476-3.c -o CASTLE-476-3","vulnerable":true,"description":"Dereferencing the result of a function, which can return nullptr","cwe":476,"lines":[19],"id":"476-3","number":133,"hash":"363c00e95232888088e4384df684a8d2","line_count":22,"cyclomatic_complexity":4,"nloc":18,"functions":2,"halstead_volume":573.2417574250535,"maintainability_index":90.2291782986875,"cl100k_base_tokens":160,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint* min(int* a, int* b) {\n    if (*a < *b) {\n        return a;\n    }\n    if (*b < *a) {\n        return b;\n    }\n    return NULL;\n}\n\nint main() {\n    int a = 3, b = 5;\n\n    printf(\"min(%d, %d) = %d\\n\", a, b, *min(&a, &b));\n    printf(\"min(%d, %d) = %d\\n\", b, a, *min(&b, &a));\n    printf(\"min(%d, %d) = %d\\n\", a, a, *min(&a, &a));\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-476-4.c","version":1.1,"compile":"gcc CASTLE-476-4.c -o CASTLE-476-4","vulnerable":true,"description":"Dereferencing after the last member of linked list","cwe":476,"lines":[51],"id":"476-4","number":134,"hash":"c21e2ac1b96c36999384b15f84fca97a","line_count":66,"cyclomatic_complexity":10,"nloc":55,"functions":4,"halstead_volume":1504.7422382228758,"maintainability_index":65.73604255963409,"cl100k_base_tokens":363,"code":"#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct ListNode {\n    int value;\n    struct ListNode* next;\n} ListNode;\n\n\nListNode* createFirstNode(int value) {\n    ListNode* first = (ListNode*)malloc(sizeof(ListNode));\n    if (first == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        exit(1); // Indicate error and exit\n    }\n    first->value = value;\n    first->next = NULL;\n    return first;\n}\n\nvoid addNode(ListNode* first, int value) {\n    if (first == NULL) {\n        return;\n    }\n\n    ListNode* last = first;\n    while (last->next != NULL) {\n        last = last->next;\n    }\n\n    ListNode* new = (ListNode*)malloc(sizeof(ListNode));\n    if (new == NULL) {\n        while (first != NULL) {\n            ListNode* next = first->next;\n            free(first);\n            first = next;\n        }\n        printf(\"Failed to allocate memory.\\n\");\n        exit(1); // Indicate error and exit\n    }\n\n    last->next = new;\n    new->value = value;\n    new->next = NULL;\n}\n\nvoid printAndFree(ListNode* first) {\n    while (first != NULL) {\n        ListNode copy = *first;\n        free(first);\n        printf(\"Curr value: %d, next value: %d\\n\", copy.value, copy.next->value);\n        first = copy.next;\n    }\n}\n\nint main() {\n    ListNode* l = createFirstNode(0);\n    addNode(l, 1);\n    addNode(l, 2);\n    addNode(l, 3);\n    addNode(l, 4);\n\n    printAndFree(l);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-476-5.c","version":1.1,"compile":"gcc CASTLE-476-5.c -o CASTLE-476-5","vulnerable":true,"description":"Dereferencing an always null value","cwe":476,"lines":[10],"id":"476-5","number":135,"hash":"3b603660a36aa6ec1cf5bc125d055c2b","line_count":13,"cyclomatic_complexity":2,"nloc":10,"functions":2,"halstead_volume":197.1533875310097,"maintainability_index":100,"cl100k_base_tokens":62,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint* generateAlwaysNonNullResult() {\n    return NULL; // Will implement later\n}\n\nint main() {\n    int* a = generateAlwaysNonNullResult();\n    printf(\"AlwaysNonNullResult: %d\\n\", *a);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-476-6.c","version":1.1,"compile":"gcc CASTLE-476-6.c -o CASTLE-476-6","vulnerable":true,"description":"Dereferencing the result of a complex function, which always return nullptr","cwe":476,"lines":[35],"id":"476-6","number":136,"hash":"af661179545d5c8e8e2265611aeb05e5","line_count":38,"cyclomatic_complexity":6,"nloc":29,"functions":3,"halstead_volume":1010.6477719407375,"maintainability_index":79.09440438864661,"cl100k_base_tokens":237,"code":"#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int a;\n    int* p;\n} IntAndPtr;\n\ntypedef unsigned long long int ulli;\n\nint global = 0;\n\nIntAndPtr add(IntAndPtr a, IntAndPtr b) {\n    int* p = (ulli)a.p < (ulli)b.p ? a.p : b.p;\n    return (IntAndPtr) {a.a + b.a, p};\n}\n\nIntAndPtr fibonacci(int a) {\n    if (a <= 0) {\n        return (IntAndPtr) {0, NULL};\n    }\n    if (a == 1) {\n        return (IntAndPtr) {1, &global};\n    }\n\n    return add(fibonacci(a - 2), fibonacci(a - 1));\n}\n\nint main() {\n    int input = 0;\n    printf(\"Enter a number: \");\n    scanf(\"%9d\", &input);\n\n    IntAndPtr result = fibonacci(input);\n    printf(\"fibonacci(%d) = %d, %d\\n\", input, result.a, *result.p);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-476-7.c","version":1.1,"compile":"gcc CASTLE-476-7.c -o CASTLE-476-7","vulnerable":false,"description":"No null dereference, becuase malloc return value is correctly checked.","cwe":476,"lines":[],"id":"476-7","number":137,"hash":"ee57acd3581d964e20e1bb0949089f65","line_count":17,"cyclomatic_complexity":3,"nloc":13,"functions":1,"halstead_volume":356.12239888752373,"maintainability_index":98.20639306704973,"cl100k_base_tokens":78,"code":"#include <stdio.h>\n#include <stdlib.h>\n\n\nint main() {\n    int *A = (int*) malloc(sizeof(int) * 10);\n    if (A == NULL) {\n        return 0;\n    }\n\n    for(int i=1; i<=4; i++) {\n        A[i] = i;\n    }\n    free(A);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-476-8.c","version":1.1,"compile":"gcc CASTLE-476-8.c -o CASTLE-476-8","vulnerable":false,"description":"The derefered value is not null","cwe":476,"lines":[],"id":"476-8","number":138,"hash":"787a1ac3565d44d95f563096c0c60df0","line_count":14,"cyclomatic_complexity":1,"nloc":9,"functions":1,"halstead_volume":252.61501174663374,"maintainability_index":100,"cl100k_base_tokens":62,"code":"#include <stdio.h>\n#include <stdlib.h>\n\n#define NULLPTR p\n\nint main() {\n    int a = 8;\n    int* p = &a;\n\n    const int* const nullptr = NULLPTR;\n    printf(\"Value: %d\\n\", *nullptr);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-476-9.c","version":1.1,"compile":"gcc CASTLE-476-9.c -o CASTLE-476-9","vulnerable":false,"description":"Cannot dereference null result because the values are never equal","cwe":476,"lines":[],"id":"476-9","number":139,"hash":"05ef163f1f7b9769258c9d4223acbc81","line_count":21,"cyclomatic_complexity":4,"nloc":17,"functions":2,"halstead_volume":490.6560805078848,"maintainability_index":91.96407796254158,"cl100k_base_tokens":133,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint* min(int* a, int* b) {\n    if (*a < *b) {\n        return a;\n    }\n    if (*b < *a) {\n        return b;\n    }\n    return NULL;\n}\n\nint main() {\n    int a = 3, b = 5;\n\n    printf(\"min(%d, %d) = %d\\n\", a, b, *min(&a, &b));\n    printf(\"min(%d, %d) = %d\\n\", b, a, *min(&b, &a));\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-476-10.c","version":1.1,"compile":"gcc CASTLE-476-10.c -o CASTLE-476-10","vulnerable":false,"description":"Dereferencing an always null value","cwe":476,"lines":[],"id":"476-10","number":140,"hash":"7d21966ff6b3ac86a7fa6917988b951e","line_count":18,"cyclomatic_complexity":3,"nloc":16,"functions":2,"halstead_volume":373.28516483252554,"maintainability_index":94.5978809481759,"cl100k_base_tokens":94,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint* generateAlwaysNonNullResult() {\n    int* a = (int*) malloc(sizeof(int));\n    if (a == NULL) {\n        perror(\"Malloc failure\");\n        exit(1);\n    }\n    return a;\n}\n\nint main() {\n    int* a = generateAlwaysNonNullResult();\n    printf(\"AlwaysNonNullResult: %d\\n\", *a);\n    free(a);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-522-1.c","version":1.1,"compile":"gcc CASTLE-522-1.c -o CASTLE-522-1 -lsqlite3","vulnerable":true,"description":"Password is stored as plain text in the database.","cwe":522,"lines":[70,74],"id":"522-1","number":141,"hash":"0b826e95577ed41958f80b49e99b6859","line_count":97,"cyclomatic_complexity":17,"nloc":76,"functions":4,"halstead_volume":2505.047791125893,"maintainability_index":56.23659181088155,"cl100k_base_tokens":618,"code":"// create table users (id INT, username VARCHAR(32), password VARCHAR(32), token VARCHAR(32));\n// insert into users values (1, \"tom\", \"password\", \"1h6df8ddfn\");\n\n#include <stdio.h>\n#include <sqlite3.h>\n#include <string.h>\n#include <ctype.h>\n\n#define SQLITE_FILE \"users.db\"\n\nvoid replace_newline(char *str) {\n    while (*str) {\n        if (*str == '\\n') {\n            *str = '\\0';\n            break;\n        }\n        str++;\n    }\n}\n\nint isValidUsername(char *input) {\n    for (int i = 0; i < strlen(input); i++) {\n        if (!isalpha(input[i])) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint isValidPassword(char *input) {\n    for (int i = 0; i < strlen(input); i++) {\n        if (!isalpha(input[i]) && !isdigit(input[i])) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    sqlite3 *db;\n    int rc;\n    rc = sqlite3_open(SQLITE_FILE, &db);\n\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"Cannot open database: %s\\n\", sqlite3_errmsg(db));\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Prepare an SQL query\n    char username[32];\n    printf(\"Username: \");\n    fgets(username, sizeof(username), stdin);\n    replace_newline(username);\n    if (!isValidUsername(username)) {\n        printf(\"Invalid username!\\n\");\n        return 1;\n    }\n\n    char password[32];\n    printf(\"Password: \");\n    fgets(password, sizeof(password), stdin);\n    replace_newline(password);\n    if (!isValidPassword(password)) {\n        printf(\"Invalid password!\\n\");\n        return 1;\n    }\n\n    char sql[256];\n    snprintf(sql, sizeof(sql), \"SELECT * FROM users WHERE username = '%s' and password = '%s'\", username, password);\n\n    // Compile the SQL query\n    sqlite3_stmt *res;\n    rc = sqlite3_prepare_v2(db, sql, -1, &res, 0);\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"Failed to prepare statement: %s\\n\", sqlite3_errmsg(db));\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Execute SQL query\n    int row_count = 0;\n    while (sqlite3_step(res) == SQLITE_ROW) {\n        const unsigned char *token = sqlite3_column_text(res, 3);\n        printf(\"Login successful. Your token: %s\\n\", token);\n        row_count++;\n    }\n    if (row_count == 0) {\n        printf(\"Invalid username or password.\\n\");\n    }\n\n    // Finalize and clean up\n    sqlite3_finalize(res);\n    sqlite3_close(db);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-522-2.c","version":1.1,"compile":"gcc CASTLE-522-2.c -o CASTLE-522-2 -lsqlite3","vulnerable":true,"description":"Cleartext storage of password in database.","cwe":522,"lines":[56,68],"id":"522-2","number":142,"hash":"ffcb376245ca2cf3db886149a7881f5c","line_count":83,"cyclomatic_complexity":13,"nloc":62,"functions":3,"halstead_volume":2295.076273667128,"maintainability_index":60.91011190765971,"cl100k_base_tokens":563,"code":"// create table users (username VARCHAR(32), password VARCHAR(32));\n\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n#include <sqlite3.h>\n\nint isValidUsername(char *input) {\n    for (int i = 0; i < strlen(input); i++) {\n        if (!isalpha(input[i])) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint isValidPassword(char *input) {\n    for (int i = 0; i < strlen(input); i++) {\n        if (!isalpha(input[i]) && !isdigit(input[i])) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    sqlite3 *db;\n    sqlite3_stmt *res;\n    int rc;\n\n    rc = sqlite3_open(\"users.db\", &db);\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"Cannot open database: %s\\n\", sqlite3_errmsg(db));\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Read user data\n    char username[32];\n    printf(\"Username: \");\n    fgets(username, sizeof(username), stdin);\n    username[strcspn(username, \"\\n\")] = '\\0'; // Remove trailing newline\n\n    char password[32];\n    printf(\"Password: \");\n    fgets(password, sizeof(password), stdin);\n    password[strcspn(password, \"\\n\")] = '\\0'; // Remove trailing newline\n\n    if (isValidUsername(username) == 0 || isValidPassword(password) == 0) {\n        fprintf(stderr, \"Username or password is not valid\\n\");\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Prepare an SQL query\n    const char *sql = \"INSERT INTO users (username, password) VALUES (?, ?);\";\n\n    // Compile the SQL query\n    rc = sqlite3_prepare_v2(db, sql, -1, &res, 0);\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"Failed to prepare statement: %s\\n\", sqlite3_errmsg(db));\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Bind values\n    sqlite3_bind_text(res, 1, username, -1, SQLITE_STATIC);\n    sqlite3_bind_text(res, 2, password, -1, SQLITE_STATIC);\n\n    rc = sqlite3_step(res);\n\n    if (rc != SQLITE_DONE) {\n        fprintf(stderr, \"Execution failed: %s\\n\", sqlite3_errmsg(db));\n    } else {\n        printf(\"Record inserted successfully.\\n\");\n    }\n\n    // Finalize and clean up\n    sqlite3_finalize(res);\n    sqlite3_close(db);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-522-3.c","version":1.1,"compile":"gcc CASTLE-522-3.c -o CASTLE-522-3","vulnerable":true,"description":"Password in Configuration File","cwe":522,"lines":[112,123],"id":"522-3","number":143,"hash":"605f714087409929932c503d7d92ffb6","line_count":152,"cyclomatic_complexity":28,"nloc":129,"functions":8,"halstead_volume":4546.820358484589,"maintainability_index":42.035685133553216,"cl100k_base_tokens":933,"code":"// echo -e \"USERNAME=apple\\nPASSWORD=secret123\" > config.txt\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct ConfigEntry {\n    char* name;\n    char* value;\n    struct ConfigEntry* next;\n} ConfigEntry;\n\nConfigEntry* createConfigEntry(char* name, unsigned int nameSize, char* value, unsigned int valueSize) {\n    ConfigEntry* entry = (ConfigEntry*)malloc(sizeof(ConfigEntry));\n    if (entry == NULL) {\n        return NULL;\n    }\n\n    entry->name = (char*)malloc(nameSize + 1);\n    entry->value = (char*)malloc(valueSize + 1);\n    entry->next = NULL;\n    if (entry->name == NULL || entry->value == NULL) {\n        free(entry->name);\n        free(entry->value);\n        free(entry);\n        return NULL;\n    }\n\n    strncpy(entry->name, name, nameSize);\n    strncpy(entry->value, value, valueSize);\n    entry->name[nameSize] = '\\0';\n    entry->value[valueSize] = '\\0';\n    return entry;\n}\n\nConfigEntry* loadConfig(char* path) {\n    FILE* file = fopen(path, \"r\");\n    if (file == NULL) {\n        return NULL;\n    }\n\n    ConfigEntry* entries = NULL;\n    ConfigEntry* lastEntry = NULL;\n    char line[256];\n\n    while (fgets(line, sizeof(line), file)) {\n        char* firstEquals = strchr(line, '=');\n        if (firstEquals == NULL) {\n            continue;\n        }\n\n        char* value = firstEquals + 1;\n        unsigned int nameSize = firstEquals - line;\n        unsigned int valueSize = strlen(value);\n        if (valueSize > 0) {\n            valueSize -= 1;\n        }\n        if (nameSize == 0 || valueSize == 0) {\n            fclose(file);\n            return entries;\n        }\n        \n        ConfigEntry* entry = createConfigEntry(line, nameSize, value, valueSize);\n        if (entry == NULL) {\n            fclose(file);\n            return entries;\n        }\n\n        if (entries == NULL) {\n            entries = entry;\n            lastEntry = entry;\n        } else {\n            lastEntry->next = entry;\n            lastEntry = entry;\n        }\n    }\n\n    fclose(file);\n    return entries;\n}\n\nvoid freeConfig(ConfigEntry* entries) {\n    ConfigEntry* current = entries;\n    while (current != NULL) {\n        ConfigEntry* next = current->next;\n        free(current->name);\n        free(current->value);\n        free(current);\n        current = next;\n    }\n}\n\nchar* findEntryValue(ConfigEntry* entries, char* name) {\n    ConfigEntry* current = entries;\n    while (current != NULL) {\n        if (strcmp(current->name, name) == 0) {\n            return current->value;\n        }\n        current = current->next;\n    }\n    return NULL;\n}\n\nvoid getString(char* buffer, unsigned int size, char* prompt) {\n    printf(\"%s\", prompt);\n    fgets(buffer, size, stdin);\n    buffer[strcspn(buffer, \"\\n\")] = '\\0';\n}\n\nint auth(ConfigEntry* entries){\n    char* username = findEntryValue(entries, \"USERNAME\");\n    char* password = findEntryValue(entries, \"PASSWORD\");\n    if (username == NULL || password == NULL) {\n        printf(\"Failed to find username or password\\n\");\n        return 0;\n    }\n\n    char inputUsername[256];\n    char inputPassword[256];\n    getString(inputUsername, sizeof(inputUsername), \"Enter username: \");\n    getString(inputPassword, sizeof(inputPassword), \"Enter password: \");\n\n    if (strcmp(username, inputUsername) == 0 && strcmp(password, inputPassword) == 0) {\n        printf(\"Login successful\\n\");\n        return 1;\n    } else {\n        printf(\"Login failed\\n\");\n        return 0;\n    }\n}\n\nvoid shareSecret() {\n    printf(\"No secrets here yet\\n\"); // Will implement later\n}\n\nint main() {\n    ConfigEntry* entries = loadConfig(\"config.txt\");\n    if (entries == NULL) {\n        printf(\"Failed to load config\\n\");\n        return 1;\n    }\n\n    if (auth(entries)) {\n        printf(\"Welcome to the system\\n\");\n        shareSecret();\n    } else {\n        printf(\"Access denied\\n\");\n    }\n\n    freeConfig(entries);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-522-4.c","version":1.1,"compile":"gcc CASTLE-522-4.c -o CASTLE-522-4 -lcurl","vulnerable":true,"description":"Password in Configuration File (echo -e \"UN=apple\\nPD=secret123\" > config.txt)","cwe":522,"lines":[105,120],"id":"522-4","number":144,"hash":"464d899d7cd85999c9c55e5adde63c23","line_count":150,"cyclomatic_complexity":26,"nloc":127,"functions":7,"halstead_volume":4415.58977425498,"maintainability_index":42.90110642011099,"cl100k_base_tokens":899,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <curl/curl.h>\n\ntypedef struct ConfigEntry {\n    char* name;\n    char* value;\n    struct ConfigEntry* next;\n} ConfigEntry;\n\nConfigEntry* createConfigEntry(char* name, unsigned int nameSize, char* value, unsigned int valueSize) {\n    ConfigEntry* entry = (ConfigEntry*)malloc(sizeof(ConfigEntry));\n    if (entry == NULL) {\n        return NULL;\n    }\n\n    entry->name = (char*)malloc(nameSize + 1);\n    entry->value = (char*)malloc(valueSize + 1);\n    entry->next = NULL;\n    if (entry->name == NULL || entry->value == NULL) {\n        free(entry->name);\n        free(entry->value);\n        free(entry);\n        return NULL;\n    }\n\n    strncpy(entry->name, name, nameSize);\n    strncpy(entry->value, value, valueSize);\n    entry->name[nameSize] = '\\0';\n    entry->value[valueSize] = '\\0';\n    return entry;\n}\n\nConfigEntry* loadConfig(char* path) {\n    FILE* file = fopen(path, \"r\");\n    if (file == NULL) {\n        return NULL;\n    }\n\n    ConfigEntry* entries = NULL;\n    ConfigEntry* lastEntry = NULL;\n    char line[256];\n\n    while (fgets(line, sizeof(line), file)) {\n        char* firstEquals = strchr(line, '=');\n        if (firstEquals == NULL) {\n            continue;\n        }\n\n        char* value = firstEquals + 1;\n        unsigned int nameSize = firstEquals - line;\n        unsigned int valueSize = strlen(value);\n        if (valueSize > 0) {\n            valueSize -= 1;\n        }\n        if (nameSize == 0 || valueSize == 0) {\n            fclose(file);\n            return entries;\n        }\n\n        ConfigEntry* entry = createConfigEntry(line, nameSize, value, valueSize);\n        if (entry == NULL) {\n            fclose(file);\n            return entries;\n        }\n\n        if (entries == NULL) {\n            entries = entry;\n            lastEntry = entry;\n        } else {\n            lastEntry->next = entry;\n            lastEntry = entry;\n        }\n    }\n\n    fclose(file);\n    return entries;\n}\n\nvoid freeConfig(ConfigEntry* entries) {\n    ConfigEntry* current = entries;\n    while (current != NULL) {\n        ConfigEntry* next = current->next;\n        free(current->name);\n        free(current->value);\n        free(current);\n        current = next;\n    }\n}\n\nchar* findEntryValue(ConfigEntry* entries, char* name) {\n    ConfigEntry* current = entries;\n    while (current != NULL) {\n        if (strcmp(current->name, name) == 0) {\n            return current->value;\n        }\n        current = current->next;\n    }\n    return NULL;\n}\n\nint auth(ConfigEntry* entries){\n    char* username = findEntryValue(entries, \"UN\");\n    char* not_password = findEntryValue(entries, \"PD\");\n    if (username == NULL || not_password == NULL) {\n        printf(\"Failed to find username or password\\n\");\n        return 0;\n    }\n\n    CURL* curl = NULL;\n    CURLcode res = CURLE_OK;\n\n    curl = curl_easy_init();\n    if (curl == NULL) {\n        return 0;\n    }\n\n    char postData[256];\n    snprintf(postData, sizeof(postData), \"username=%s&password=%s\", username, not_password);\n\n    curl_easy_setopt(curl, CURLOPT_URL, \"https://mypage.com/login\");\n    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postData);\n    res = curl_easy_perform(curl);\n    curl_easy_cleanup(curl);\n\n    return res == CURLE_OK;\n}\n\nvoid shareSecret() {\n    printf(\"No secrets here yet\\n\"); // Will implement later\n}\n\nint main() {\n    ConfigEntry* entries = loadConfig(\"config.txt\");\n    if (entries == NULL) {\n        printf(\"Failed to load config\\n\");\n        return 1;\n    }\n\n    if (auth(entries)) {\n        printf(\"Welcome to the system\\n\");\n        shareSecret();\n    } else {\n        printf(\"Access denied\\n\");\n    }\n\n    freeConfig(entries);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-522-5.c","version":1.1,"compile":"gcc CASTLE-522-5.c -o CASTLE-522-5","vulnerable":true,"description":"Plain text password is stored in a file","cwe":522,"lines":[13],"id":"522-5","number":145,"hash":"dabb4816845aa19da5bbad76d7911666","line_count":18,"cyclomatic_complexity":2,"nloc":15,"functions":1,"halstead_volume":380.5489597580819,"maintainability_index":95.77318956796998,"cl100k_base_tokens":92,"code":"#include <stdio.h>\n#include <string.h>\n\nint main() {\n    FILE *file;\n    char password[32];\n\n    file = fopen(\"credentials.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Error opening file\\n\");\n        return 1;\n    }\n    fscanf(file, \"%31s\", password);\n    fclose(file);\n\n    printf(\"Password length: %zu\\n\", strlen(password));\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-522-6.c","version":1.1,"compile":"gcc CASTLE-522-6.c -o CASTLE-522-6","vulnerable":true,"description":"Plain text password is stored in /etc/passwd following convention in legacy UNIX systems.","cwe":522,"lines":[17],"id":"522-6","number":146,"hash":"7786bff71b17f158f6ce338ed6b16331","line_count":39,"cyclomatic_complexity":3,"nloc":25,"functions":2,"halstead_volume":930.7989138774702,"maintainability_index":82.61678666143602,"cl100k_base_tokens":280,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define PASSWD_FILE \"/etc/passwd\"\n\n\nvoid add_user(const char *username, const char *password) {\n    FILE *passwd_file = fopen(PASSWD_FILE, \"a\");\n\n    if (passwd_file == NULL) {\n        perror(\"Error opening /etc/passwd\");\n        exit(1);\n    }\n\n    // Format: username:x:uid:gid:comment:home_dir:shell\n    fprintf(passwd_file, \"%s:%s:1001:1001::/home/%s:/bin/bash\\n\", username, password, username);\n\n    fclose(passwd_file);\n    printf(\"User %s added to /etc/passwd with password: %s (INSECURE)\\n\", username, password);\n}\n\nint main() {\n    char username[50];\n    char password[50];\n\n    printf(\"Enter new username: \");\n    fgets(username, sizeof(username), stdin);\n    username[strcspn(username, \"\\n\")] = 0;  // Remove newline character\n\n    printf(\"Enter password for user: \");\n    fgets(password, sizeof(password), stdin);\n    password[strcspn(password, \"\\n\")] = 0;  // Remove newline character\n\n    // Add user to /etc/passwd\n    add_user(username, password);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-522-7.c","version":1.1,"compile":"gcc CASTLE-522-7.c -o CASTLE-522-7 -lsqlite3 -lssl -lcrypto","vulnerable":false,"description":"Password is hashed before being stored in the database.","cwe":522,"lines":[],"id":"522-7","number":147,"hash":"ac2305ff87a6d97a08211df861629e0e","line_count":155,"cyclomatic_complexity":23,"nloc":121,"functions":6,"halstead_volume":4875.200162931322,"maintainability_index":43.86022766474299,"cl100k_base_tokens":1076,"code":"// create table users (username VARCHAR(32), password VARCHAR(32));\n\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n#include <sqlite3.h>\n#include <openssl/evp.h>\n#include <openssl/err.h>\n\nvoid sha256_hash_string(unsigned char hash[EVP_MAX_MD_SIZE], char outputBuffer[65], unsigned int hash_len) {\n    for (unsigned int i = 0; i < hash_len; i++) {\n        sprintf(outputBuffer + (i * 2), \"%02x\", hash[i]);\n    }\n    outputBuffer[hash_len * 2] = '\\0';\n}\n\nvoid sha256(const char *str, char outputBuffer[65]) {\n    EVP_MD_CTX *mdctx;\n    const EVP_MD *md;\n    unsigned char hash[EVP_MAX_MD_SIZE];\n    unsigned int hash_len;\n\n    md = EVP_sha256();\n    mdctx = EVP_MD_CTX_new();\n\n    if (!mdctx) {\n        printf(\"Error creating EVP_MD_CTX\\n\");\n        return;\n    }\n\n    if (1 != EVP_DigestInit_ex(mdctx, md, NULL)) {\n        printf(\"Error initializing digest\\n\");\n        EVP_MD_CTX_free(mdctx);\n        return;\n    }\n\n    if (1 != EVP_DigestUpdate(mdctx, str, strlen(str))) {\n        printf(\"Error updating digest\\n\");\n        EVP_MD_CTX_free(mdctx);\n        return;\n    }\n\n    if (1 != EVP_DigestFinal_ex(mdctx, hash, &hash_len)) {\n        printf(\"Error finalizing digest\\n\");\n        EVP_MD_CTX_free(mdctx);\n        return;\n    }\n\n    sha256_hash_string(hash, outputBuffer, hash_len);\n    EVP_MD_CTX_free(mdctx);\n}\n\nint generateSalt(char outSalt[33]) {\n    unsigned char randBytes[16];\n    int result = RAND_bytes(randBytes, 16);\n    if (result != 1) {\n        printf(\"RAND_bytes failed\\n\");\n        return 0;\n    }\n    bufferToHexString(randBytes, outSalt, 16);\n    return 1;\n}\n\nint isValidUsername(char *input) {\n    for (int i = 0; i < strlen(input); i++) {\n        if (!isalpha(input[i])) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint isValidPassword(char *input) {\n    for (int i = 0; i < strlen(input); i++) {\n        if (!isalpha(input[i]) && !isdigit(input[i])) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    sqlite3 *db;\n    sqlite3_stmt *res;\n    int rc;\n\n    rc = sqlite3_open(\"users.db\", &db);\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"Cannot open database: %s\\n\", sqlite3_errmsg(db));\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Read user data\n    char username[32];\n    printf(\"Username: \");\n    fgets(username, sizeof(username), stdin);\n    username[strcspn(username, \"\\n\")] = '\\0'; // Remove trailing newline\n\n    char password[32];\n    printf(\"Password: \");\n    fgets(password, sizeof(password), stdin);\n    password[strcspn(password, \"\\n\")] = '\\0'; // Remove trailing newline\n\n    if (isValidUsername(username) == 0 || isValidPassword(password) == 0) {\n        fprintf(stderr, \"Username or password is not valid\\n\");\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Generating salt and hashing salted password\n    char salt[33];\n    if (generateSalt(salt) == 0) {\n        fprintf(stderr, \"Failed to generate salt\\n\");\n        sqlite3_close(db);\n        return 1;\n    }\n    printf(\"Salt: %s\\n\", salt);\n\n    char saltedPassword[65];\n    strncpy(saltedPassword, password, 33); // To always allow null termination\n    strncat(saltedPassword, salt, 32);\n\n    char passwordDigest[65];\n    sha256(saltedPassword, passwordDigest);\n\n    // Prepare an SQL query\n    const char *sql = \"INSERT INTO users (username, password) VALUES (?, ?);\";\n\n    // Compile the SQL query\n    rc = sqlite3_prepare_v2(db, sql, -1, &res, 0);\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"Failed to prepare statement: %s\\n\", sqlite3_errmsg(db));\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Bind values\n    sqlite3_bind_text(res, 1, username, -1, SQLITE_STATIC);\n    sqlite3_bind_text(res, 2, passwordDigest, -1, SQLITE_STATIC);\n\n    rc = sqlite3_step(res);\n\n    if (rc != SQLITE_DONE) {\n        fprintf(stderr, \"Execution failed: %s\\n\", sqlite3_errmsg(db));\n    } else {\n        printf(\"Record inserted successfully.\\n\");\n    }\n\n    // Finalize and clean up\n    sqlite3_finalize(res);\n    sqlite3_close(db);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-522-8.c","version":1.1,"compile":"gcc CASTLE-522-8.c -o CASTLE-522-8 -lcurl","vulnerable":false,"description":"Password read from environment variable","cwe":522,"lines":[],"id":"522-8","number":148,"hash":"7410dd7791160e10f0fe59b52575ceb4","line_count":47,"cyclomatic_complexity":6,"nloc":37,"functions":3,"halstead_volume":991.5913024080061,"maintainability_index":75.24671246513367,"cl100k_base_tokens":253,"code":"// export PASSWORD=secret123\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <curl/curl.h>\n\nint auth(){\n    char* username = \"apple\";\n    char* password = getenv(\"PASSWORD\");\n    if (password == NULL) {\n        printf(\"Failed to load password\\n\");\n        return 0;\n    }\n\n    CURL* curl = NULL;\n    CURLcode res = CURLE_OK;\n\n    curl = curl_easy_init();\n    if (curl == NULL) {\n        return 0;\n    }\n\n    char postData[256];\n    snprintf(postData, sizeof(postData), \"username=%s&password=%s\", username, password);\n\n    curl_easy_setopt(curl, CURLOPT_URL, \"https://mypage.com/login\");\n    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postData);\n    res = curl_easy_perform(curl);\n    curl_easy_cleanup(curl);\n\n    return res == CURLE_OK;\n}\n\nvoid shareSecret() {\n    printf(\"No secrets here yet\\n\"); // Will implement later\n}\n\nint main() {\n    if (auth()) {\n        printf(\"Welcome to the system\\n\");\n        shareSecret();\n    } else {\n        printf(\"Access denied\\n\");\n    }\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-522-9.c","version":1.1,"compile":"gcc CASTLE-522-9.c -o CASTLE-522-9 -lmysqlclient","vulnerable":false,"description":"MQSql Database connection parameters are loaded from environment.","cwe":522,"lines":[],"id":"522-9","number":149,"hash":"09209236a2b8af04ee3b74fbd477c933","line_count":59,"cyclomatic_complexity":11,"nloc":43,"functions":1,"halstead_volume":1616.8309274992844,"maintainability_index":69.1197969931124,"cl100k_base_tokens":394,"code":"#include <mysql/mysql.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    MYSQL *conn;\n    MYSQL_RES *res;\n    MYSQL_ROW row;\n\n    // Credentials\n    const char *server = getenv(\"DB_ADDRESS\");\n    const char *user = getenv(\"DB_USERNAME\");\n    const char *password = getenv(\"DB_PASSWORD\");\n    const char *database = getenv(\"DB_DATABASE\");\n    if (server == NULL || user == NULL || password == NULL || database == NULL) {\n        printf(\"Missing database credentials\\n\");\n        return 1;\n    }\n\n    // Initialize MySQL connection\n    conn = mysql_init(NULL);\n    if (conn == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    // Connect to database\n    if (!mysql_real_connect(conn, server, user, password, database, 0, NULL, 0)) {\n        fprintf(stderr, \"Connection failed: %s\\n\", mysql_error(conn));\n        return 1;\n    }\n\n    // Send SQL query\n    if (mysql_query(conn, \"SELECT id, token FROM tokens\")) {\n        fprintf(stderr, \"Query failed: %s\\n\", mysql_error(conn));\n        return 1;\n    }\n\n    // Store the result\n    res = mysql_store_result(conn);\n\n    // Output the result row by row\n    int num_fields = mysql_num_fields(res);\n    while ((row = mysql_fetch_row(res))) {\n        unsigned long *lengths;\n        lengths = mysql_fetch_lengths(res);\n        for(int i = 0; i < num_fields; i++) {\n            printf(\"[%.*s] \", (int) lengths[i],\n                    row[i] ? row[i] : \"NULL\");\n        }\n        printf(\"\\n\");\n    }\n\n    // Clean up\n    mysql_free_result(res);\n    mysql_close(conn);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-522-10.c","version":1.1,"compile":"gcc CASTLE-522-10.c -o CASTLE-522-10 -lsqlite3","vulnerable":false,"description":"No sensitive information is stored in the database.","cwe":522,"lines":[],"id":"522-10","number":150,"hash":"9e0eeb18634d85a8e0ec1b733412861d","line_count":69,"cyclomatic_complexity":8,"nloc":50,"functions":2,"halstead_volume":1704.565939069013,"maintainability_index":67.09168527626535,"cl100k_base_tokens":451,"code":"// create table users (username VARCHAR(32), admin INT);\n\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n#include <sqlite3.h>\n\nint isValidUsername(char *input) {\n    for (int i = 0; i < strlen(input); i++) {\n        if (!isalpha(input[i])) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    sqlite3 *db;\n    sqlite3_stmt *res;\n    int rc;\n\n    rc = sqlite3_open(\"users.db\", &db);\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"Cannot open database: %s\\n\", sqlite3_errmsg(db));\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Read user data\n    char username[32];\n    printf(\"Username: \");\n    fgets(username, sizeof(username), stdin);\n    username[strcspn(username, \"\\n\")] = '\\0'; // Remove trailing newline\n\n    if (isValidUsername(username) == 0) {\n        fprintf(stderr, \"Username or is not valid\\n\");\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Prepare an SQL query\n    const char *sql = \"INSERT INTO users (username, admin) VALUES (?, ?);\";\n\n    // Compile the SQL query\n    rc = sqlite3_prepare_v2(db, sql, -1, &res, 0);\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"Failed to prepare statement: %s\\n\", sqlite3_errmsg(db));\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Bind values\n    sqlite3_bind_text(res, 1, username, -1, SQLITE_STATIC);\n    sqlite3_bind_int(res, 2, 0);\n\n    rc = sqlite3_step(res);\n\n    if (rc != SQLITE_DONE) {\n        fprintf(stderr, \"Execution failed: %s\\n\", sqlite3_errmsg(db));\n    } else {\n        printf(\"Record inserted successfully.\\n\");\n    }\n\n    // Finalize and clean up\n    sqlite3_finalize(res);\n    sqlite3_close(db);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-617-1.c","version":1.1,"compile":"gcc CASTLE-617-1.c -o CASTLE-617-1","vulnerable":true,"description":"Assertion always reached","cwe":617,"lines":[28],"id":"617-1","number":151,"hash":"601ace146f61df081796f5fb4c20ba33","line_count":33,"cyclomatic_complexity":4,"nloc":26,"functions":4,"halstead_volume":943.6555489862831,"maintainability_index":81.68007776599737,"cl100k_base_tokens":213,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\ntypedef struct {\n    double x, y, z;\n} UnitVector;\n\nvoid correctLengths(double* x, double* y, double* z) {\n    double* s = x;\n    x = y;\n    y = z;\n    z = s;\n}\n\nUnitVector createUnitVector(double x, double y, double z) {\n    correctLengths(&x, &y, &z);\n    UnitVector uv = {x, y, z};\n    return uv;\n}\n\nint isValidUnitVector(UnitVector uv) {\n    return uv.x * uv.x + uv.y * uv.y + uv.z * uv.z == 1;\n}\n\nint main() {\n    UnitVector uv = createUnitVector(1.0, 2.0, 3.0);\n    assert(isValidUnitVector(uv));\n\n    printf(\"{%f, %f, %f}\\n\", uv.x, uv.y, uv.z);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-617-2.c","version":1.1,"compile":"gcc CASTLE-617-2.c -o CASTLE-617-2 -lm","vulnerable":true,"description":"Assertion always reached","cwe":617,"lines":[8,19],"id":"617-2","number":152,"hash":"492f4f3a31eb956f11915eb6dbc6f2e0","line_count":22,"cyclomatic_complexity":3,"nloc":17,"functions":2,"halstead_volume":464.0842589809777,"maintainability_index":92.48359995875632,"cl100k_base_tokens":124,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <math.h>\n\n\ndouble safeSqrt(double a) {\n    assert(a >= 0);\n    if (a < 0) {\n        return 0;\n    }\n    return sqrt(a);\n}\n\nint main() {\n    const double a = 3.14, b = -2.7;\n\n    printf(\"Sqrt of %f is %f\\n\", a, safeSqrt(a));\n    printf(\"Sqrt of %f is %f\\n\", b, safeSqrt(b));\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-617-3.c","version":1.1,"compile":"gcc CASTLE-617-3.c -o CASTLE-617-3","vulnerable":true,"description":"Assertion always reached","cwe":617,"lines":[7],"id":"617-3","number":153,"hash":"4241bfe90fe46333a7241064cc041088","line_count":12,"cyclomatic_complexity":1,"nloc":7,"functions":1,"halstead_volume":140.1816079436383,"maintainability_index":100,"cl100k_base_tokens":36,"code":"#include <stdio.h>\n#include <assert.h>\n\n#define true 0\n\nint main() {\n    assert(true);\n\n    printf(\"Run Completed\\n\");\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-617-4.c","version":1.1,"compile":"gcc CASTLE-617-4.c -o CASTLE-617-4","vulnerable":true,"description":"Assertion always reached","cwe":617,"lines":[12],"id":"617-4","number":154,"hash":"b732b9c481101d9c4756a51b69e1a5f4","line_count":18,"cyclomatic_complexity":3,"nloc":14,"functions":1,"halstead_volume":299.32032633211963,"maintainability_index":97.90939676785894,"cl100k_base_tokens":83,"code":"#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int i = 200;\n\n    while (i >= 0) {\n        if (i % 10 == 0) {\n            printf(\"%d\\n\", i);\n        }\n        --i;\n        assert(i >= 0);\n    }\n\n    printf(\"Final value: %d\\n\", i);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-617-5.c","version":1.1,"compile":"gcc CASTLE-617-5.c -o CASTLE-617-5","vulnerable":true,"description":"Assertion always reached","cwe":617,"lines":[8],"id":"617-5","number":155,"hash":"005040060d4bfca9c0e2487b121fc6fd","line_count":15,"cyclomatic_complexity":2,"nloc":11,"functions":1,"halstead_volume":235.02198590705459,"maintainability_index":100,"cl100k_base_tokens":68,"code":"#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    double d = 3.14;\n\n    do {\n        assert(d < 0);\n        d += 1.23;\n    } while (d < 0);\n\n    printf(\"Final value: %f\\n\", d);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-617-6.c","version":1.1,"compile":"gcc CASTLE-617-6.c -o CASTLE-617-6","vulnerable":true,"description":"Easly reachable assertion by user input","cwe":617,"lines":[10],"id":"617-6","number":156,"hash":"6ba40c7930a075a9b530ac8ca3673d2c","line_count":15,"cyclomatic_complexity":1,"nloc":11,"functions":1,"halstead_volume":323.85477931016226,"maintainability_index":100,"cl100k_base_tokens":88,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint main() {\n    int input = 0;\n    printf(\"Enter a number: \");\n    scanf(\"%9d\", &input);\n\n    assert(input % 3 != 0);\n\n    printf(\"%d / 3 = %d (remainder %d)\\n\", input, input / 3, input % 3);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-617-7.c","version":1.1,"compile":"gcc CASTLE-617-7.c -o CASTLE-617-7","vulnerable":false,"description":"Easly reachable assertion, but debug is turned off","cwe":617,"lines":[],"id":"617-7","number":157,"hash":"f39a92c2ac8f366264957a50dfcd67c7","line_count":93,"cyclomatic_complexity":13,"nloc":64,"functions":2,"halstead_volume":2545.67294211057,"maintainability_index":59.85691243047654,"cl100k_base_tokens":557,"code":"// echo \"-2\" | nc localhost 8080\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <assert.h>\n\n#define PORT 8080\n#define BUFFER_SIZE 64\n\n#define NDEBUG\n\nint isPrime(int n) {\n    assert(n >= 0);\n\n    if (n == 0 || n == 1) {\n        return 0;\n    }\n\n    for (int i = 2; i < n; i++) {\n        if (n % i == 0) {\n            return 0;\n        }\n    }\n\n    return 1;\n}\n\nint main() {\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n    char buffer[BUFFER_SIZE] = {0};\n    char response[BUFFER_SIZE] = {0};\n\n    // Create socket\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"Socket failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Bind the socket to the port\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(PORT);\n\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        perror(\"Bind failed\");\n        close(server_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    // Listen for incoming connections\n    if (listen(server_fd, 3) < 0) {\n        perror(\"Listen failed\");\n        close(server_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"Server is running on port %d\\n\", PORT);\n\n    // Accept incoming connection and handle request\n    while ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t *)&addrlen)) >= 0) {\n        int bytes_read = read(new_socket, buffer, BUFFER_SIZE - 1);\n        if (bytes_read == -1) {\n            close(new_socket);\n            continue;\n        }\n        \n        buffer[bytes_read] = '\\0';\n        printf(\"Received request: \\\"%s\\\"\\n\", buffer);\n\n        // Process input\n        int input = atoi(buffer);\n        snprintf(response, sizeof(response), isPrime(input) ? \"true\\n\" : \"false\\n\");\n        printf(\"Sending response: \\\"%s\\\"\\n\", response);\n\n        // Send response\n        write(new_socket, response, strlen(response));\n        close(new_socket);\n    }\n\n    if (new_socket < 0) {\n        perror(\"Accept failed\");\n        close(server_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-617-8.c","version":1.1,"compile":"gcc CASTLE-617-8.c -o CASTLE-617-8","vulnerable":false,"description":"Assertions never reached","cwe":617,"lines":[],"id":"617-8","number":158,"hash":"21972393542ab7cd83dd0f361b1132b3","line_count":14,"cyclomatic_complexity":1,"nloc":8,"functions":1,"halstead_volume":187.29612798276648,"maintainability_index":100,"cl100k_base_tokens":46,"code":"#include <stdio.h>\n#include <assert.h>\n\n#define true 0\n#define false 1\n\nint main() {\n    assert(!true);\n    assert(false);\n\n    printf(\"Run Completed\\n\");\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-617-9.c","version":1.1,"compile":"gcc CASTLE-617-9.c -o CASTLE-617-9","vulnerable":false,"description":"Assertions never reached","cwe":617,"lines":[],"id":"617-9","number":159,"hash":"262f52a8723642a478b58b60a8b8fc57","line_count":15,"cyclomatic_complexity":2,"nloc":11,"functions":1,"halstead_volume":222.90509710918678,"maintainability_index":100,"cl100k_base_tokens":67,"code":"#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    double d = 3.14;\n\n    while (d < 0) {\n        assert(d < 0);\n        d += 1.23;\n    }\n\n    printf(\"Final value: %f\\n\", d);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-617-10.c","version":1.1,"compile":"gcc CASTLE-617-10.c -o CASTLE-617-10 -Wno-type-limits","vulnerable":false,"description":"Assertion never reached","cwe":617,"lines":[],"id":"617-10","number":160,"hash":"88d83143828128944ba45e7079f6a57d","line_count":90,"cyclomatic_complexity":13,"nloc":65,"functions":2,"halstead_volume":2633.272809229449,"maintainability_index":59.429815846123745,"cl100k_base_tokens":559,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <assert.h>\n\n#define PORT 8080\n#define BUFFER_SIZE 64\n\nint isPrime(unsigned long n) {\n    assert(n >= 0);\n\n    if (n == 0 || n == 1) {\n        return 0;\n    }\n\n    for (unsigned long i = 2; i < n; i++) {\n        if (n % i == 0) {\n            return 0;\n        }\n    }\n\n    return 1;\n}\n\nint main() {\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n    char buffer[BUFFER_SIZE] = {0};\n    char response[BUFFER_SIZE] = {0};\n\n    // Create socket\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"Socket failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Bind the socket to the port\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(PORT);\n\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        perror(\"Bind failed\");\n        close(server_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    // Listen for incoming connections\n    if (listen(server_fd, 3) < 0) {\n        perror(\"Listen failed\");\n        close(server_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"Server is running on port %d\\n\", PORT);\n\n    // Accept incoming connection and handle request\n    while ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t *)&addrlen)) >= 0) {\n        int bytes_read = read(new_socket, buffer, BUFFER_SIZE - 1);\n        if (bytes_read == -1) {\n            close(new_socket);\n            continue;\n        }\n        \n        buffer[bytes_read] = '\\0';\n        printf(\"Received request: \\\"%s\\\"\\n\", buffer);\n\n        // Process input\n        char *endptr;\n        unsigned long input = strtoul(buffer, &endptr, 10);\n        snprintf(response, sizeof(response), isPrime(input) ? \"true\\n\" : \"false\\n\");\n        printf(\"Sending response: \\\"%s\\\"\\n\", response);\n\n        // Send response\n        write(new_socket, response, strlen(response));\n        close(new_socket);\n    }\n\n    if (new_socket < 0) {\n        perror(\"Accept failed\");\n        close(server_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-628-1.c","version":1.1,"compile":"gcc CASTLE-628-1.c -o CASTLE-628-1","vulnerable":true,"description":"write_to_file function call has semantically incorrect parameters.","cwe":628,"lines":[18],"id":"628-1","number":161,"hash":"c307039ee7227e8625a937a5616ec073","line_count":23,"cyclomatic_complexity":3,"nloc":18,"functions":2,"halstead_volume":506.8778377412035,"maintainability_index":91.09897340062575,"cl100k_base_tokens":129,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid write_to_file(const char *filename, const char *text) {\n    FILE *file = fopen(filename, \"w\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return;\n    }\n    fprintf(file, \"%s\", text);\n    fclose(file);\n}\n\nint main() {\n    const char *filename = \"output.txt\";\n    const char *text = \"Hello, this is a sample text written to the file.\";\n\n    write_to_file(text, filename);\n\n    printf(\"Text written to %s\\n\", filename);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-628-2.c","version":1.1,"compile":"gcc CASTLE-628-2.c -o CASTLE-628-2","vulnerable":true,"description":"gte function call has semantically incorrect parameters.","cwe":628,"lines":[18],"id":"628-2","number":162,"hash":"7262fba4e5028234c97986809349d612","line_count":23,"cyclomatic_complexity":5,"nloc":19,"functions":2,"halstead_volume":401.2899011413369,"maintainability_index":90.97773115719939,"cl100k_base_tokens":112,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint gte(int a, int b) {\n    if (a < b) {\n        return -1;\n    } else if (a == b) {\n        return 0;\n    } else {\n        return 1;\n    }\n}\n\nint main() {\n    const int a = 55;\n    const int b = 6;\n\n    if (gte(b, a) < 0) {\n        printf(\"A is smaller than b!\\n\");\n    }\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-628-3.c","version":1.1,"compile":"gcc CASTLE-628-3.c -o CASTLE-628-3","vulnerable":true,"description":"power_mod function call has semantically incorrect parameters.","cwe":628,"lines":[36],"id":"628-3","number":163,"hash":"ecae42c2881c18676b7c6fb9cbb54313","line_count":46,"cyclomatic_complexity":5,"nloc":34,"functions":2,"halstead_volume":1157.174769762185,"maintainability_index":76.04352829705306,"cl100k_base_tokens":357,"code":"#include <stdio.h>\n#include <math.h>\n\nlong long power_mod(long long base, long long exp, long long mod) {\n    long long result = 1;\n    base = base % mod;\n\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % mod;\n        }\n        exp = exp >> 1;\n        base = (base * base) % mod;\n    }\n    return result;\n}\n\nint main() {\n    // Settings\n    long long prime = 37199; // modulus\n    long long base = 5;   // generator\n\n    // Private keys\n    long long alice_private = 19945234904;  // Alice (secret)\n    long long bob_private = 2530476561349134275;   // Bob (secret)\n\n    long long alice_public = power_mod(base, alice_private, prime);\n    printf(\"Alice's public key: %lld\\n\", alice_public);\n\n    long long bob_public = power_mod(base, bob_private, prime);\n    printf(\"Bob's public key: %lld\\n\", bob_public);\n\n    long long alice_shared_secret = power_mod(bob_public, alice_private, prime);\n    printf(\"Alice's shared secret: %lld\\n\", alice_shared_secret);\n\n    long long bob_shared_secret = power_mod(bob_private, alice_public, prime);\n    printf(\"Bob's shared secret: %lld\\n\", bob_shared_secret);\n\n    if (alice_shared_secret == bob_shared_secret) {\n        printf(\"Key exchange successful! Shared secret: %lld\\n\", alice_shared_secret);\n    } else {\n        printf(\"Key exchange failed.\\n\");\n    }\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-628-4.c","version":1.1,"compile":"gcc CASTLE-628-4.c -o CASTLE-628-4 -lssl -lcrypto","vulnerable":true,"description":"sha256 function call has semantically incorrect parameters.","cwe":628,"lines":[10,12,58],"id":"628-4","number":164,"hash":"385c744ce47a4471dc5db7ad23c04378","line_count":63,"cyclomatic_complexity":9,"nloc":50,"functions":3,"halstead_volume":1829.9016698829112,"maintainability_index":66.4927362492095,"cl100k_base_tokens":412,"code":"#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <openssl/evp.h>\n#include <openssl/err.h>\n\n\nvoid sha256_hash_string(unsigned char hash[EVP_MAX_MD_SIZE], char outputBuffer[65], unsigned int hash_len) {\n    for (unsigned int i = 0; i < hash_len; i++) {\n        sprintf(outputBuffer + (i * 2), \"%02x\", hash[i]);\n    }\n    outputBuffer[hash_len * 2] = '\\0';\n}\n\nvoid sha256(const char *str, char outputBuffer[65]) {\n    EVP_MD_CTX *mdctx;\n    const EVP_MD *md;\n    unsigned char hash[EVP_MAX_MD_SIZE];\n    unsigned int hash_len;\n\n    md = EVP_sha256();\n    mdctx = EVP_MD_CTX_new();\n\n    if (!mdctx) {\n        printf(\"Error creating EVP_MD_CTX\\n\");\n        return;\n    }\n\n    if (1 != EVP_DigestInit_ex(mdctx, md, NULL)) {\n        printf(\"Error initializing digest\\n\");\n        EVP_MD_CTX_free(mdctx);\n        return;\n    }\n\n    if (1 != EVP_DigestUpdate(mdctx, str, strlen(str))) {\n        printf(\"Error updating digest\\n\");\n        EVP_MD_CTX_free(mdctx);\n        return;\n    }\n\n    if (1 != EVP_DigestFinal_ex(mdctx, hash, &hash_len)) {\n        printf(\"Error finalizing digest\\n\");\n        EVP_MD_CTX_free(mdctx);\n        return;\n    }\n\n    sha256_hash_string(hash, outputBuffer, hash_len);\n    EVP_MD_CTX_free(mdctx);\n}\n\nint main(int argc, char* argv[]) {\n    if (argc != 2) {\n        printf(\"Usage: %s <string_to_hash>\\n\", argv[0]);\n        return 1;\n    }\n\n    char digest[65] = {0};\n    sha256(digest, argv[1]);\n\n    printf(\"%s\\n\", digest);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-628-5.c","version":1.1,"compile":"gcc CASTLE-628-5.c -o CASTLE-628-5","vulnerable":true,"description":"url_decode function call has semantically incorrect parameters.","cwe":628,"lines":[23,27,32,36,41,48],"id":"628-5","number":165,"hash":"5e35362de135d7c413d99177590d5486","line_count":52,"cyclomatic_complexity":14,"nloc":43,"functions":3,"halstead_volume":1427.3011716877436,"maintainability_index":69.07814675851773,"cl100k_base_tokens":400,"code":"#include <stdio.h>\n#include <ctype.h>\n\nint hex_to_int(char c) {\n    if (c >= '0' && c <= '9') {\n        return c - '0';\n    } else if (c >= 'a' && c <= 'f') {\n        return c - 'a' + 10;\n    } else if (c >= 'A' && c <= 'F') {\n        return c - 'A' + 10;\n    } else {\n        return -1;\n    }\n}\n\nvoid url_decode(const char *src, char *dest) {\n    while (*src) {\n        if (*src == '%') {\n            if (isxdigit(*(src + 1)) && isxdigit(*(src + 2))) {\n                // Decode the next two characters as a hex value\n                int high = hex_to_int(*(src + 1));\n                int low = hex_to_int(*(src + 2));\n                *dest = (char)(high * 16 + low);\n                src += 3;\n            } else {\n                // Invalid encoding, copy the % as-is\n                *dest = *src;\n                src++;\n            }\n        } else if (*src == '+') {\n            // Replace '+' with space\n            *dest = ' ';\n            src++;\n        } else {\n            // Copy other characters as-is\n            *dest = *src;\n            src++;\n        }\n        dest++;\n    }\n    *dest = '\\0';\n}\n\nint main() {\n    char* url = \"http://localhost:8080/?search=%3C%3Cscript%3Escript%20%3Ealert(1)%3C/script%20%3C/script%3E%3E\";\n    char decodedUrl[1024] = {0};\n\n    url_decode(decodedUrl, url);\n\n    printf(\"Decoded URL: %s\\n\", decodedUrl);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-628-6.c","version":1.1,"compile":"gcc CASTLE-628-6.c -o CASTLE-628-6 -lcurl","vulnerable":true,"description":"httpGet function call has semantically incorrect parameters.","cwe":628,"lines":[53],"id":"628-6","number":166,"hash":"8768dd5630e69e4378e10e60005cf22f","line_count":55,"cyclomatic_complexity":8,"nloc":46,"functions":5,"halstead_volume":1645.5051418916719,"maintainability_index":68.62583537224323,"cl100k_base_tokens":359,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <curl/curl.h>\n\n// Callback function to handle the response data\nsize_t write_callback(void *ptr, size_t size, size_t nmemb, void *userdata) {\n    size_t total_size = size * nmemb;\n    char *response = (char *)malloc(total_size + 1);\n    if (response == NULL) {\n        fprintf(stderr, \"Failed to allocate memory.\\n\");\n        return 0;\n    }\n    memcpy(response, ptr, total_size);\n    response[total_size] = '\\0';\n    void (*onSuccess)(const char *) = userdata;\n    onSuccess(response);\n    free(response);\n    return total_size;\n}\n\nvoid httpGet(const char *url, void (*onSuccess)(const char *), void (*onError)(const char *)) {\n    CURL *curl;\n    CURLcode res;\n\n    curl = curl_easy_init();\n    if (curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, url);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, onSuccess);\n\n        res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            onError(curl_easy_strerror(res));\n        }\n\n        curl_easy_cleanup(curl);\n    } else {\n        onError(\"Failed to initialize CURL.\");\n    }\n}\n\nvoid onSuccess(const char *response) {\n    printf(\"Success: %s\\n\", response);\n}\n\nvoid onError(const char *error) {\n    fprintf(stderr, \"Error: %s\\n\", error);\n}\n\nint main() {\n    const char *url = \"http://example.com\";\n    httpGet(url, onError, onSuccess);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-628-7.c","version":1.1,"compile":"gcc CASTLE-628-7.c -o CASTLE-628-7","vulnerable":false,"description":"reserve2DimArrayAndFillWithRange function call has semantically correct parameters.","cwe":628,"lines":[],"id":"628-7","number":167,"hash":"209ea1139243b27f71ab7a42bae500c8","line_count":37,"cyclomatic_complexity":8,"nloc":29,"functions":2,"halstead_volume":1099.1835129132223,"maintainability_index":78.19772835884982,"cl100k_base_tokens":243,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* reserve2DimArrayAndFillWithRange(int rangeStart, int rangeEnd, int n, int m) {\n    if (rangeStart >= rangeEnd || n <= 0 || m <= 0) {\n        return NULL;\n    }\n\n    int *array = (int *)malloc(n * m * sizeof(int));\n    if (array == NULL) {\n        return NULL;\n    }\n\n    const double step = ((double)rangeEnd - (double)rangeStart) / (n * m);\n    double curr = rangeStart;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            array[i * m + j] = (int)curr;\n            curr += step;\n        }\n    }\n\n    return array;\n}\n\nint main() {\n    int n = 5;\n    int m = 7;\n    int range = 100;\n\n    int* array = reserve2DimArrayAndFillWithRange(0, range, n, m);\n\n    free(array);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-628-8.c","version":1.1,"compile":"gcc CASTLE-628-8.c -o CASTLE-628-8","vulnerable":false,"description":"url_decode function call has semantically correct parameters.","cwe":628,"lines":[],"id":"628-8","number":168,"hash":"21985f1e41b2fdbb2e99c46cf46ff327","line_count":52,"cyclomatic_complexity":14,"nloc":43,"functions":3,"halstead_volume":1409.2340682486583,"maintainability_index":69.14438969256037,"cl100k_base_tokens":396,"code":"#include <stdio.h>\n#include <ctype.h>\n\nint hex_to_int(char c) {\n    if (c >= '0' && c <= '9') {\n        return c - '0';\n    } else if (c >= 'a' && c <= 'f') {\n        return c - 'a' + 10;\n    } else if (c >= 'A' && c <= 'F') {\n        return c - 'A' + 10;\n    } else {\n        return -1;\n    }\n}\n\nvoid url_decode(const char *src, char *dest) {\n    while (*src) {\n        if (*src == '%') {\n            if (isxdigit(*(src + 1)) && isxdigit(*(src + 2))) {\n                // Decode the next two characters as a hex value\n                int high = hex_to_int(*(src + 1));\n                int low = hex_to_int(*(src + 2));\n                *dest = (char)(high * 16 + low);\n                src += 3;\n            } else {\n                // Invalid encoding, copy the % as-is\n                *dest = *src;\n                src++;\n            }\n        } else if (*src == '+') {\n            // Replace '+' with space\n            *dest = ' ';\n            src++;\n        } else {\n            // Copy other characters as-is\n            *dest = *src;\n            src++;\n        }\n        dest++;\n    }\n    *dest = '\\0';\n}\n\nint main() {\n    char* url = \"http://localhost:8080/?search=%3C%3Cscript%3Escript%20%3Ealert(1)%3C/script%20%3C/script%3E%3E\";\n    char decodedUrl[1024];\n\n    url_decode(url, decodedUrl);\n\n    printf(\"Decoded URL: %s\\n\", decodedUrl);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-628-9.c","version":1.1,"compile":"gcc CASTLE-628-9.c -o CASTLE-628-9","vulnerable":false,"description":"url_decode function call has semantically correct parameters.","cwe":628,"lines":[],"id":"628-9","number":169,"hash":"21985f1e41b2fdbb2e99c46cf46ff327","line_count":52,"cyclomatic_complexity":14,"nloc":43,"functions":3,"halstead_volume":1409.2340682486583,"maintainability_index":69.14438969256037,"cl100k_base_tokens":396,"code":"#include <stdio.h>\n#include <ctype.h>\n\nint hex_to_int(char c) {\n    if (c >= '0' && c <= '9') {\n        return c - '0';\n    } else if (c >= 'a' && c <= 'f') {\n        return c - 'a' + 10;\n    } else if (c >= 'A' && c <= 'F') {\n        return c - 'A' + 10;\n    } else {\n        return -1;\n    }\n}\n\nvoid url_decode(const char *src, char *dest) {\n    while (*src) {\n        if (*src == '%') {\n            if (isxdigit(*(src + 1)) && isxdigit(*(src + 2))) {\n                // Decode the next two characters as a hex value\n                int high = hex_to_int(*(src + 1));\n                int low = hex_to_int(*(src + 2));\n                *dest = (char)(high * 16 + low);\n                src += 3;\n            } else {\n                // Invalid encoding, copy the % as-is\n                *dest = *src;\n                src++;\n            }\n        } else if (*src == '+') {\n            // Replace '+' with space\n            *dest = ' ';\n            src++;\n        } else {\n            // Copy other characters as-is\n            *dest = *src;\n            src++;\n        }\n        dest++;\n    }\n    *dest = '\\0';\n}\n\nint main() {\n    char* url = \"http://localhost:8080/?search=%3C%3Cscript%3Escript%20%3Ealert(1)%3C/script%20%3C/script%3E%3E\";\n    char decodedUrl[1024];\n\n    url_decode(url, decodedUrl);\n\n    printf(\"Decoded URL: %s\\n\", decodedUrl);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-628-10.c","version":1.1,"compile":"gcc CASTLE-628-10.c -o CASTLE-628-10 -lssl -lcrypto","vulnerable":false,"description":"sha256 function call has semantically correct parameters.","cwe":628,"lines":[],"id":"628-10","number":170,"hash":"043ece472db066713495fa187be6c2f9","line_count":63,"cyclomatic_complexity":9,"nloc":50,"functions":3,"halstead_volume":1811.1013102608265,"maintainability_index":66.54643724281992,"cl100k_base_tokens":407,"code":"#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <openssl/evp.h>\n#include <openssl/err.h>\n\n\nvoid sha256_hash_string(unsigned char hash[EVP_MAX_MD_SIZE], char outputBuffer[65], unsigned int hash_len) {\n    for (unsigned int i = 0; i < hash_len; i++) {\n        sprintf(outputBuffer + (i * 2), \"%02x\", hash[i]);\n    }\n    outputBuffer[hash_len * 2] = '\\0';\n}\n\nvoid sha256(const char *str, char outputBuffer[65]) {\n    EVP_MD_CTX *mdctx;\n    const EVP_MD *md;\n    unsigned char hash[EVP_MAX_MD_SIZE];\n    unsigned int hash_len;\n\n    md = EVP_sha256();\n    mdctx = EVP_MD_CTX_new();\n\n    if (!mdctx) {\n        printf(\"Error creating EVP_MD_CTX\\n\");\n        return;\n    }\n\n    if (1 != EVP_DigestInit_ex(mdctx, md, NULL)) {\n        printf(\"Error initializing digest\\n\");\n        EVP_MD_CTX_free(mdctx);\n        return;\n    }\n\n    if (1 != EVP_DigestUpdate(mdctx, str, strlen(str))) {\n        printf(\"Error updating digest\\n\");\n        EVP_MD_CTX_free(mdctx);\n        return;\n    }\n\n    if (1 != EVP_DigestFinal_ex(mdctx, hash, &hash_len)) {\n        printf(\"Error finalizing digest\\n\");\n        EVP_MD_CTX_free(mdctx);\n        return;\n    }\n\n    sha256_hash_string(hash, outputBuffer, hash_len);\n    EVP_MD_CTX_free(mdctx);\n}\n\nint main(int argc, char* argv[]) {\n    if (argc != 2) {\n        printf(\"Usage: %s <string_to_hash>\\n\", argv[0]);\n        return 1;\n    }\n\n    char digest[65];\n    sha256(argv[1], digest);\n\n    printf(\"%s\\n\", digest);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-674-1.c","version":1.1,"compile":"gcc CASTLE-674-1.c -o CASTLE-674-1","vulnerable":true,"description":"Uncontrolled recursion due to faulty iteration.","cwe":674,"lines":[5],"id":"674-1","number":171,"hash":"5cf740dd18f9083771b558f063f18155","line_count":11,"cyclomatic_complexity":2,"nloc":9,"functions":2,"halstead_volume":146.94555522617034,"maintainability_index":100,"cl100k_base_tokens":42,"code":"#include <stdio.h>\n\nvoid print(int i) {\n    printf(\"i = %d\\n\", i);\n    print(i);\n}\n\nint main() {\n    print(0);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-674-2.c","version":1.1,"compile":"gcc CASTLE-674-2.c -o CASTLE-674-2","vulnerable":true,"description":"Uncontrolled recursion due to faulty iteration.","cwe":674,"lines":[9],"id":"674-2","number":172,"hash":"f6c741acb35e6bc55486b918af845edb","line_count":15,"cyclomatic_complexity":3,"nloc":12,"functions":2,"halstead_volume":197.1533875310097,"maintainability_index":100,"cl100k_base_tokens":55,"code":"#include <stdio.h>\nvoid countdown(int i) {\n    printf(\"%d...\\n\", i);\n\n    if (i == 0) {\n        return;\n    }\n\n    countdown(i--);\n}\n\nint main() {\n    countdown(5);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-674-3.c","version":1.1,"compile":"gcc CASTLE-674-3.c -o CASTLE-674-3","vulnerable":true,"description":"Uncontrolled recursion because of invalid fibonacci implementation.","cwe":674,"lines":[4,7,9],"id":"674-3","number":173,"hash":"842c18aee9cac2e3f06fd05b8e3d3091","line_count":28,"cyclomatic_complexity":5,"nloc":23,"functions":2,"halstead_volume":539.1110263239493,"maintainability_index":86.34740171757886,"cl100k_base_tokens":145,"code":"#include <stdio.h>\n\nint fibonacci(int n) {\n    if (n == 1) {\n        return 1;\n    } else {\n        return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n}\n\nint main() {\n    int n, i;\n\n    printf(\"Enter the number of terms: \");\n    scanf(\"%9d\", &n);\n    if (n <= 0) {\n        printf(\"Non-positive number\\n\");\n        return 1;\n    }\n\n    printf(\"Fibonacci Series: \");\n    for (i = 0; i < n; i++) {\n        printf(\"%d \", fibonacci(i));\n    }\n    printf(\"\\n\");\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-674-4.c","version":1.1,"compile":"gcc CASTLE-674-4.c -o CASTLE-674-4","vulnerable":true,"description":"Uncontrolled recursion because of invalid recursive iteration","cwe":674,"lines":[9,10],"id":"674-4","number":174,"hash":"4e89c6acc1887571c98b9e102f52dd37","line_count":17,"cyclomatic_complexity":3,"nloc":14,"functions":2,"halstead_volume":454.9534001269235,"maintainability_index":95.73225727893995,"cl100k_base_tokens":112,"code":"#include <stdio.h>\n\nint recursivePrintArray(int* arr, int size, int index) {\n    if (index == size) {\n        return 0;\n    }\n\n    printf(\"%d\\n\", arr[index]);\n    return recursivePrintArray(arr, size, index++);\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    int ret = recursivePrintArray(arr, 5, 0);\n    printf(\"Ret: %d\\n\", ret);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-674-5.c","version":1.1,"compile":"gcc CASTLE-674-5.c -o CASTLE-674-5","vulnerable":true,"description":"Uncontrolled recursion because of invalid recursive iteration","cwe":674,"lines":[9,10],"id":"674-5","number":175,"hash":"418939838114cdf425e29ddac2605294","line_count":17,"cyclomatic_complexity":3,"nloc":14,"functions":2,"halstead_volume":479.2697096378634,"maintainability_index":95.46150102339064,"cl100k_base_tokens":118,"code":"#include <stdio.h>\n\nint recursivePrintArray(int* arr, int size, int index) {\n    if (index == size) {\n        return 0;\n    }\n\n    printf(\"%d\\n\", arr[index]);\n    return recursivePrintArray(arr, size, (index+1) % size);\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    int ret = recursivePrintArray(arr, 5, 0);\n    printf(\"Ret: %d\\n\", ret);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-674-6.c","version":1.1,"compile":"gcc CASTLE-674-6.c -o CASTLE-674-6","vulnerable":true,"description":"Uncontrolled recursion because of invalid iteration reset.","cwe":674,"lines":[5,8,9],"id":"674-6","number":176,"hash":"94061036680df57aee1c657a63366f1d","line_count":16,"cyclomatic_complexity":3,"nloc":13,"functions":2,"halstead_volume":441.1183394572671,"maintainability_index":97.09339185809665,"cl100k_base_tokens":107,"code":"#include <stdio.h>\n\nint sumArray(int* arr, int size, int index) {\n    if (index == size) {\n        index = 0;\n    }\n\n    return arr[index] + sumArray(arr, size, index+1);\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    int sum = sumArray(arr, 5, 0);\n    printf(\"Sum: %d\\n\", sum);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-674-7.c","version":1.1,"compile":"gcc CASTLE-674-7.c -o CASTLE-674-7","vulnerable":false,"description":"No uncontrolled recursion because of valid recursive iteration","cwe":674,"lines":[],"id":"674-7","number":177,"hash":"4e8ced0bb5e129f3f8e359bfb60cc195","line_count":17,"cyclomatic_complexity":3,"nloc":14,"functions":2,"halstead_volume":454.9534001269235,"maintainability_index":95.73225727893995,"cl100k_base_tokens":113,"code":"#include <stdio.h>\n\nint recursivePrintArray(int* arr, int size, int index) {\n    if (index == size) {\n        return 0;\n    }\n\n    printf(\"%d\\n\", arr[index]);\n    return recursivePrintArray(arr, size, ++index);\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    int ret = recursivePrintArray(arr, 5, 0);\n    printf(\"Ret: %d\\n\", ret);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-674-8.c","version":1.1,"compile":"gcc CASTLE-674-8.c -o CASTLE-674-8","vulnerable":false,"description":"No uncontrolled recursion because of proper return at the end of the array.","cwe":674,"lines":[],"id":"674-8","number":178,"hash":"7350d11ab446b7e30a831a91cf7db335","line_count":16,"cyclomatic_complexity":3,"nloc":13,"functions":2,"halstead_volume":447.6967300300298,"maintainability_index":97.01641689041975,"cl100k_base_tokens":111,"code":"#include <stdio.h>\n\nint sumArray(int* arr, int size, int index) {\n    if (index == size) {\n        return 0;\n    }\n\n    return arr[index] + sumArray(arr, size, index+1);\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    sumArray(arr, 5, 0);\n    printf(\"Sum: %d\\n\", sumArray(arr, 5, 0));\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-674-9.c","version":1.1,"compile":"gcc CASTLE-674-9.c -o CASTLE-674-9","vulnerable":false,"description":"No uncontolled recursion because of failsafe","cwe":674,"lines":[],"id":"674-9","number":179,"hash":"55f1fc19f08940788c67f04383e1fd63","line_count":17,"cyclomatic_complexity":3,"nloc":13,"functions":2,"halstead_volume":289.50654514090263,"maintainability_index":99.28329530214069,"cl100k_base_tokens":85,"code":"#include <stdio.h>\n\n#define MAX_RECURSION 200\n\nvoid print(int i, int counter) {\n    printf(\"i = %d\\n\", i);\n    if (counter >= MAX_RECURSION) {\n        perror(\"Recursion limit reached\");\n        return;\n    }\n    print(i, counter + 1);\n}\n\nint main() {\n    print(0, 0);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-674-10.c","version":1.1,"compile":"gcc CASTLE-674-10.c -o CASTLE-674-10","vulnerable":false,"description":"Correct fibonacci implementation does not lead to uncontrolled recursion.","cwe":674,"lines":[],"id":"674-10","number":180,"hash":"f57d2221fa8e08b1f065922e444f0a73","line_count":31,"cyclomatic_complexity":6,"nloc":26,"functions":2,"halstead_volume":591.9650485125719,"maintainability_index":83.64490859802677,"cl100k_base_tokens":163,"code":"#include <stdio.h>\n\nint fibonacci(int n) {\n    if (n == 1) {\n        return 0;\n    } else\n    if (n == 2) {\n        return 1;\n    } else {\n        return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n}\n\nint main() {\n    int n, i;\n\n    printf(\"Enter the number of terms: \");\n    scanf(\"%9d\", &n);\n    if (n <= 0) {\n        printf(\"Non-positive number\\n\");\n        return 1;\n    }\n\n    printf(\"Fibonacci Series: \");\n    for (i = 0; i < n; i++) {\n        printf(\"%d \", fibonacci(i));\n    }\n    printf(\"\\n\");\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-761-1.c","version":1.1,"compile":"gcc CASTLE-761-1.c -o CASTLE-761-1","vulnerable":true,"description":"String search buffer stepping causes free function to be called on non-buffer start pointer.","cwe":761,"lines":[15,19,22],"id":"761-1","number":181,"hash":"1b23d8b974ce6b6e5cd8f6f0d184de7b","line_count":37,"cyclomatic_complexity":6,"nloc":32,"functions":2,"halstead_volume":848.9143001096157,"maintainability_index":78.4064955315303,"cl100k_base_tokens":216,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint contains_char(char c, const char *target){\n    char *str;\n    str = (char*)malloc((strlen(target) + 1) * sizeof(char));\n    if (str == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        exit(1); // Indicate error and exit\n    }\n    strcpy(str, target);\n    while (*str != 0) {\n        if( *str == c ){\n            free(str);\n            return 1;\n        }\n\n        str = str + 1;\n    }\n\n    free(str);\n    return 0;\n}\n\nint main() {\n    char search = 'a';\n    char *text = \"banana\";\n\n    if (contains_char(search, text)) {\n        printf(\"'%s' contains '%c' character.\\n\", text, search);\n    }\n    else {\n        printf(\"'%s' does not contain '%c' character.\\n\", text, search);\n    }\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-761-2.c","version":1.1,"compile":"gcc CASTLE-761-2.c -o CASTLE-761-2","vulnerable":true,"description":"Buffer pointer operation causes free function to be called on non-buffer start pointer.","cwe":761,"lines":[12],"id":"761-2","number":182,"hash":"2b7dd7128c39854f0d58915fb5875a51","line_count":14,"cyclomatic_complexity":2,"nloc":12,"functions":1,"halstead_volume":274.78587335407707,"maintainability_index":100,"cl100k_base_tokens":74,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *buf = (int*)malloc(8 * sizeof(int));\n    if (buf == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    buf++;\n    free(buf);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-761-3.c","version":1.1,"compile":"gcc CASTLE-761-3.c -o CASTLE-761-3","vulnerable":true,"description":"Stepping by another pointer causes free function to be called on non-buffer start pointer","cwe":761,"lines":[23],"id":"761-3","number":183,"hash":"baaa6e29f4a2ce76bed1a6f5741e5120","line_count":26,"cyclomatic_complexity":5,"nloc":21,"functions":1,"halstead_volume":641.6857733106725,"maintainability_index":86.91542309104821,"cl100k_base_tokens":158,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int* a = (int*)malloc(sizeof(int) * 10);\n    if (a == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    for (int i = 0; i < 10; ++i) {\n        a[i] = i * 8 - 6;\n    }\n\n    int** p = &a;\n    for (int i = 0; i < 10; ++i) {\n        printf(\"%d\\n\", **p);\n        if (i < 9) {\n            ++(*p);\n        }\n    }\n\n    free(a);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-761-4.c","version":1.1,"compile":"gcc CASTLE-761-4.c -o CASTLE-761-4","vulnerable":true,"description":"Swapping pointers causes free function to be called on non-buffer start pointer","cwe":761,"lines":[30],"id":"761-4","number":184,"hash":"db71af048a3a2649c1f3ae9b9ad1f46f","line_count":33,"cyclomatic_complexity":6,"nloc":27,"functions":2,"halstead_volume":840.2535237384402,"maintainability_index":81.2121837372998,"cl100k_base_tokens":197,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid f(int** a, int**b) {\n    int* temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int* a = (int*)malloc(sizeof(int) * 10);\n    if (a == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    for (int i = 0; i < 10; ++i) {\n        a[i] = i * 6 + 5;\n    }\n\n    int* b = a;\n    for (int i = 0; i < 10; ++i) {\n        printf(\"%d\\n\", *b);\n        if (i < 9) {\n            ++b;\n        }\n    }\n\n    f(&a, &b);\n    free(a);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-761-5.c","version":1.1,"compile":"gcc CASTLE-761-5.c -o CASTLE-761-5","vulnerable":true,"description":"Buffer pointer operation causes free function to be called on non-buffer start pointer","cwe":761,"lines":[18],"id":"761-5","number":185,"hash":"ef75c0c3d16f5bcb40753567170b10de","line_count":21,"cyclomatic_complexity":2,"nloc":14,"functions":1,"halstead_volume":450.034368387919,"maintainability_index":96.01878669920723,"cl100k_base_tokens":117,"code":"#include <stdio.h>\n#include <stdlib.h>\n\n#define GET_ADDRESS(p) (ulli)(p++)\n\ntypedef unsigned long long int ulli;\n\nint main() {\n    int* a = (int*)malloc(sizeof(int) * 10);\n    if (a == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    const ulli address = GET_ADDRESS(a);\n    printf(\"The address is 0x%llx\\n\", address);\n\n    free(a);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-761-6.c","version":1.1,"compile":"gcc CASTLE-761-6.c -o CASTLE-761-6","vulnerable":true,"description":"Conditional, but always true buffer pointer operation causes free function to be called on non-buffer start pointer","cwe":761,"lines":[15,18],"id":"761-6","number":186,"hash":"4073f35688c85227b7e5c71c4988cc7a","line_count":21,"cyclomatic_complexity":2,"nloc":14,"functions":1,"halstead_volume":510.74233795865973,"maintainability_index":95.36077205364646,"cl100k_base_tokens":127,"code":"#include <stdio.h>\n#include <stdlib.h>\n\n#define GET_ADDRESS(p) (ulli)(((ulli)p % 2) ? p : p++)\n\ntypedef unsigned long long int ulli;\n\nint main() {\n    int* a = (int*)malloc(sizeof(int) * 10);\n    if (a == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    const ulli address = GET_ADDRESS(a);\n    printf(\"The address is 0x%llx\\n\", address);\n\n    free(a);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-761-7.c","version":1.1,"compile":"gcc CASTLE-761-7.c -o CASTLE-761-7","vulnerable":false,"description":"String search buffer stepping does not cause free function to be called on non-buffer start pointer.","cwe":761,"lines":[],"id":"761-7","number":187,"hash":"4e425824b455d54f42f89bfa089b9273","line_count":40,"cyclomatic_complexity":6,"nloc":33,"functions":2,"halstead_volume":887.124155370203,"maintainability_index":77.67905579155938,"cl100k_base_tokens":222,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n\nint contains_char(char c, const char *target){\n    char *str;\n    str = (char*)malloc((strlen(target) + 1) * sizeof(char));\n    if (str == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        exit(1);\n    }\n\n    char *str_copy = str;\n    strcpy(str_copy, target);\n    while (*str_copy != 0) {\n        if( *str_copy == c ){\n            free(str);\n            return 1;\n        }\n\n        str_copy = str_copy + 1;\n    }\n\n    free(str);\n    return 0;\n}\n\nint main() {\n    char search = 'a';\n    char *text = \"banana\";\n\n    if (contains_char(search, text)) {\n        printf(\"'%s' contains '%c' character.\\n\", text, search);\n    }\n    else {\n        printf(\"'%s' does not contain '%c' character.\\n\", text, search);\n    }\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-761-8.c","version":1.1,"compile":"gcc CASTLE-761-8.c -o CASTLE-761-8","vulnerable":false,"description":"The pointer at the start of the buffer is freed correctly","cwe":761,"lines":[],"id":"761-8","number":188,"hash":"e6457c84e372e1cf23282dab141f2178","line_count":33,"cyclomatic_complexity":6,"nloc":27,"functions":2,"halstead_volume":840.2535237384402,"maintainability_index":81.2121837372998,"cl100k_base_tokens":197,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid f(int** a, int**b) {\n    int* temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int* a = (int*)malloc(sizeof(int) * 10);\n    if (a == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    for (int i = 0; i < 10; ++i) {\n        a[i] = i * 6 + 5;\n    }\n\n    int* b = a;\n    for (int i = 0; i < 10; ++i) {\n        printf(\"%d\\n\", *b);\n        if (i < 9) {\n            ++b;\n        }\n    }\n\n    f(&a, &b);\n    free(b);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-761-9.c","version":1.1,"compile":"gcc CASTLE-761-9.c -o CASTLE-761-9","vulnerable":false,"description":"Not swapping the pointers does not cause the free function to be called on non-buffer start pointer","cwe":761,"lines":[],"id":"761-9","number":189,"hash":"6a8f59ea6ce61fe068ba0128e62f0989","line_count":33,"cyclomatic_complexity":6,"nloc":26,"functions":2,"halstead_volume":791.6175847024081,"maintainability_index":82.1336282604903,"cl100k_base_tokens":198,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid f(int** a, int**b) {\n    int* temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int* a = (int*)malloc(sizeof(int) * 10);\n    if (a == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    for (int i = 0; i < 10; ++i) {\n        a[i] = i * 6 + 5;\n    }\n\n    int* b = a;\n    for (int i = 0; i < 10; ++i) {\n        printf(\"%d\\n\", *b);\n        if (i < 9) {\n            ++b;\n        }\n    }\n\n    // f(&a, &b);\n    free(a);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-761-10.c","version":1.1,"compile":"gcc CASTLE-761-10.c -o CASTLE-761-10","vulnerable":false,"description":"Buffer pointer operation does not cause the free function to be called on non-buffer start pointer.","cwe":761,"lines":[],"id":"761-10","number":190,"hash":"061d2c3d04372966f5b6ac746b5dda9d","line_count":21,"cyclomatic_complexity":2,"nloc":14,"functions":1,"halstead_volume":441.7200318756511,"maintainability_index":96.11575465965703,"cl100k_base_tokens":109,"code":"#include <stdio.h>\n#include <stdlib.h>\n\n#define GET_ADDRESS(p) (ulli)(p)\n\ntypedef unsigned long long int ulli;\n\nint main() {\n    int* a = (int*)malloc(sizeof(int) * 10);\n    if (a == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1;\n    }\n\n    const ulli address = GET_ADDRESS(a);\n    printf(\"The address is 0x%llx\\n\", address);\n\n    free(a);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-770-1.c","version":1.1,"compile":"gcc CASTLE-770-1.c -o CASTLE-770-1","vulnerable":true,"description":"Server allocates process resources without limiting concurrent connections.","cwe":770,"lines":[68],"id":"770-1","number":191,"hash":"f0b9a983c2c428af080555f47e40dc00","line_count":87,"cyclomatic_complexity":10,"nloc":63,"functions":2,"halstead_volume":2309.3409324441827,"maintainability_index":61.30868668113784,"cl100k_base_tokens":563,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <arpa/inet.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n\n#define PORT 8080\n#define BUFFER_SIZE 1024\n\nvoid handle_client(int client_sock) {\n    char buffer[BUFFER_SIZE];\n    int bytes_read;\n\n    while ((bytes_read = read(client_sock, buffer, BUFFER_SIZE - 1)) > 0) {\n        buffer[bytes_read] = '\\0'; // Null-terminate the received data\n        printf(\"Received: %s\\n\", buffer);\n        write(client_sock, buffer, bytes_read); // Echo data\n    }\n\n    close(client_sock);\n    exit(0); // Exit child process\n}\n\nint main() {\n    int server_sock, client_sock;\n    struct sockaddr_in server_addr, client_addr;\n    socklen_t addr_len = sizeof(client_addr);\n    pid_t pid;\n\n    // Create socket\n    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1) {\n        perror(\"Could not create socket\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Set up server address\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_addr.s_addr = INADDR_ANY;\n    server_addr.sin_port = htons(PORT);\n\n    // Bind socket to address\n    if (bind(server_sock, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {\n        perror(\"Could not bind socket to address\");\n        close(server_sock);\n        exit(EXIT_FAILURE);\n    }\n\n    // Listen for connections\n    if (listen(server_sock, 5) == -1) {\n        perror(\"Could not open port\");\n        close(server_sock);\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"Server listening on port %d...\\n\", PORT);\n\n    while (1) {\n        // Accept a connection\n        if ((client_sock = accept(server_sock, (struct sockaddr *)&client_addr, &addr_len)) == -1) {\n            perror(\"accept\");\n            continue;\n        }\n\n        // Fork a new process to handle the client\n        if ((pid = fork()) == -1) {\n            perror(\"fork\");\n            close(client_sock);\n            continue;\n        }\n\n        if (pid == 0) {\n            // Child process\n            close(server_sock); // Close the listening socket in the child process\n            handle_client(client_sock);\n        } else {\n            // Parent process\n            close(client_sock); // Close the connected socket in the parent process\n            waitpid(-1, NULL, WNOHANG); // Reap zombie processes\n        }\n    }\n\n    close(server_sock);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-770-2.c","version":1.1,"compile":"gcc CASTLE-770-2.c -o CASTLE-770-2","vulnerable":true,"description":"Network write to file without limits or throttling.","cwe":770,"lines":[30,37],"id":"770-2","number":192,"hash":"4d29b617cf9dff01bf34265adcd756de","line_count":93,"cyclomatic_complexity":13,"nloc":61,"functions":3,"halstead_volume":2363.665076376887,"maintainability_index":61.020406202879585,"cl100k_base_tokens":594,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <fcntl.h>\n\n#define PORT 12345\n#define BUFFER_SIZE 2048\n#define FILE_PATH \"output.txt\"\n\nvoid handle_error(const char *msg) {\n    perror(msg);\n    exit(EXIT_FAILURE);\n}\n\nvoid handle_client(int client_socket) {\n    int file_fd;\n    char buffer[BUFFER_SIZE] = {0};\n    ssize_t bytes_read;\n\n    // Open file for appending\n    if ((file_fd = open(FILE_PATH, O_WRONLY | O_APPEND | O_CREAT, 0644)) < 0) {\n        handle_error(\"file open\");\n    }\n\n    // Read data from the socket and append to the file\n    while ((bytes_read = read(client_socket, buffer, BUFFER_SIZE)) > 0) {\n        if (write(file_fd, buffer, bytes_read) != bytes_read) {\n            handle_error(\"file write\");\n        }\n        memset(buffer, 0, BUFFER_SIZE);\n    }\n\n    // Close file descriptor and client socket\n    close(file_fd);\n    close(client_socket);\n}\n\nint main() {\n    int server_fd, client_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n    pid_t pid;\n\n    // Create socket\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        handle_error(\"socket failed\");\n    }\n\n    // Define the address and port to bind\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(PORT);\n\n    // Bind the socket\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        handle_error(\"bind failed\");\n    }\n\n    // Listen for incoming connections\n    if (listen(server_fd, 3) < 0) {\n        handle_error(\"listen\");\n    }\n\n    printf(\"Server listening on port %d\\n\", PORT);\n\n    while (1) {\n        // Accept a connection\n        if ((client_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {\n            handle_error(\"accept\");\n        }\n\n        // Fork a new process to handle the client\n        if ((pid = fork()) == 0) {\n            // In child process\n            close(server_fd); // Child doesn't need the server socket\n            handle_client(client_socket);\n            exit(EXIT_SUCCESS);\n        } else if (pid < 0) {\n            handle_error(\"fork\");\n        }\n\n        // In parent process\n        close(client_socket); // Parent doesn't need the client socket\n    }\n\n    // Close the server socket (this will never be reached in this example)\n    close(server_fd);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-770-3.c","version":1.1,"compile":"gcc CASTLE-770-3.c -o CASTLE-770-3","vulnerable":true,"description":"Program allocates memory without properly limiting size","cwe":770,"lines":[26],"id":"770-3","number":193,"hash":"a9260b807d5445353197ffd18436add7","line_count":73,"cyclomatic_complexity":19,"nloc":58,"functions":3,"halstead_volume":2124.374112135684,"maintainability_index":61.01241421610189,"cl100k_base_tokens":458,"code":"#include <stdio.h>\n#include <stdlib.h>\n\n#define ROUND_LIMIT 1000000\n\nchar base64char(int i) {\n    if (i >= 0 && i < 26) {\n        return 'A' + i;\n    } else if (i >= 26 && i < 52) {\n        return 'a' + i - 26;\n    } else if (i >= 52 && i < 62) {\n        return '0' + i - 52;\n    } else if (i == 62) {\n        return '+';\n    } else if (i == 63) {\n        return '/';\n    }\n    return '\\0';\n}\n\nchar* createRandChars(unsigned int n, int* seed) {\n    if (n == 0xFFFFFFFF) {\n        return NULL;\n    }\n    \n    char* buffer = (char*)malloc(n + 1);\n    if (buffer == NULL) {\n        return NULL;\n    }\n\n    int rand = *seed;\n    for (unsigned int i = 0; i < n; ++i) {\n        rand = (rand * 89 + 101) % 64;\n        buffer[i] = base64char(rand);\n    }\n    buffer[n] = '\\0';\n    *seed = rand;\n\n    return buffer;\n}\n\nint main () {\n    char** buffers = (char**)malloc(sizeof(char*) * ROUND_LIMIT);\n    if (buffers == NULL) {\n        exit(1);\n    }\n    \n    int bufferInd = 0;\n    int seed = 31;\n    unsigned int input = 0;\n\n    scanf(\"%9u\", &input);\n    while (input != 0 && bufferInd < ROUND_LIMIT) {\n        char* randChars = createRandChars(input, &seed);\n        if (randChars == NULL) {\n            break;\n        }\n\n        buffers[bufferInd] = randChars;\n        printf(\"%s\\n\", buffers[bufferInd++]);\n\n        scanf(\"%9u\", &input);\n    }\n\n    for (int i = 0; i < bufferInd; ++i) {\n        free(buffers[i]);\n    }\n    free(buffers);\n\n    printf(\"Run ended\\n\");\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-770-4.c","version":1.1,"compile":"gcc CASTLE-770-4.c -o CASTLE-770-4","vulnerable":true,"description":"Unlimited incrementation of buffer size may cause memory exhaustion.","cwe":770,"lines":[34],"id":"770-4","number":194,"hash":"33c32883e0b839e1b7b168cd42441f96","line_count":48,"cyclomatic_complexity":8,"nloc":43,"functions":1,"halstead_volume":1105.9368932800262,"maintainability_index":71.78462789169072,"cl100k_base_tokens":295,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    char *input = malloc(2);\n    if (input == NULL) {\n        printf(\"Memory allocation failed\\n\");\n        return 1;\n    }\n\n    size_t allocated_size = 1;\n    char c;\n    size_t i = 0;\n\n    printf(\"Enter text (type 'exit' to quit): \");\n\n    while (1) {\n        int read_val = getchar();\n        c = (char)read_val;\n        if (c == '\\n' || read_val == EOF) {\n            input[i] = '\\0';\n            if (strcmp(input, \"exit\") == 0) {\n                break;\n            }\n            printf(\"You entered: %s\\n\", input);\n            i = 0;\n            printf(\"Enter more text (type 'exit' to quit): \");\n        } else {\n            input[i] = c;\n            i++;\n            if (i >= allocated_size) {\n                allocated_size *= 2;\n                char *new_input = realloc(input, allocated_size);\n                printf(\"Resized buffer to %zu bytes\\n\", allocated_size);\n                if (new_input == NULL) {\n                    printf(\"Memory allocation failed\\n\");\n                    return 1;\n                }\n                input = new_input;\n            }\n        }\n    }\n\n    free(input);\n    printf(\"Exiting the program...\\n\");\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-770-5.c","version":1.1,"compile":"gcc CASTLE-770-5.c -o CASTLE-770-5","vulnerable":true,"description":"Unlimited forking during connection handling may cause memory exhaustion.","cwe":770,"lines":[26],"id":"770-5","number":195,"hash":"c62a83861e2aa947a1524046291d6e04","line_count":43,"cyclomatic_complexity":6,"nloc":36,"functions":1,"halstead_volume":941.6226067672682,"maintainability_index":75.9594494613818,"cl100k_base_tokens":208,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n\nint main() {\n    int server_socket = socket(AF_INET, SOCK_STREAM, 0);\n    if (server_socket < 0) {\n        perror(\"Socket creation failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    while (1) {\n        int client_socket = accept(server_socket, NULL, NULL);\n        if (client_socket < 0) {\n            perror(\"Accept failed\");\n            continue;\n        }\n\n        printf(\"A connection has been accepted\\n\");\n\n        pid_t pid = fork();\n        if (pid < 0) {\n            perror(\"Fork failed\");\n            close(client_socket);\n            continue;\n        }\n\n        if (pid == 0) {\n            close(client_socket);\n            exit(0);\n        } else {\n            close(client_socket);\n        }\n    }\n\n    close(server_socket);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-770-6.c","version":1.1,"compile":"gcc CASTLE-770-6.c -o CASTLE-770-6","vulnerable":true,"description":"Unlimited forking during connection handling may cause memory exhaustion.","cwe":770,"lines":[31],"id":"770-6","number":196,"hash":"a80b5e9cefc15aad2afc6b6b109ceff4","line_count":45,"cyclomatic_complexity":6,"nloc":36,"functions":2,"halstead_volume":1116.40232257001,"maintainability_index":75.07408697024569,"cl100k_base_tokens":244,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n#define BUFFER_SIZE 1024*1024\n\nchar* allocateBufferForClient() {\n    return (char*)malloc(BUFFER_SIZE);\n}\n\nint main() {\n    int server_socket = socket(AF_INET, SOCK_STREAM, 0);\n    if (server_socket < 0) {\n        perror(\"Socket creation failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    while (1) {\n        int client_socket = accept(server_socket, NULL, NULL);\n        if (client_socket < 0) {\n            perror(\"Accept failed\");\n            continue;\n        }\n\n        printf(\"A connection has been accepted\\n\");\n\n        char* buffer = allocateBufferForClient();\n        if (buffer == NULL) {\n            perror(\"Memory allocation failed\");\n            close(client_socket);\n            continue;\n        }\n\n        ssize_t received_bytes = recv(client_socket, buffer, BUFFER_SIZE, 0);\n        close(client_socket);\n        printf(\"Received %ld bytes\\n\", received_bytes);\n    }\n\n    close(server_socket);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-770-7.c","version":1.1,"compile":"gcc CASTLE-770-7.c -o CASTLE-770-7","vulnerable":false,"description":"Unlimited incrementation of buffer is avoided due to buffer size limit","cwe":770,"lines":[],"id":"770-7","number":197,"hash":"e67e9d63b6bb8f0cd842899d56760b75","line_count":54,"cyclomatic_complexity":9,"nloc":47,"functions":1,"halstead_volume":1231.3196642409828,"maintainability_index":69.55523164320157,"cl100k_base_tokens":331,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_BUFFER_SIZE 1024*1024\n\nint main() {\n    char *input = malloc(2);\n    if (input == NULL) {\n        printf(\"Memory allocation failed\\n\");\n        return 1;\n    }\n\n    size_t allocated_size = 1;\n    char c;\n    size_t i = 0;\n\n    printf(\"Enter text (type 'exit' to quit): \");\n\n    while (1) {\n        int read_val = getchar();\n        c = (char)read_val;\n        if (c == '\\n' || read_val == EOF) {\n            input[i] = '\\0';\n            if (strcmp(input, \"exit\") == 0) {\n                break;\n            }\n            printf(\"You entered: %s\\n\", input);\n            i = 0;\n            printf(\"Enter more text (type 'exit' to quit): \");\n        } else {\n            input[i] = c;\n            i++;\n            if (i >= allocated_size) {\n                if (allocated_size >= MAX_BUFFER_SIZE) {\n                    printf(\"Buffer size limit reached\\n\");\n                    break;\n                }\n                allocated_size *= 2;\n                char *new_input = realloc(input, allocated_size);\n                printf(\"Resized buffer to %zu bytes\\n\", allocated_size);\n                if (new_input == NULL) {\n                    printf(\"Memory allocation failed\\n\");\n                    return 1;\n                }\n                input = new_input;\n            }\n        }\n    }\n\n    free(input);\n    printf(\"Exiting the program...\\n\");\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-770-8.c","version":1.1,"compile":"gcc CASTLE-770-8.c -o CASTLE-770-8","vulnerable":false,"description":"The server limits the concurrently available processes.","cwe":770,"lines":[],"id":"770-8","number":198,"hash":"101da83b7ae29a9f15d493ecdfafd457","line_count":112,"cyclomatic_complexity":13,"nloc":81,"functions":3,"halstead_volume":3062.2603541244193,"maintainability_index":55.07999897390776,"cl100k_base_tokens":755,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <arpa/inet.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n\n#define PORT 8080\n#define BUFFER_SIZE 1024\n#define MAX_WORKERS 5\n\nint active_workers = 0;\n\nvoid handle_client(int client_sock) {\n    char buffer[BUFFER_SIZE];\n    int bytes_read;\n\n    while ((bytes_read = read(client_sock, buffer, BUFFER_SIZE - 1)) > 0) {\n        buffer[bytes_read] = '\\0'; // Null-terminate the received data\n        printf(\"Received: %s\\n\", buffer);\n        write(client_sock, buffer, bytes_read); // Echo back the received data\n    }\n\n    close(client_sock);\n    exit(0); // Exit the child process\n}\n\nvoid sigchld_handler(int signo) {\n    // Clean up zombie processes and update active_workers count\n    while (waitpid(-1, NULL, WNOHANG) > 0) {\n        active_workers--;\n    }\n}\n\nint main() {\n    int server_sock, client_sock;\n    struct sockaddr_in server_addr, client_addr;\n    socklen_t addr_len = sizeof(client_addr);\n    pid_t pid;\n\n    // Set up signal handler for SIGCHLD\n    struct sigaction sa;\n    sa.sa_handler = sigchld_handler;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = SA_RESTART | SA_NOCLDSTOP;\n    sigaction(SIGCHLD, &sa, NULL);\n\n    // Create socket\n    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1) {\n        perror(\"Could not create socket\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Set up server address\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_addr.s_addr = INADDR_ANY;\n    server_addr.sin_port = htons(PORT);\n\n    // Bind socket to address\n    if (bind(server_sock, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {\n        perror(\"Could not bind socket to address\");\n        close(server_sock);\n        exit(EXIT_FAILURE);\n    }\n\n    // Listen for connections\n    if (listen(server_sock, 5) == -1) {\n        perror(\"Could not open port\");\n        close(server_sock);\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"Server listening on port %d...\\n\", PORT);\n\n    while (1) {\n        // Accept a connection\n        if ((client_sock = accept(server_sock, (struct sockaddr *)&client_addr, &addr_len)) == -1) {\n            perror(\"accept\");\n            continue;\n        }\n\n        // Fork a new process to handle the client if we have not reached the max number of workers\n        if (active_workers < MAX_WORKERS) {\n            if ((pid = fork()) == -1) {\n                perror(\"Could not create child process\");\n                close(client_sock);\n                continue;\n            }\n\n            if (pid == 0) {\n                // Child process\n                close(server_sock); // Close the listening socket in the child process\n                handle_client(client_sock);\n            } else {\n                // Parent process\n                close(client_sock); // Close the connected socket in the parent process\n                active_workers++;\n            }\n        } else {\n            // Too many connections, reject the new connection\n            const char *message = \"Server busy, please try again later.\";\n            write(client_sock, message, strlen(message));\n            close(client_sock);\n        }\n    }\n\n    close(server_sock);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-770-9.c","version":1.1,"compile":"gcc CASTLE-770-9.c -o CASTLE-770-9","vulnerable":false,"description":"Program allocates memory with propper limits","cwe":770,"lines":[],"id":"770-9","number":199,"hash":"f86d1119fa9d27a7a13ac4fc43f943a5","line_count":56,"cyclomatic_complexity":15,"nloc":45,"functions":3,"halstead_volume":1685.7655794469283,"maintainability_index":67.24619720073177,"cl100k_base_tokens":375,"code":"#include <stdio.h>\n#include <stdlib.h>\n\n#define LENGTH_LIMIT 100\n\nchar base64char(int i) {\n    if (i >= 0 && i < 26) {\n        return 'A' + i;\n    } else if (i >= 26 && i < 52) {\n        return 'a' + i - 26;\n    } else if (i >= 52 && i < 62) {\n        return '0' + i - 52;\n    } else if (i == 62) {\n        return '+';\n    } else if (i == 63) {\n        return '/';\n    }\n    return '\\0';\n}\n\nchar* createRandChars(unsigned int desiredN, int* seed) {\n    unsigned int n = (LENGTH_LIMIT < desiredN) ? LENGTH_LIMIT : desiredN;\n    char* buffer = (char*)malloc(n + 1);\n    if (buffer == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        exit(1); // Indicate error and exit\n    }\n\n    int rand = *seed;\n    for (unsigned int i = 0; i < n; ++i) {\n        rand = (rand * 89 + 101) % 64;\n        buffer[i] = base64char(rand);\n    }\n    buffer[n] = '\\0';\n    *seed = rand;\n\n    return buffer;\n}\n\nint main () {\n    int seed = 31;\n    unsigned int input = 0;\n\n    scanf(\"%9u\", &input);\n    while (input != 0) {\n        char* buffer = createRandChars(input, &seed);\n        printf(\"%s\\n\", buffer);\n        free(buffer);\n\n        scanf(\"%9u\", &input);\n    }\n\n    printf(\"Run ended\\n\");\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-770-10.c","version":1.1,"compile":"gcc CASTLE-770-10.c -o CASTLE-770-10","vulnerable":false,"description":"Memory is freed after it is allocated for a client buffer","cwe":770,"lines":[],"id":"770-10","number":200,"hash":"2bebd072694ee3acd9552a5c2561df01","line_count":46,"cyclomatic_complexity":6,"nloc":37,"functions":2,"halstead_volume":1144.632306149637,"maintainability_index":74.50036839620691,"cl100k_base_tokens":248,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n#define BUFFER_SIZE 1024*1024\n\nchar* allocateBufferForClient() {\n    return (char*)malloc(BUFFER_SIZE);\n}\n\nint main() {\n    int server_socket = socket(AF_INET, SOCK_STREAM, 0);\n    if (server_socket < 0) {\n        perror(\"Socket creation failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    while (1) {\n        int client_socket = accept(server_socket, NULL, NULL);\n        if (client_socket < 0) {\n            perror(\"Accept failed\");\n            continue;\n        }\n\n        printf(\"A connection has been accepted\\n\");\n\n        char* buffer = allocateBufferForClient();\n        if (buffer == NULL) {\n            perror(\"Memory allocation failed\");\n            close(client_socket);\n            continue;\n        }\n\n        ssize_t received_bytes = recv(client_socket, buffer, BUFFER_SIZE, 0);\n        close(client_socket);\n        printf(\"Received %ld bytes\\n\", received_bytes);\n        free(buffer);\n    }\n\n    close(server_socket);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-787-1.c","version":1.1,"compile":"gcc CASTLE-787-1.c -o CASTLE-787-1","vulnerable":true,"description":"Buffer overflow in scanf function.","cwe":787,"lines":[7],"id":"787-1","number":201,"hash":"9786009e6d1d87ed59b7036e6a7541bd","line_count":10,"cyclomatic_complexity":1,"nloc":9,"functions":1,"halstead_volume":213.75116378561316,"maintainability_index":100,"cl100k_base_tokens":56,"code":"#include <stdio.h>\n\nint main( int argc, char *argv[])\n{\n    char reg_name[12];\n    printf(\"Enter your username:\");\n    scanf(\"%s\", reg_name);\n    printf(\"Hello %s.\\n\",reg_name);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-787-2.c","version":1.1,"compile":"gcc CASTLE-787-2.c -o CASTLE-787-2","vulnerable":true,"description":"Buffer overflow in strcpy function.","cwe":787,"lines":[7],"id":"787-2","number":202,"hash":"1fb507b286df5339adb8dee5ce6e9af1","line_count":11,"cyclomatic_complexity":1,"nloc":9,"functions":1,"halstead_volume":228.3251067709959,"maintainability_index":100,"cl100k_base_tokens":58,"code":"#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char *argv[])\n{\n    char username[10];\n    strcpy(username,\"Is_this_too_long_for_this_array_buffer?\");\n    printf(\"Hello  %s!\\n\", username);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-787-3.c","version":1.1,"compile":"gcc CASTLE-787-3.c -o CASTLE-787-3","vulnerable":true,"description":"Buffer overflow in strcpy function.","cwe":787,"lines":[18],"id":"787-3","number":203,"hash":"abcbc9d70a7c4d64b58eada158139239","line_count":23,"cyclomatic_complexity":6,"nloc":21,"functions":2,"halstead_volume":595.159243476212,"maintainability_index":87.0768256785544,"cl100k_base_tokens":126,"code":"#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid test()\n{\n    printf(\"Test function\\n\");\n}\n\nint main( int argc, char *argv[])\n{\n    if (argc>=2 && argc<=5)\n    {\n        for(int i=0;i<10000;i++){}; // do nothing\n        char *user = getenv(\"USER\");\n        if (user==NULL) return 0;\n        char OSusername[10];\n        strcpy(OSusername,user);\n        printf(\"Hello  %s!\\n\", OSusername);\n        test();\n    }\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-787-4.c","version":1.1,"compile":"gcc CASTLE-787-4.c -o CASTLE-787-4","vulnerable":true,"description":"Buffer overflow in scanf, fscanf and gets functions.","cwe":787,"lines":[14],"id":"787-4","number":204,"hash":"e5caa85c19cf96f4eac346fd1289e1e8","line_count":23,"cyclomatic_complexity":3,"nloc":20,"functions":1,"halstead_volume":681.3654250879811,"maintainability_index":87.85382360109891,"cl100k_base_tokens":183,"code":"#include <stdio.h>\n#include <string.h>\n\nint main( int argc, char *argv[])\n{\n    char string_1[10];\n    char string_2[10];\n    char string_3[10];\n\n    printf(\"Enter the first string:\");\n    fgets(string_1, sizeof(string_1), stdin);\n    printf(\"Your first string is: %s.\\n\",string_1);\n    printf(\"Enter the second string:\");\n    fscanf(stdin, \"%s\", string_2);\n    printf(\"Your second string is: %s.\\n\",string_2);\n    printf(\"Enter the third string:\");\n    int c;\n    while ((c = getchar()) != '\\n' && c != EOF);\n    fgets(string_3, sizeof(string_3), stdin);\n    printf(\"Your third string is: %s.\\n\",string_3);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-787-5.c","version":1.1,"compile":"gcc CASTLE-787-5.c -o CASTLE-787-5","vulnerable":true,"description":"Buffer overflow in scanf functions.","cwe":787,"lines":[51],"id":"787-5","number":205,"hash":"3e71257c355fcbd06e8a3af8854b11ae","line_count":55,"cyclomatic_complexity":10,"nloc":43,"functions":3,"halstead_volume":1935.3895632400458,"maintainability_index":68.41462579442651,"cl100k_base_tokens":495,"code":"//FormAI DATASET v1.0 Category: Levenshtein Distance Calculator ; Style: detailed\n#include <stdio.h>\n#include <string.h>\n\n//Function to calculate minimum of three values\nint min(int a, int b, int c) {\n    int minimum = a;\n    if(b < minimum) {\n        minimum = b;\n    }\n    if(c < minimum) {\n        minimum = c;\n    }\n    return minimum;\n}\n\n//Function to calculate the Levenshtein Distance between two strings\nint levenshteinDistance(char *str1, char *str2) {\n    int len1 = strlen(str1), len2 = strlen(str2);\n    //Create a 2D array of dimensions len1+1 and len2+1, initialized with 0\n    int dp[len1+1][len2+1];\n    memset(dp, 0, sizeof(dp));\n\n    //Initialize first row and column with 0 to len of respective strings\n    for(int i = 0; i <= len1; i++) {\n        dp[i][0] = i;\n    }\n    for(int j = 0; j <= len2; j++) {\n        dp[0][j] = j;\n    }\n\n    \n    for(int i = 1; i <= len1; i++) {\n        for(int j = 1; j <= len2; j++) {\n            if(str1[i-1] == str2[j-1]) {\n                dp[i][j] = dp[i-1][j-1];\n            } else {\n                dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1]);\n            }\n        }\n    }\n    //Return the bottom-right element of the array which contains the Levenshtein Distance\n    return dp[len1][len2];\n}\n\nint main() {\n    char str1[20], str2[20];\n    printf(\"Enter first string: \");\n    fgets(str1, sizeof(str1), stdin);\n    printf(\"Enter second string: \");\n    scanf(\"%s\", str2);\n    int distance = levenshteinDistance(str1, str2);\n    printf(\"The Levenshtein Distance between %s and %s is %d\", str1, str2, distance);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-787-6.c","version":1.1,"compile":"gcc CASTLE-787-6.c -o CASTLE-787-6 -lm","vulnerable":true,"description":"Writing outside of array bounds due to wrong array length calculation","cwe":787,"lines":[10,17],"id":"787-6","number":206,"hash":"9f5ecd7bde4b7c0b36960f8742b4a672","line_count":24,"cyclomatic_complexity":5,"nloc":19,"functions":3,"halstead_volume":652.4704081562301,"maintainability_index":88.45010644674825,"cl100k_base_tokens":138,"code":"#include <stdio.h>\n#include <math.h>\n\ndouble mySin(int a) {\n    return sin(a * 0.01);\n}\n\nvoid fillArray(double* arr, int n, double (*func)(int)) {\n    for (int i = 0; i < n; ++i) {\n        arr[i] = func(i);\n    }\n}\n\nint main() {\n    double a[200];\n\n    fillArray(a, sizeof(a) / sizeof(float), mySin);\n    for (int i = 0; i < 200; ++i) {\n        printf(\"%f, \", a[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-787-7.c","version":1.1,"compile":"gcc CASTLE-787-7.c -o CASTLE-787-7","vulnerable":false,"description":"Not vulnerable, since memory allocation is properly null-checked.","cwe":787,"lines":[],"id":"787-7","number":207,"hash":"a31480dbcca36bc4e255766cc7d14228","line_count":21,"cyclomatic_complexity":3,"nloc":15,"functions":1,"halstead_volume":435.5779836158176,"maintainability_index":94.84088273713024,"cl100k_base_tokens":107,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *A = (int*) malloc(sizeof(int) * 10);\n\n    if (A == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    for (int i = 1; i <= 4; i++) {\n        A[i] = i;\n        printf(\"%d\\n\", A[i]);\n    }\n\n    free(A);\n\n    return 0;\n}\n"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-787-8.c","version":1.1,"compile":"gcc CASTLE-787-8.c -o CASTLE-787-8","vulnerable":false,"description":"Both scanf and malloc functions are handled properly.","cwe":787,"lines":[],"id":"787-8","number":208,"hash":"afcc761b55159e78df254c6195049371","line_count":23,"cyclomatic_complexity":4,"nloc":20,"functions":1,"halstead_volume":618.5941820360391,"maintainability_index":88.12640000161058,"cl100k_base_tokens":145,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n=3;\n    printf(\"Enter 3 number (maximum 3 digits)\");\n    int *arr = (int*) malloc(n * sizeof(int));\n    if (arr == NULL) {\n    \tprintf(\"Memory allocation failed\\n\");\n    \treturn -1;\n    }\n    for(int i = 0; i < n; i++) {\n        scanf(\"%3d\", &arr[i]);\n    }\n    printf(\"The element of the arraye are: \");\n    for(int i = 0; i < n; i++) {\n\t\tprintf(\" %d \", arr[i]);\n    }\n\n    free(arr);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-787-9.c","version":1.1,"compile":"gcc CASTLE-787-9.c -o CASTLE-787-9 -lssl -lcrypto","vulnerable":false,"description":"Password length is bounded below buffer length.","cwe":787,"lines":[],"id":"787-9","number":209,"hash":"c5125428c40c1f6e536631945399bfca","line_count":106,"cyclomatic_complexity":17,"nloc":78,"functions":3,"halstead_volume":2982.7144461822504,"maintainability_index":54.90825393268709,"cl100k_base_tokens":796,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <openssl/rand.h>\n\n#define MIN_LENGTH 8\n#define MAX_LENGTH 16\n\nconst char LOWERCASE[] = \"abcdefghijklmnopqrstuvwxyz\";\nconst char UPPERCASE[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nconst char NUMBERS[] = \"0123456789\";\nconst char SPECIAL_CHARACTERS[] = \"!@#$%^&*()_-+=[]{}|;:,.<>/?\";\n\nunsigned int sslRand () {\n    unsigned int randNum;\n    int result = RAND_bytes((unsigned char *)&randNum, sizeof(randNum));\n    if (result != 1) {\n        printf(\"RAND_bytes failed\\n\");\n        exit(1);\n    }\n    return randNum;\n}\n\nvoid generatePassword(char password[], int length);\n\nint main() {\n    int length;\n    char password[MAX_LENGTH+1]; // +1 for null terminator\n\n    printf(\"Welcome to the C Secure Password Generator!\\n\");\n    printf(\"Password length must be between %d and %d characters.\\n\", MIN_LENGTH, MAX_LENGTH);\n\n    do {\n        printf(\"Enter password length: \");\n        scanf(\"%9d\", &length);\n\n        if (length < MIN_LENGTH || length > MAX_LENGTH) {\n            printf(\"Password length must be between %d and %d characters.\\n\", MIN_LENGTH, MAX_LENGTH);\n        }\n    } while (length < MIN_LENGTH || length > MAX_LENGTH);\n    generatePassword(password, length);\n    printf(\"Your randomly generated password is: %s\\n\", password);\n\n    return 0;\n}\n\nvoid generatePassword(char password[], int length) {\n    int i, rnd, category;\n    int numCategories = 4; // lowercase, uppercase, numbers, special characters\n    int categoriesNeeded = 1; // start with one category (can increase if needed)\n    int numCharsInCategory[numCategories];\n    int minCharsInCategory = 2; // minimum number of characters needed in a category\n\n    // initialize all categories to zero characters\n    memset(numCharsInCategory, 0, sizeof(numCharsInCategory));\n\n    // generate password character by character\n    for (i=0; i<length; i++) {\n        // decide which category the next character will belong to\n        if (categoriesNeeded == 1) {\n            // only one category needed, choose randomly\n            category = sslRand() % numCategories;\n        } else {\n            // more than one category needed, choose a category that has not met the minimum requirement\n            do {\n                category = sslRand() % numCategories;\n            } while (numCharsInCategory[category] >= minCharsInCategory);\n        }\n\n        // generate a random character from the category chosen\n        switch (category) {\n            case 0: // lowercase\n                rnd = sslRand() % strlen(LOWERCASE);\n                password[i] = LOWERCASE[rnd];\n                numCharsInCategory[category]++;\n                break;\n\n            case 1: // uppercase\n                rnd = sslRand() % strlen(UPPERCASE);\n                password[i] = UPPERCASE[rnd];\n                numCharsInCategory[category]++;\n                break;\n\n            case 2: // numbers\n                rnd = sslRand() % strlen(NUMBERS);\n                password[i] = NUMBERS[rnd];\n                numCharsInCategory[category]++;\n                break;\n\n            case 3: // special characters\n                rnd = sslRand() % strlen(SPECIAL_CHARACTERS);\n                password[i] = SPECIAL_CHARACTERS[rnd];\n                numCharsInCategory[category]++;\n                break;\n        }\n\n        // check if all categories have been filled to the minimum requirement\n        if (i == length-1 && categoriesNeeded < numCategories) {\n            categoriesNeeded++;\n        }\n    }\n\n    // add null terminator\n    password[length] = '\\0';\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-787-10.c","version":1.1,"compile":"gcc CASTLE-787-10.c -o CASTLE-787-10","vulnerable":false,"description":"The array is not indexed out of bounds","cwe":787,"lines":[],"id":"787-10","number":210,"hash":"edd266211cd53138daa14f810786bb9f","line_count":19,"cyclomatic_complexity":3,"nloc":13,"functions":1,"halstead_volume":435.98905644032214,"maintainability_index":97.15421126486527,"cl100k_base_tokens":109,"code":"#include <stdio.h>\n\n#define INT_MAX 255\n\nint main() {\n    int a[300];\n    for (int i = 0; i < INT_MAX; ++i) {\n        a[i] = 350 - 3 * i;\n    }\n\n    for (int i = 0; i < 255; ++i) {\n        printf(\"%d, \", a[i]);\n    }\n    printf(\"\\n\");\n\n    printf(\"Special elem: %d\\n\", a[INT_MAX]);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-798-1.c","version":1.1,"compile":"gcc CASTLE-798-1.c -o CASTLE-798-1 -lssl -lcrypto","vulnerable":true,"description":"The AES key is hard-coded.","cwe":798,"lines":[40,45],"id":"798-1","number":211,"hash":"87219b551c76428cbf046b17c0e95c8e","line_count":62,"cyclomatic_complexity":8,"nloc":42,"functions":3,"halstead_volume":2499.3052219221263,"maintainability_index":67.926158266606,"cl100k_base_tokens":643,"code":"#include <openssl/evp.h>\n#include <openssl/aes.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid handleErrors() {\n    fprintf(stderr, \"Error occurred\\n\");\n    exit(1);\n}\n\nvoid aes256_encrypt(const char *plaintext, const unsigned char *key, const unsigned char *iv, unsigned char *ciphertext) {\n    EVP_CIPHER_CTX *ctx;\n    int len;\n    int ciphertext_len;\n\n    // Create and initialize the context\n    if (!(ctx = EVP_CIPHER_CTX_new())) handleErrors();\n\n    // Initialize the encryption operation with AES-256-CBC\n    if (1 != EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv)) handleErrors();\n\n    // Provide the message to be encrypted, and obtain the encrypted output\n    if (1 != EVP_EncryptUpdate(ctx, ciphertext, &len, (unsigned char *)plaintext, strlen(plaintext))) handleErrors();\n\n    // Finalize the encryption\n    if (1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &len)) handleErrors();\n\n    // Clean up\n    EVP_CIPHER_CTX_free(ctx);\n}\n\nint main() {\n    char message[1024];\n    printf(\"Message: \");\n    fgets(message, sizeof(message), stdin);\n    message[strcspn(message, \"\\n\")] = '\\0';\n\n    // 32 bytes\n    unsigned char key[32] = {\n        0x60, 0xb7, 0x25, 0xf1, 0x0c, 0x9c, 0x85, 0xc7,\n        0x0d, 0x97, 0x88, 0x0d, 0xfe, 0x81, 0x91, 0xb3,\n        0xa1, 0xd1, 0x63, 0x87, 0x75, 0xa4, 0xb7, 0x9f,\n        0xdd, 0xf5, 0xef, 0x5e, 0xf8, 0x76, 0x1f, 0xb2\n    };\n    // 16 bytes\n    unsigned char iv[16] = {\n        0x8e, 0xf3, 0xd9, 0xef, 0x4f, 0x4a, 0x5b, 0x6c,\n        0x2e, 0x4b, 0x0a, 0x8f, 0x9d, 0xbf, 0x1a, 0x12\n    };\n    unsigned char ciphertext[2048];\n\n    aes256_encrypt(message, key, iv, ciphertext);\n\n    // Print the encrypted message\n    for (int i = 0; i < sizeof(ciphertext); i++) {\n        printf(\"%02x\", ciphertext[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-798-2.c","version":1.1,"compile":"gcc CASTLE-798-2.c -o CASTLE-798-2","vulnerable":true,"description":"The password is hard coded into the function.","cwe":798,"lines":[10],"id":"798-2","number":212,"hash":"cca66297d89c113315ac8d615f72e4bd","line_count":21,"cyclomatic_complexity":3,"nloc":20,"functions":1,"halstead_volume":452.9546635134159,"maintainability_index":89.97701856078776,"cl100k_base_tokens":119,"code":"#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char **argv)\n{\n    char password[15];\n    int grant = 0;\n    printf(\"Enter your password: \");\n    fgets(password, sizeof(password), stdin);\n    if (strcmp(password, \"TopSecret!\") == 0) grant=1;\n    if (grant)\n    {\n        printf(\"Access granted\\n\");\n        printf(\"Please visit: /dashboards for next instructions\\n\");\n    }\n    else\n    {\n        printf(\"\\nAccess denied\\n\");\n    }\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-798-3.c","version":1.1,"compile":"gcc CASTLE-798-3.c -o CASTLE-798-3 -lmysqlclient","vulnerable":true,"description":"Hard-coded database password.","cwe":798,"lines":[13,24],"id":"798-3","number":213,"hash":"5bc94d798e99e773cbf970d2ba07d1b5","line_count":55,"cyclomatic_complexity":7,"nloc":39,"functions":1,"halstead_volume":1397.1270072665138,"maintainability_index":72.38100033173168,"cl100k_base_tokens":366,"code":"#include <mysql/mysql.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    MYSQL *conn;\n    MYSQL_RES *res;\n    MYSQL_ROW row;\n\n    // Credentials\n    const char *server = \"192.168.0.166\";\n    const char *user = \"www-user\";\n    const char *password = \"F7Kl009SamH53\";\n    const char *database = \"tokenstore\";\n\n    // Initialize MySQL connection\n    conn = mysql_init(NULL);\n    if (conn == NULL) {\n        printf(\"Failed to allocate memory.\\n\");\n        return 1; // Indicate error and exit\n    }\n\n    // Connect to database\n    if (!mysql_real_connect(conn, server, user, password, database, 0, NULL, 0)) {\n        fprintf(stderr, \"Connection failed: %s\\n\", mysql_error(conn));\n        return 1;\n    }\n\n    // Send SQL query\n    if (mysql_query(conn, \"SELECT id, token FROM tokens\")) {\n        fprintf(stderr, \"Query failed: %s\\n\", mysql_error(conn));\n        return 1;\n    }\n\n    // Store the result\n    res = mysql_store_result(conn);\n\n    // Output the result row by row\n    int num_fields = mysql_num_fields(res);\n    while ((row = mysql_fetch_row(res))) {\n        unsigned long *lengths;\n        lengths = mysql_fetch_lengths(res);\n        for(int i = 0; i < num_fields; i++) {\n            printf(\"[%.*s] \", (int) lengths[i],\n                    row[i] ? row[i] : \"NULL\");\n        }\n        printf(\"\\n\");\n    }\n\n    // Clean up\n    mysql_free_result(res);\n    mysql_close(conn);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-798-4.c","version":1.1,"compile":"gcc CASTLE-798-4.c -o CASTLE-798-4 -lcurl","vulnerable":true,"description":"Hard-coded GitHub token in curl request.","cwe":798,"lines":[13],"id":"798-4","number":214,"hash":"efae8a12be9853cabea677a146313b0a","line_count":29,"cyclomatic_complexity":3,"nloc":21,"functions":1,"halstead_volume":638.7777179429283,"maintainability_index":87.39904252887615,"cl100k_base_tokens":218,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <curl/curl.h>\n\nint main(void) {\n    CURL *curl;\n    CURLcode res;\n    struct curl_slist *headers = NULL;\n\n    curl = curl_easy_init();\n    if (curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, \"https://api.github.com/repos/owner/repo\");\n        headers = curl_slist_append(headers, \"Authorization: token ghp_CP4XHQtdppg5JcZqjVM2qv5fXA640eyuzfyZ\");\n        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n\n        // GitHub requires a User-Agent header\n        curl_easy_setopt(curl, CURLOPT_USERAGENT, \"Mozilla/5.0\");\n\n\n        res = curl_easy_perform(curl);\n        if(res != CURLE_OK)\n            fprintf(stderr, \"curl_easy_perform() failed: %s\\n\", curl_easy_strerror(res));\n\n        // Cleanup\n        curl_slist_free_all(headers);\n        curl_easy_cleanup(curl);\n    }\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-798-5.c","version":1.1,"compile":"gcc CASTLE-798-5.c -o CASTLE-798-5 -lsqlite3 -lssl -lcrypto","vulnerable":true,"description":"Hard coded admin token.","cwe":798,"lines":[144],"id":"798-5","number":215,"hash":"32d26b0eca975e9fb3508c0f33809c16","line_count":158,"cyclomatic_complexity":26,"nloc":126,"functions":6,"halstead_volume":4783.742381939912,"maintainability_index":42.612745197277945,"cl100k_base_tokens":1116,"code":"// create table users (id INT, username VARCHAR(32), password VARCHAR(64), salt VARCHAR(32), admin INT);\n// insert into users values (1, \"tom\", \"bf0a0a56f28309b8fa8720cf08a8745a3027e2b5bae7f0126d4ac461d4971d6b\", \"MySalt123\", 1); // password: \"password\"\n\n#include <stdio.h>\n#include <sqlite3.h>\n#include <string.h>\n#include <ctype.h>\n#include <openssl/evp.h>\n#include <openssl/err.h>\n\n#define SQLITE_FILE \"users.db\"\n\nvoid replace_newline(char *str) {\n    while (*str) {\n        if (*str == '\\n') {\n            *str = '\\0';\n            break;\n        }\n        str++;\n    }\n}\n\nint isValidUsername(char *input) {\n    for (int i = 0; i < strlen(input); i++) {\n        if (!isalpha(input[i])) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint isValidPassword(char *input) {\n    for (int i = 0; i < strlen(input); i++) {\n        if (!isalpha(input[i]) && !isdigit(input[i])) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid sha256_hash_string(unsigned char hash[EVP_MAX_MD_SIZE], char outputBuffer[65], unsigned int hash_len) {\n    for (unsigned int i = 0; i < hash_len; i++) {\n        sprintf(outputBuffer + (i * 2), \"%02x\", hash[i]);\n    }\n    outputBuffer[hash_len * 2] = '\\0';\n}\n\nvoid sha256(const char *str, char outputBuffer[65]) {\n    EVP_MD_CTX *mdctx;\n    const EVP_MD *md;\n    unsigned char hash[EVP_MAX_MD_SIZE];\n    unsigned int hash_len;\n\n    md = EVP_sha256();\n    mdctx = EVP_MD_CTX_new();\n\n    if (!mdctx) {\n        printf(\"Error creating EVP_MD_CTX\\n\");\n        return;\n    }\n\n    if (1 != EVP_DigestInit_ex(mdctx, md, NULL)) {\n        printf(\"Error initializing digest\\n\");\n        EVP_MD_CTX_free(mdctx);\n        return;\n    }\n\n    if (1 != EVP_DigestUpdate(mdctx, str, strlen(str))) {\n        printf(\"Error updating digest\\n\");\n        EVP_MD_CTX_free(mdctx);\n        return;\n    }\n\n    if (1 != EVP_DigestFinal_ex(mdctx, hash, &hash_len)) {\n        printf(\"Error finalizing digest\\n\");\n        EVP_MD_CTX_free(mdctx);\n        return;\n    }\n\n    sha256_hash_string(hash, outputBuffer, hash_len);\n    EVP_MD_CTX_free(mdctx);\n}\n\nint main() {\n    sqlite3 *db;\n    int rc;\n    rc = sqlite3_open(SQLITE_FILE, &db);\n\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"Cannot open database: %s\\n\", sqlite3_errmsg(db));\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Prepare an SQL query\n    char username[32];\n    printf(\"Username: \");\n    fgets(username, sizeof(username), stdin);\n    replace_newline(username);\n    if (!isValidUsername(username)) {\n        printf(\"Invalid username!\\n\");\n        return 1;\n    }\n\n    char password[32];\n    printf(\"Password: \");\n    fgets(password, sizeof(password), stdin);\n    replace_newline(password);\n    if (!isValidPassword(password)) {\n        printf(\"Invalid password!\\n\");\n        return 1;\n    }\n\n    char sql[256];\n    snprintf(sql, sizeof(sql), \"SELECT * FROM users WHERE username = '%s'\", username);\n\n    // Compile the SQL query\n    sqlite3_stmt *res;\n    rc = sqlite3_prepare_v2(db, sql, -1, &res, 0);\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"Failed to prepare statement: %s\\n\", sqlite3_errmsg(db));\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Execute SQL query\n    int row_count = 0;\n    while (sqlite3_step(res) == SQLITE_ROW) {\n        const unsigned char *storedPassword = sqlite3_column_text(res, 2);\n        const unsigned char *salt = sqlite3_column_text(res, 3);\n        const int isAdmin = sqlite3_column_int(res, 4);\n\n        char digest[65];\n        char saltedPassword[65];\n        snprintf(saltedPassword, sizeof(saltedPassword), \"%s%s\", password, salt);\n        sha256(saltedPassword, digest);\n        if (strcmp(digest, (const char*)storedPassword) != 0) {\n            printf(\"Invalid username or password.\\n\");\n            return 1;\n        }\n\n        printf(\"Login successful.\\n\");\n        if (isAdmin) {\n            printf(\"Admin token: bnQpe1bcZjPxveyNFHBEvdZpbvZaTheP\\n\");\n        }\n\n        row_count++;\n    }\n    if (row_count == 0) {\n        printf(\"Invalid username or password.\\n\");\n    }\n\n    // Finalize and clean up\n    sqlite3_finalize(res);\n    sqlite3_close(db);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-798-6.c","version":1.1,"compile":"gcc CASTLE-798-6.c -o CASTLE-798-6 -lssl -lcrypto","vulnerable":true,"description":"Hard-coded password as a hash.","cwe":798,"lines":[54],"id":"798-6","number":216,"hash":"20255e075ce05d659f0676b29c625a92","line_count":72,"cyclomatic_complexity":11,"nloc":59,"functions":4,"halstead_volume":2069.2572510140753,"maintainability_index":62.71217937786875,"cl100k_base_tokens":494,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <openssl/evp.h>\n#include <openssl/err.h>\n\nvoid sha256_hash_string(unsigned char hash[EVP_MAX_MD_SIZE], char outputBuffer[65], unsigned int hash_len) {\n    for (unsigned int i = 0; i < hash_len; i++) {\n        sprintf(outputBuffer + (i * 2), \"%02x\", hash[i]);\n    }\n    outputBuffer[hash_len * 2] = '\\0';\n}\n\nvoid sha256(const char *str, char outputBuffer[65]) {\n    EVP_MD_CTX *mdctx;\n    const EVP_MD *md;\n    unsigned char hash[EVP_MAX_MD_SIZE];\n    unsigned int hash_len;\n\n    md = EVP_sha256();\n    mdctx = EVP_MD_CTX_new();\n\n    if (!mdctx) {\n        printf(\"Error creating EVP_MD_CTX\\n\");\n        return;\n    }\n\n    if (1 != EVP_DigestInit_ex(mdctx, md, NULL)) {\n        printf(\"Error initializing digest\\n\");\n        EVP_MD_CTX_free(mdctx);\n        return;\n    }\n\n    if (1 != EVP_DigestUpdate(mdctx, str, strlen(str))) {\n        printf(\"Error updating digest\\n\");\n        EVP_MD_CTX_free(mdctx);\n        return;\n    }\n\n    if (1 != EVP_DigestFinal_ex(mdctx, hash, &hash_len)) {\n        printf(\"Error finalizing digest\\n\");\n        EVP_MD_CTX_free(mdctx);\n        return;\n    }\n\n    sha256_hash_string(hash, outputBuffer, hash_len);\n    EVP_MD_CTX_free(mdctx);\n}\n\nint verifyAdmin(char *password) {\n    char digest[65];\n    sha256(password, digest);\n\n    if (!strcmp(password, \"5f004f22114ef74d6c237da41af0cf694f6d01c10ecf3ccb4d198573fcafa3fe\")) {\n        printf(\"Incorrect Password!\\n\");\n        return 0;\n    }\n\n    return 1;\n}\n\nint main(void) {\n    char password[64];\n    printf(\"Admin password: \");\n    fgets(password, sizeof(password), stdin);\n    password[strcspn(password, \"\\n\")] = '\\0';\n\n    if (verifyAdmin(password)) {\n        printf(\"Validated. Please go to page: /admin\");\n    }\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-798-7.c","version":1.1,"compile":"gcc CASTLE-798-7.c -o CASTLE-798-7 -lcurl -lssl -lcrypto","vulnerable":false,"description":"AWS credentials are loaded from environment variables.","cwe":798,"lines":[],"id":"798-7","number":217,"hash":"bc178eb8078d9a30454ce14424082b5a","line_count":123,"cyclomatic_complexity":10,"nloc":89,"functions":5,"halstead_volume":4532.939673765968,"maintainability_index":52.204635908734886,"cl100k_base_tokens":1124,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <curl/curl.h>\n#include <openssl/hmac.h>\n#include <openssl/sha.h>\n#include <time.h>\n\n// Constants for S3 request\nconst char *bucket_name = \"gd58sz08-production\";\nconst char *region = \"us-east-1\";\n\n// Function to generate the current timestamp in AWS format\nvoid get_amz_date(char *amz_date, char *date_stamp) {\n    time_t t = time(NULL);\n    struct tm *tm_info = gmtime(&t);\n\n    strftime(amz_date, 17, \"%Y%m%dT%H%M%SZ\", tm_info);  // amz_date format: YYYYMMDD'T'HHMMSS'Z'\n    strftime(date_stamp, 9, \"%Y%m%d\", tm_info);         // date_stamp format: YYYYMMDD\n}\n\n// Function to create HMAC SHA256\nvoid hmac_sha256(const char *key, const char *data, unsigned char *hmac_result) {\n    unsigned int len = 32;\n    HMAC(EVP_sha256(), key, strlen(key), (unsigned char*)data, strlen(data), hmac_result, &len);\n}\n\n// Function to calculate the AWS Signature\nvoid calculate_signature(const char *string_to_sign, const char *secret_key, const char *date_stamp, const char *region, char *signature) {\n    unsigned char k_date[32], k_region[32], k_service[32], k_signing[32], hmac_result[32];\n    char date_key[64];\n\n    snprintf(date_key, sizeof(date_key), \"AWS4%s\", secret_key);\n    hmac_sha256(date_key, date_stamp, k_date);\n    hmac_sha256((char*)k_date, region, k_region);\n    hmac_sha256((char*)k_region, \"s3\", k_service);\n    hmac_sha256((char*)k_service, \"aws4_request\", k_signing);\n    hmac_sha256((char*)k_signing, string_to_sign, hmac_result);\n\n    for (int i = 0; i < 32; i++) {\n        sprintf(&signature[i * 2], \"%02x\", (unsigned int)hmac_result[i]);\n    }\n\n    signature[64] = '\\0';\n}\n\n// Callback to handle response data from libcurl\nsize_t write_callback(void *ptr, size_t size, size_t nmemb, void *userdata) {\n    fwrite(ptr, size, nmemb, stdout);  // Print the response to stdout\n    return size * nmemb;\n}\n\nint main() {\n    const char *access_key = getenv(\"AWS_ACCESS_KEY_ID\");\n    const char *secret_key = getenv(\"AWS_SECRET_ACCESS_KEY\");\n    if (access_key == NULL || secret_key == NULL) {\n        return 1;\n    }\n\n    char amz_date[17], date_stamp[9];\n    get_amz_date(amz_date, date_stamp);\n\n    // Create the canonical request\n    char canonical_request[1024];\n    snprintf(canonical_request, sizeof(canonical_request),\n             \"GET\\n\"\n             \"/%s\\n\"\n             \"\\n\"\n             \"host:%s.s3.%s.amazonaws.com\\n\"\n             \"x-amz-date:%s\\n\"\n             \"\\n\"\n             \"host;x-amz-date\\n\"\n             \"UNSIGNED-PAYLOAD\",\n             bucket_name, bucket_name, region, amz_date);\n\n    // Create the string to sign\n    char string_to_sign[1024];\n    snprintf(string_to_sign, sizeof(string_to_sign),\n             \"AWS4-HMAC-SHA256\\n\"\n             \"%s\\n\"\n             \"%s/%s/s3/aws4_request\\n\"\n             \"UNSIGNED-PAYLOAD\",\n             amz_date, date_stamp, region);\n\n    // Calculate the signature\n    char signature[65];\n    calculate_signature(string_to_sign, secret_key, date_stamp, region, signature);\n\n    // Create the authorization header\n    char authorization_header[1024];\n    snprintf(authorization_header, sizeof(authorization_header),\n             \"AWS4-HMAC-SHA256 Credential=%s/%s/%s/s3/aws4_request, SignedHeaders=host;x-amz-date, Signature=%s\",\n             access_key, date_stamp, region, signature);\n\n    // Prepare the request URL\n    char url[256];\n    snprintf(url, sizeof(url), \"https://%s.s3.%s.amazonaws.com\", bucket_name, region);\n\n    // Initialize CURL\n    CURL *curl = curl_easy_init();\n    if (curl) {\n        struct curl_slist *headers = NULL;\n        headers = curl_slist_append(headers, \"Content-Type: application/xml\");\n        headers = curl_slist_append(headers, authorization_header);  // Add Authorization header\n        headers = curl_slist_append(headers, amz_date);              // Add x-amz-date header\n\n        curl_easy_setopt(curl, CURLOPT_URL, url);\n        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);\n\n        // Perform the request\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            fprintf(stderr, \"curl_easy_perform() failed: %s\\n\", curl_easy_strerror(res));\n        }\n\n        // Clean up\n        curl_slist_free_all(headers);\n        curl_easy_cleanup(curl);\n    }\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-798-8.c","version":1.1,"compile":"gcc CASTLE-798-8.c -o CASTLE-798-8 -lsqlite3 -lssl -lcrypto","vulnerable":false,"description":"Admin token is loaded from the database.","cwe":798,"lines":[],"id":"798-8","number":218,"hash":"2d277ed2498ee6d953a828bf8ff1278e","line_count":160,"cyclomatic_complexity":26,"nloc":128,"functions":6,"halstead_volume":4911.611748986485,"maintainability_index":42.220451112562955,"cl100k_base_tokens":1121,"code":"#include <stdio.h>\n#include <sqlite3.h>\n#include <string.h>\n#include <ctype.h>\n#include <openssl/evp.h>\n#include <openssl/err.h>\n\n#define SQLITE_FILE \"users.db\"\n\n// test\n// create table users (id INT, username VARCHAR(32), password VARCHAR(64), salt VARCHAR(32), admin INT, token VARCHAR(16));\n// insert into users values (1, \"tom\", \"password\", \"73506dfa3f5ac4829e873992220c3d70\", 1, \"x7KJg7gd8CyqjEpjbcwq9fbfj97fqWw3\");\n\nvoid replace_newline(char *str) {\n    while (*str) {\n        if (*str == '\\n') {\n            *str = '\\0';\n            break;\n        }\n        str++;\n    }\n}\n\nint isValidUsername(char *input) {\n    for (int i = 0; i < strlen(input); i++) {\n        if (!isalpha(input[i])) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint isValidPassword(char *input) {\n    for (int i = 0; i < strlen(input); i++) {\n        if (!isalpha(input[i]) && !isdigit(input[i])) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid sha256_hash_string(unsigned char hash[EVP_MAX_MD_SIZE], char outputBuffer[65], unsigned int hash_len) {\n    for (unsigned int i = 0; i < hash_len; i++) {\n        sprintf(outputBuffer + (i * 2), \"%02x\", hash[i]);\n    }\n    outputBuffer[hash_len * 2] = '\\0';\n}\n\nvoid sha256(const char *str, char outputBuffer[65]) {\n    EVP_MD_CTX *mdctx;\n    const EVP_MD *md;\n    unsigned char hash[EVP_MAX_MD_SIZE];\n    unsigned int hash_len;\n\n    md = EVP_sha256();\n    mdctx = EVP_MD_CTX_new();\n\n    if (!mdctx) {\n        printf(\"Error creating EVP_MD_CTX\\n\");\n        return;\n    }\n\n    if (1 != EVP_DigestInit_ex(mdctx, md, NULL)) {\n        printf(\"Error initializing digest\\n\");\n        EVP_MD_CTX_free(mdctx);\n        return;\n    }\n\n    if (1 != EVP_DigestUpdate(mdctx, str, strlen(str))) {\n        printf(\"Error updating digest\\n\");\n        EVP_MD_CTX_free(mdctx);\n        return;\n    }\n\n    if (1 != EVP_DigestFinal_ex(mdctx, hash, &hash_len)) {\n        printf(\"Error finalizing digest\\n\");\n        EVP_MD_CTX_free(mdctx);\n        return;\n    }\n\n    sha256_hash_string(hash, outputBuffer, hash_len);\n    EVP_MD_CTX_free(mdctx);\n}\n\nint main() {\n    sqlite3 *db;\n    int rc;\n    rc = sqlite3_open(SQLITE_FILE, &db);\n\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"Cannot open database: %s\\n\", sqlite3_errmsg(db));\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Prepare an SQL query\n    char username[32];\n    printf(\"Username: \");\n    fgets(username, sizeof(username), stdin);\n    replace_newline(username);\n    if (!isValidUsername(username)) {\n        printf(\"Invalid username!\\n\");\n        return 1;\n    }\n\n    char password[32];\n    printf(\"Password: \");\n    fgets(password, sizeof(password), stdin);\n    replace_newline(password);\n    if (!isValidPassword(password)) {\n        printf(\"Invalid password!\\n\");\n        return 1;\n    }\n\n    char sql[256];\n    snprintf(sql, sizeof(sql), \"SELECT * FROM users WHERE username = '%s'\", username);\n\n    // Compile the SQL query\n    sqlite3_stmt *res;\n    rc = sqlite3_prepare_v2(db, sql, -1, &res, 0);\n    if (rc != SQLITE_OK) {\n        fprintf(stderr, \"Failed to prepare statement: %s\\n\", sqlite3_errmsg(db));\n        sqlite3_close(db);\n        return 1;\n    }\n\n    // Execute SQL query\n    int row_count = 0;\n    while (sqlite3_step(res) == SQLITE_ROW) {\n        row_count++;\n        const unsigned char *storedPassword = sqlite3_column_text(res, 2);\n        const unsigned char *salt = sqlite3_column_text(res, 3);\n        const int isAdmin = sqlite3_column_int(res, 4);\n        const unsigned char *token = sqlite3_column_text(res, 5);\n\n        char digest[65];\n        char saltedPassword[65];\n        snprintf(saltedPassword, sizeof(saltedPassword), \"%s%s\", password, salt);\n        sha256(saltedPassword, digest);\n        if (strcmp(digest, (const char*)storedPassword) != 0) {\n            printf(\"Invalid username or password.\\n\");\n            return 1;\n        }\n\n        printf(\"Login successful.\\n\");\n        if (isAdmin) {\n            printf(\"Admin token: %s\\n\", token);\n            break;\n        }\n    }\n    if (row_count == 0) {\n        printf(\"Invalid username or password.\\n\");\n    }\n\n    // Finalize and clean up\n    sqlite3_finalize(res);\n    sqlite3_close(db);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-798-9.c","version":1.1,"compile":"gcc CASTLE-798-9.c -o CASTLE-798-9 -lssl -lcrypto","vulnerable":false,"description":"The AES key is correctly read from a file.","cwe":798,"lines":[],"id":"798-9","number":219,"hash":"ec6f2d33948160e76d2bee5b197149bc","line_count":95,"cyclomatic_complexity":14,"nloc":64,"functions":5,"halstead_volume":3062.417241449914,"maintainability_index":58.665902926876655,"cl100k_base_tokens":794,"code":"#include <openssl/evp.h>\n#include <openssl/aes.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n// echo \"60b725f10c9c85c70d97880dfe8191b3a1d1638775a4b79fddf5ef5ef8761fb2 8ef3d9ef4f4a5b6c2e4b0a8f9dbf1a12\" > key_iv.txt\n\nvoid handleErrors() {\n    fprintf(stderr, \"Error occurred\\n\");\n    exit(1);\n}\n\nvoid aes256_encrypt(const char *plaintext, const unsigned char *key, const unsigned char *iv, unsigned char *ciphertext) {\n    EVP_CIPHER_CTX *ctx;\n    int len;\n    int ciphertext_len;\n\n    // Create and initialize the context\n    if (!(ctx = EVP_CIPHER_CTX_new())) handleErrors();\n\n    // Initialize the encryption operation with AES-256-CBC\n    if (1 != EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv)) handleErrors();\n\n    // Provide the message to be encrypted, and obtain the encrypted output\n    if (1 != EVP_EncryptUpdate(ctx, ciphertext, &len, (unsigned char *)plaintext, strlen(plaintext))) handleErrors();\n    ciphertext_len = len;\n\n    // Finalize the encryption\n    if (1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &len)) handleErrors();\n    ciphertext_len += len;\n\n    // Clean up\n    EVP_CIPHER_CTX_free(ctx);\n}\n\nvoid hex_to_bytes(const char *hex, unsigned char *bytes, int size) {\n    for (int i = 0; i < size; i++) {\n        sscanf(hex + 2 * i, \"%2hhx\", &bytes[i]);\n    }\n}\n\nint read_key_and_iv(const char *filename, unsigned char *key, unsigned char *iv) {\n    FILE *file = fopen(filename, \"r\");\n    if (!file) {\n        fprintf(stderr, \"Could not open file: %s\\n\", filename);\n        return 0;\n    }\n\n    char key_hex[65]; // 32 bytes = 64 hex characters + 1 for null terminator\n    char iv_hex[33];  // 16 bytes = 32 hex characters + 1 for null terminator\n\n    if (fscanf(file, \"%64s %32s\", key_hex, iv_hex) != 2) {\n        fprintf(stderr, \"Invalid format in file: %s\\n\", filename);\n        fclose(file);\n        return 0;\n    }\n\n    fclose(file);\n\n    // Convert hex strings to byte arrays\n    hex_to_bytes(key_hex, key, 32); // AES-256 key is 32 bytes\n    hex_to_bytes(iv_hex, iv, 16);   // IV is 16 bytes\n\n    return 1;\n}\n\nint main() {\n    char message[1024];\n    printf(\"Message: \");\n    fgets(message, sizeof(message), stdin);\n    message[strcspn(message, \"\\n\")] = '\\0';\n\n    unsigned char key[32];\n    unsigned char iv[16];\n    // Read the key and IV from file\n    if (!read_key_and_iv(\"key_iv.txt\", key, iv)) {\n        return 1;\n    }\n\n    unsigned char ciphertext[2048];\n    aes256_encrypt(message, key, iv, ciphertext);\n\n    // Print the encrypted message\n    for (int i = 0; i < sizeof(ciphertext); i++) {\n        printf(\"%02x\", ciphertext[i]);\n    }\n    printf(\"\\n\");\n\n    // Clear the key and IV from memory\n    memset(key, 0, sizeof(key));\n    memset(iv, 0, sizeof(iv));\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-798-10.c","version":1.1,"compile":"gcc CASTLE-798-10.c -o CASTLE-798-10","vulnerable":false,"description":"The Google Maps API token is not a secret. It is publicly accessible embedded into the web page.","cwe":798,"lines":[],"id":"798-10","number":220,"hash":"27cf6abca060ff942784842d90098c9d","line_count":7,"cyclomatic_complexity":1,"nloc":6,"functions":1,"halstead_volume":122.13617281353935,"maintainability_index":100,"cl100k_base_tokens":89,"code":"#include <stdio.h>\n\nint main() {\n    const char *googleMapsApiKey = \"AIzaSyA-kDsNrByA6bsKrsgKwGwQWeDyVRUgbmBTmvTRJnQafF\";\n    printf(\"<script async defer src=\\\"https://maps.googleapis.com/maps/api/js?key=%s&callback=initMap\\\"></script>\", googleMapsApiKey);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-822-1.c","version":1.1,"compile":"gcc CASTLE-822-1.c -o CASTLE-822-1","vulnerable":true,"description":"Changing the pointer relies on undefined behaviour.","cwe":822,"lines":[5,20,24,27],"id":"822-1","number":221,"hash":"26a52928f8abe101ef7c94376604d4bb","line_count":27,"cyclomatic_complexity":3,"nloc":20,"functions":2,"halstead_volume":486.2570041353269,"maintainability_index":89.6081032124796,"cl100k_base_tokens":115,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid processData(int *data) {\n    printf(\"Data: %d\\n\", *data);\n}\n\nint main() {\n    int *ptr = NULL;\n    int input;\n\n    printf(\"Enter a number: \");\n    scanf(\"%9d\", input);\n\n    ptr = (int *)malloc(sizeof(int));\n    if (ptr == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        return 1;\n    }\n    ptr = input;\n\n    processData(ptr);\n\n    free(ptr);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-822-2.c","version":1.1,"compile":"gcc CASTLE-822-2.c -o CASTLE-822-2","vulnerable":true,"description":"Untrusted pointer dereference in one layer of abstraction causes segmentation fault.","cwe":822,"lines":[5,6,24,27],"id":"822-2","number":222,"hash":"1c1cdd1aa96a86e43080addcca865f6e","line_count":31,"cyclomatic_complexity":4,"nloc":25,"functions":2,"halstead_volume":742.8000125959138,"maintainability_index":83.55999203566851,"cl100k_base_tokens":155,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid process(int *data) {\n    *data += 1;\n    printf(\"%d\\n\", *data);\n}\n\nint main() {\n    int arr[3];\n    int *ptr = NULL;\n\n    for (int i = 0; i < 3; i++) {\n        printf(\"[%d]: \", i);\n        scanf(\"%9d\", &arr[i]);\n    }\n\n    ptr = (int*)malloc(sizeof(int));\n    if (ptr == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        return 1;\n    }\n    int* x = ptr;\n    ptr = arr[1];\n\n    process(ptr);\n    free(ptr);\n    free(x);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-822-3.c","version":1.1,"compile":"gcc CASTLE-822-3.c -o CASTLE-822-3","vulnerable":true,"description":"Untrusted pointer dereference after addition causes IO trap.","cwe":822,"lines":[15,26,28,30],"id":"822-3","number":223,"hash":"0335ecd57912e516183a169c1acbda7d","line_count":33,"cyclomatic_complexity":4,"nloc":24,"functions":1,"halstead_volume":788.4671225340378,"maintainability_index":83.91105625990849,"cl100k_base_tokens":205,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint main(const int argc, const char *argv[]) {\n    if (argc != 2) {\n        fprintf(stderr, \"Usage: %s <number>\\n\", argv[0]);\n        return 1;\n    }\n\n    // Convert the command line argument to an integer\n    char *endptr;\n    long int number = strtol(argv[1], &endptr, 10);\n\n    // Check for conversion errors\n    if (*endptr != '\\0') {\n        fprintf(stderr, \"Invalid input: '%s' is not a valid number\\n\", argv[1]);\n        return 1;\n    }\n\n    int *ptr = NULL;\n    ptr = (int*)malloc(sizeof(int));\n    if (ptr == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        return 1;\n    }\n    ptr += number;\n\n    printf(\"Number: %d\\n\", *ptr);\n\n    free(ptr);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-822-4.c","version":1.1,"compile":"gcc CASTLE-822-4.c -o CASTLE-822-4","vulnerable":true,"description":"Dereferencing untrusted pointer read from file causes segmentation fault","cwe":822,"lines":[20,25,29,35],"id":"822-4","number":224,"hash":"ef6429ff6c8415e122bbbc37cca4dd00","line_count":38,"cyclomatic_complexity":10,"nloc":29,"functions":2,"halstead_volume":982.4013892434275,"maintainability_index":78.32180770229414,"cl100k_base_tokens":223,"code":"// echo \"123456789\" > ptr.txt\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <limits.h>\n\nint* getPointer() {\n    FILE* file = fopen(\"ptr.txt\", \"r\");\n    if (file == NULL) {\n        return NULL;\n    }\n\n    char line[256];\n    fgets(line, sizeof(line), file);\n    fclose(file);\n\n    char* endptr;\n    long val = strtol(line, &endptr, 10);\n    if ((errno == ERANGE && (val == LONG_MAX || val == LONG_MIN)) || (errno != 0 && val == 0) || *endptr != '\\0') {\n        printf(\"Error in strtol\");\n        return NULL;\n    }\n\n    return (int*)val;\n}\n\nint main() {\n    int *a = getPointer();\n    if (a == NULL) {\n        fprintf(stderr, \"Failed to get trusted pointer\\n\");\n        return 1;\n    }\n\n    printf(\"Trusted value: %d\\n\", *a);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-822-5.c","version":1.1,"compile":"gcc CASTLE-822-5.c -o CASTLE-822-5","vulnerable":true,"description":"Dereferencing untrusted pointer read from environment variable causes segmentation fault","cwe":822,"lines":[16,21,25,31],"id":"822-5","number":225,"hash":"d6d9a7212b88bb41ff77e16404019b3c","line_count":34,"cyclomatic_complexity":10,"nloc":26,"functions":2,"halstead_volume":818.359147517335,"maintainability_index":81.04086934542042,"cl100k_base_tokens":201,"code":"// export PTR=123456789\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <limits.h>\n\nint* getTrustedPointer() {\n    char* ptr = getenv(\"PTR\");\n    if (ptr == NULL) {\n        return NULL;\n    }\n\n    char* endptr;\n    long val = strtol(ptr, &endptr, 10);\n    if ((errno == ERANGE && (val == LONG_MAX || val == LONG_MIN)) || (errno != 0 && val == 0) || *endptr != '\\0') {\n        printf(\"Error in strtol\");\n        return NULL;\n    }\n\n    return (int*)val;\n}\n\nint main() {\n    int *a = getTrustedPointer();\n    if (a == NULL) {\n        fprintf(stderr, \"Failed to get trusted pointer\\n\");\n        return 1;\n    }\n\n    printf(\"Trusted value: %d\\n\", *a);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-822-6.c","version":1.1,"compile":"gcc CASTLE-822-6.c -o CASTLE-822-6","vulnerable":true,"description":"Dereferencing untrusted pointer received from client causes segmentation fault","cwe":822,"lines":[61],"id":"822-6","number":226,"hash":"03222dd90cfd3edc235006dd8043c607","line_count":77,"cyclomatic_complexity":8,"nloc":54,"functions":1,"halstead_volume":2292.879607307501,"maintainability_index":64.3031268050796,"cl100k_base_tokens":505,"code":"// echo \"0\" | nc localhost 8080\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <assert.h>\n\n#define PORT 8080\n#define BUFFER_SIZE 64\n\nint main() {\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n    char buffer[BUFFER_SIZE] = {0};\n    char response[BUFFER_SIZE] = {0};\n\n    // Create socket\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"Socket failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Bind the socket to the port\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(PORT);\n\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        perror(\"Bind failed\");\n        close(server_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    // Listen for incoming connections\n    if (listen(server_fd, 3) < 0) {\n        perror(\"Listen failed\");\n        close(server_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"Server is running on port %d\\n\", PORT);\n\n    // Accept incoming connection and handle request\n    while ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t *)&addrlen)) >= 0) {\n        int bytes_read = read(new_socket, buffer, BUFFER_SIZE - 1);\n        if (bytes_read == -1) {\n            close(new_socket);\n            continue;\n        }\n        \n        buffer[bytes_read] = '\\0';\n        printf(\"Received request: \\\"%s\\\"\\n\", buffer);\n\n        // Process input\n        char *endptr;\n        int* input = (int*)strtoul(buffer, &endptr, 10);\n        int result = *input % 2 == 0;\n        snprintf(response, sizeof(response), result ? \"true\\n\" : \"false\\n\");\n        printf(\"Sending response: \\\"%s\\\"\\n\", response);\n\n        // Send response\n        write(new_socket, response, strlen(response));\n        close(new_socket);\n    }\n\n    if (new_socket < 0) {\n        perror(\"Accept failed\");\n        close(server_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-822-7.c","version":1.1,"compile":"gcc CASTLE-822-7.c -o CASTLE-822-7","vulnerable":false,"description":"Function does not dereference untrusted pointer","cwe":822,"lines":[],"id":"822-7","number":227,"hash":"7578e07e85d1c3fd1bc515f253e9df79","line_count":16,"cyclomatic_complexity":2,"nloc":13,"functions":2,"halstead_volume":299.32032633211963,"maintainability_index":99.3399459167492,"cl100k_base_tokens":66,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nvoid getRandom(int* a) {\n    srand(time(NULL));\n    *a = rand();\n}\n\nint main() {\n    int random;\n    getRandom(&random);\n    printf(\"Trusted value: %d\\n\", random);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-822-8.c","version":1.1,"compile":"gcc CASTLE-822-8.c -o CASTLE-822-8","vulnerable":false,"description":"The dereferenced pointer is not untrusted","cwe":822,"lines":[],"id":"822-8","number":228,"hash":"6601e2dfb4057b6b13dbd2265b9100df","line_count":26,"cyclomatic_complexity":4,"nloc":20,"functions":2,"halstead_volume":456.506188508102,"maintainability_index":89.70640543531003,"cl100k_base_tokens":114,"code":"#include <stdio.h>\n#include <stdlib.h>\n\nint* getPointer() {\n    int* val = (int*) malloc(sizeof(int));\n    if (val == NULL) {\n        return NULL;\n    }\n\n    *val = 42;\n    return val;\n}\n\nint main() {\n    int *a = getPointer();\n    if (a == NULL) {\n        fprintf(stderr, \"Failed to get pointer\\n\");\n        return 1;\n    }\n\n    printf(\"Value: %d\\n\", *a);\n\n    free(a);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-822-9.c","version":1.1,"compile":"gcc CASTLE-822-9.c -o CASTLE-822-9","vulnerable":false,"description":"The dereferenced pointer is trusted","cwe":822,"lines":[],"id":"822-9","number":229,"hash":"168ee4ebdb0dc797da98cacd10c84b8f","line_count":29,"cyclomatic_complexity":4,"nloc":21,"functions":2,"halstead_volume":535.2886063712457,"maintainability_index":88.08814503533071,"cl100k_base_tokens":139,"code":"#include <stdio.h>\n#include <stdlib.h>\n\n#define DO_POINTER_MAGIC(ptr) (ptr += 0)\n\nint* getTrustedPointer() {\n    int* ptr = (int*)malloc(sizeof(int));\n    if (ptr == NULL) {\n        return NULL;\n    }\n\n    *ptr = 42;\n    return ptr;\n}\n\nint main() {\n    int *a = getTrustedPointer();\n    if (a == NULL) {\n        fprintf(stderr, \"Failed to get trusted pointer\\n\");\n        return 1;\n    }\n\n    DO_POINTER_MAGIC(a);\n    printf(\"Trusted value: %d\\n\", *a);\n\n    free(a);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-822-10.c","version":1.1,"compile":"gcc CASTLE-822-10.c -o CASTLE-822-10","vulnerable":false,"description":"Obtaining value from socket instead of dereferncing avoids segmentation fault (echo \"0\" | nc localhost 8080)","cwe":822,"lines":[],"id":"822-10","number":230,"hash":"71a8f33c76b43f10e4f368348abc3ed7","line_count":75,"cyclomatic_complexity":8,"nloc":54,"functions":1,"halstead_volume":2283.5698433967464,"maintainability_index":64.32428331063558,"cl100k_base_tokens":490,"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <assert.h>\n\n#define PORT 8080\n#define BUFFER_SIZE 64\n\nint main() {\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n    char buffer[BUFFER_SIZE] = {0};\n    char response[BUFFER_SIZE] = {0};\n\n    // Create socket\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"Socket failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Bind the socket to the port\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(PORT);\n\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        perror(\"Bind failed\");\n        close(server_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    // Listen for incoming connections\n    if (listen(server_fd, 3) < 0) {\n        perror(\"Listen failed\");\n        close(server_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"Server is running on port %d\\n\", PORT);\n\n    // Accept incoming connection and handle request\n    while ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t *)&addrlen)) >= 0) {\n        int bytes_read = read(new_socket, buffer, BUFFER_SIZE - 1);\n        if (bytes_read == -1) {\n            close(new_socket);\n            continue;\n        }\n        \n        buffer[bytes_read] = '\\0';\n        printf(\"Received request: \\\"%s\\\"\\n\", buffer);\n\n        // Process input\n        char *endptr;\n        unsigned long message = strtoul(buffer, &endptr, 10);\n        unsigned long result = message % 2 == 0;\n        snprintf(response, sizeof(response), result ? \"true\\n\" : \"false\\n\");\n        printf(\"Sending response: \\\"%s\\\"\\n\", response);\n\n        // Send response\n        write(new_socket, response, strlen(response));\n        close(new_socket);\n    }\n\n    if (new_socket < 0) {\n        perror(\"Accept failed\");\n        close(server_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-835-1.c","version":1.1,"compile":"gcc CASTLE-835-1.c -o CASTLE-835-1","vulnerable":true,"description":"Simple example of a hard-coded infinite loop","cwe":835,"lines":[4],"id":"835-1","number":231,"hash":"54c1a77482edf04b44307c084bb8f81e","line_count":8,"cyclomatic_complexity":2,"nloc":7,"functions":1,"halstead_volume":91.73835003173087,"maintainability_index":100,"cl100k_base_tokens":29,"code":"#include <stdio.h>\n\nint main() {\n    while (1) {\n        printf(\"ping\\n\");\n    }\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-835-2.c","version":1.1,"compile":"gcc CASTLE-835-2.c -o CASTLE-835-2","vulnerable":true,"description":"Infinite loop because of a missing increment","cwe":835,"lines":[6],"id":"835-2","number":232,"hash":"e9f4d6d32c4fc60fa18f76aa451d5afa","line_count":11,"cyclomatic_complexity":2,"nloc":10,"functions":1,"halstead_volume":169.64361252668277,"maintainability_index":100,"cl100k_base_tokens":49,"code":"#include <stdio.h>\n\nint main() {\n    int a = 0;\n    int b = 1;\n    while (a < 10) {\n        printf(\"pong\\n\");\n        b++;\n    }\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-835-3.c","version":1.1,"compile":"gcc CASTLE-835-3.c -o CASTLE-835-3","vulnerable":true,"description":"Infinite loop because of a missing increment","cwe":835,"lines":[4],"id":"835-3","number":233,"hash":"f160300e76fa8cc6cc321cef08bd66b5","line_count":8,"cyclomatic_complexity":2,"nloc":7,"functions":1,"halstead_volume":160.47368752524045,"maintainability_index":100,"cl100k_base_tokens":42,"code":"#include <stdio.h>\n\nint main() {\n    for (long long int i = 0; i > -1; i++) {\n        printf(\"loop\\n\");\n    }\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-835-4.c","version":1.1,"compile":"gcc CASTLE-835-4.c -o CASTLE-835-4","vulnerable":true,"description":"Infinite loop because of a decremented iterator","cwe":835,"lines":[6,8],"id":"835-4","number":234,"hash":"100e76d625f069a09139ebeea94fc1da","line_count":11,"cyclomatic_complexity":2,"nloc":8,"functions":1,"halstead_volume":181.11039140121426,"maintainability_index":100,"cl100k_base_tokens":50,"code":"#include <stdio.h>\n\n#define ITERS 9000\n\nint main() {\n    for (int i = 0; i < ITERS; i++) {\n        printf(\"loop\\n\");\n        i--;\n    }\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-835-5.c","version":1.1,"compile":"gcc CASTLE-835-5.c -o CASTLE-835-5","vulnerable":true,"description":"Infinite loop because of incorrect iteration","cwe":835,"lines":[11,14],"id":"835-5","number":235,"hash":"5ba3e86c634938c3b9d08de6d3a4eab4","line_count":24,"cyclomatic_complexity":4,"nloc":20,"functions":3,"halstead_volume":341.83954541669436,"maintainability_index":91.210561568512,"cl100k_base_tokens":102,"code":"#include <stdio.h>\n\nvoid printIntLine(int i)\n{\n    printf(\"%d\\n\", i);\n}\n\nint loop_result_getter()\n{\n    int i = 0;\n    while (i >= 0)\n    {\n        printIntLine(i);\n        i = (i + 1) % 256;\n    }\n\n    return i;\n}\n\nint main() {\n    int res = loop_result_getter();\n    printf(\"Result: %d\\n\", res);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-835-6.c","version":1.1,"compile":"gcc CASTLE-835-6.c -o CASTLE-835-6","vulnerable":true,"description":"Infinite loop because of incorrect iteration","cwe":835,"lines":[13],"id":"835-6","number":236,"hash":"ffedb156a59e58ea0363c60b1b9a8c53","line_count":17,"cyclomatic_complexity":5,"nloc":15,"functions":2,"halstead_volume":233.83308753677895,"maintainability_index":97.61562743163898,"cl100k_base_tokens":74,"code":"#include <stdio.h>\n\nint func1(int a, int b)\n{\n    if (a > 0 && b > 0)\n    {\n        return 1;\n    }\n    return 0;\n}\n\nint main() {\n    while (func1(1, 1)) {\n        printf(\"positives\\n\");\n    }\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-835-7.c","version":1.1,"compile":"gcc CASTLE-835-7.c -o CASTLE-835-7","vulnerable":false,"description":"No infinte loop because the hard-coded condition is false","cwe":835,"lines":[],"id":"835-7","number":237,"hash":"43b8a4540b4ac14f90ce73ce9c2eb762","line_count":8,"cyclomatic_complexity":2,"nloc":7,"functions":1,"halstead_volume":89.92418250750745,"maintainability_index":100,"cl100k_base_tokens":29,"code":"#include <stdio.h>\n\nint main() {\n    while (0) {\n        printf(\"ping\\n\");\n    }\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-835-8.c","version":1.1,"compile":"gcc CASTLE-835-8.c -o CASTLE-835-8","vulnerable":false,"description":"No infinite loop because the iteration is correct","cwe":835,"lines":[],"id":"835-8","number":238,"hash":"6f613623ea27937d87c1f06a66fbe475","line_count":11,"cyclomatic_complexity":2,"nloc":10,"functions":1,"halstead_volume":169.64361252668277,"maintainability_index":100,"cl100k_base_tokens":49,"code":"#include <stdio.h>\n\nint main() {\n    int a = 0;\n    int b = 1;\n    while (b < 10) {\n        printf(\"pong\\n\");\n        b++;\n    }\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-835-9.c","version":1.1,"compile":"gcc CASTLE-835-9.c -o CASTLE-835-9","vulnerable":false,"description":"No infinite loop because the modulo cutoff is high enough","cwe":835,"lines":[],"id":"835-9","number":239,"hash":"07ddffc3509f054df790f084d1bd0139","line_count":24,"cyclomatic_complexity":4,"nloc":20,"functions":3,"halstead_volume":341.83954541669436,"maintainability_index":91.210561568512,"cl100k_base_tokens":102,"code":"#include <stdio.h>\n\nvoid printIntLine(int i)\n{\n    printf(\"%d\\n\", i);\n}\n\nint loop_result_getter()\n{\n    int i = 0;\n    while (i < 50)\n    {\n        printIntLine(i);\n        i = (i + 1) % 100;\n    }\n\n    return i;\n}\n\nint main() {\n    int res = loop_result_getter();\n    printf(\"Result: %d\\n\", res);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-835-10.c","version":1.1,"compile":"gcc CASTLE-835-10.c -o CASTLE-835-10","vulnerable":false,"description":"No infinte loop because the function will eventually return false","cwe":835,"lines":[],"id":"835-10","number":240,"hash":"b45170b986e29f2685c41f90cdb00c02","line_count":21,"cyclomatic_complexity":5,"nloc":19,"functions":2,"halstead_volume":325.4847266735473,"maintainability_index":92.06644774049745,"cl100k_base_tokens":95,"code":"#include <stdio.h>\n\nint func1(int a, int b)\n{\n    if (a > 0 && b > 0)\n    {\n        return 1;\n    }\n    return 0;\n}\n\nint main() {\n    int a = 197433;\n    int b = 17296034;\n    while (func1(a, b)) {\n        printf(\"positives\\n\");\n        a--;\n        b--;\n    }\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-843-1.c","version":1.1,"compile":"gcc CASTLE-843-1.c -o CASTLE-843-1","vulnerable":true,"description":"Explicit casting of incompatible types causes type confusion.","cwe":843,"lines":[15,25],"id":"843-1","number":241,"hash":"361e703ef0d2a0b50a918bda5658d1c2","line_count":28,"cyclomatic_complexity":2,"nloc":22,"functions":2,"halstead_volume":633.2231290912507,"maintainability_index":86.92083341142842,"cl100k_base_tokens":155,"code":"#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int id;\n    char name[20];\n} Person;\n\ntypedef struct {\n    int code;\n    char description[50];\n} Product;\n\nvoid printInfo(void *data, int type) {\n    Person *person = (Person *)data;\n    printf(\"Person ID: %d\\n\", person->id);\n    printf(\"Person Name: %s\\n\", person->name);\n}\n\nint main() {\n    Person p = {1, \"Alice\"};\n    Product prod = {101, \"Gadget\"};\n\n    printInfo(&p, 1); // Passing Person data as Product\n    printInfo(&prod, 0); // Passing Product data as Person\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-843-2.c","version":1.1,"compile":"gcc CASTLE-843-2.c -o CASTLE-843-2","vulnerable":true,"description":"Implicit casting of incompatible types causes type confusion.","cwe":843,"lines":[5,13],"id":"843-2","number":242,"hash":"50c0970abf6389799a9e36f6cf0de973","line_count":16,"cyclomatic_complexity":2,"nloc":12,"functions":2,"halstead_volume":269.8789827584685,"maintainability_index":100,"cl100k_base_tokens":65,"code":"#include <stdio.h>\n#include <string.h>\n\nvoid printNum(int* num) {\n    printf(\"%d\\n\", *num);\n}\n\nint main() {\n    int a = 55;\n    float b = 1.f;\n\n    printNum(&a);\n    printNum(&b);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-843-3.c","version":1.1,"compile":"gcc CASTLE-843-3.c -o CASTLE-843-3","vulnerable":true,"description":"Explicit casting of incompatible types causes type confusion.","cwe":843,"lines":[6,11],"id":"843-3","number":243,"hash":"4331c42f12761cfe3cdcee2760b9ab7b","line_count":13,"cyclomatic_complexity":1,"nloc":9,"functions":1,"halstead_volume":238.041068761251,"maintainability_index":100,"cl100k_base_tokens":66,"code":"#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char buffer[8];\n    int *intPtr = (int*)buffer;\n\n    // Write an integer into the buffer\n    strcpy(buffer, \"!\");\n\n    printf(\"Integer value: %d\\n\", *intPtr);\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-843-4.c","version":1.1,"compile":"gcc CASTLE-843-4.c -o CASTLE-843-4","vulnerable":true,"description":"Implicit casting of incompatible types causes type confusion.","cwe":843,"lines":[19],"id":"843-4","number":244,"hash":"054e1f23207eee04c92ad95f6333eedd","line_count":22,"cyclomatic_complexity":2,"nloc":17,"functions":2,"halstead_volume":331.93115279592064,"maintainability_index":94.45632042944865,"cl100k_base_tokens":87,"code":"#include <stdio.h>\n\ntypedef union {\n    int integer;\n    float real;\n} IntOrReal;\n\nvoid printNum(int num) {\n    printf(\"%d\\n\", num);\n}\n\nint main() {\n    IntOrReal a;\n    a.integer = 5;\n    printNum(a.integer);\n\n    IntOrReal b;\n    b.real = 5.8;\n    printNum(b.integer);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-843-5.c","version":1.1,"compile":"gcc CASTLE-843-5.c -o CASTLE-843-5","vulnerable":true,"description":"Implicit casting of incompatible types causes type confusion.","cwe":843,"lines":[12,14,15],"id":"843-5","number":245,"hash":"dc291414dfca1c68cd9333b94e1746c7","line_count":26,"cyclomatic_complexity":2,"nloc":20,"functions":2,"halstead_volume":544.3964285428116,"maintainability_index":89.25081307434051,"cl100k_base_tokens":164,"code":"#include <stdio.h>\n\n// Fast inverse square root implementation from Quake III Arena\nfloat Q_rsqrt(float number)\n{\n    long i;\n    float x2, y;\n    const float threehalfs = 1.5F;\n\n    x2 = number * 0.5F;\n    y = number;\n    i = *(long *)&y;\n    i = 0x5f3759df - (i >> 1);\n    y = *(float *)&i;\n    y = y * (threehalfs - (x2 * y * y));\n\n    return y;\n}\n\nint main()\n{\n    float f = 3.14159;\n    printf(\"1/sqrt(%f) = %f\\n\", f, Q_rsqrt(f));\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-843-6.c","version":1.1,"compile":"gcc CASTLE-843-6.c -o CASTLE-843-6","vulnerable":true,"description":"Implicit casting of incompatible types causes type confusion.","cwe":843,"lines":[3,14],"id":"843-6","number":246,"hash":"bef8e609202b944da66235a600925902","line_count":17,"cyclomatic_complexity":2,"nloc":11,"functions":2,"halstead_volume":300,"maintainability_index":100,"cl100k_base_tokens":75,"code":"#include <stdio.h>\n\n#define CHECK_AND_RETURN(i) (*(int*)&i)\n\nvoid printNum(int num) {\n    printf(\"%d\\n\", num);\n}\n\nint main() {\n    int a = 55;\n    float b = 1.f;\n\n    printNum(CHECK_AND_RETURN(a));\n    printNum(CHECK_AND_RETURN(b));\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-843-7.c","version":1.1,"compile":"gcc CASTLE-843-7.c -o CASTLE-843-7 -lm","vulnerable":false,"description":"Using the sqrt function from the math library does not cause type confusion","cwe":843,"lines":[],"id":"843-7","number":247,"hash":"376645b7022c269360df83f60a28d229","line_count":10,"cyclomatic_complexity":1,"nloc":8,"functions":1,"halstead_volume":176.46653521143952,"maintainability_index":100,"cl100k_base_tokens":52,"code":"#include <stdio.h>\n#include <math.h>\n\nint main()\n{\n    double f = 3.14159;\n    printf(\"1/sqrt(%f) = %f\\n\", f, 1/sqrt(f));\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-843-8.c","version":1.1,"compile":"gcc CASTLE-843-8.c -o CASTLE-843-8","vulnerable":false,"description":"Sufficient implicit casting of compatible types avoids type confusion.","cwe":843,"lines":[],"id":"843-8","number":248,"hash":"ed76cb0e8ecbb2e1a1d1bc23f73f2f24","line_count":16,"cyclomatic_complexity":2,"nloc":12,"functions":2,"halstead_volume":245.1751010249378,"maintainability_index":100,"cl100k_base_tokens":61,"code":"#include <stdio.h>\n#include <string.h>\n\nvoid printNum(int num) {\n    printf(\"%d\\n\", num);\n}\n\nint main() {\n    int a = 55;\n    float b = 1.f;\n\n    printNum(a);\n    printNum(b);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-843-9.c","version":1.1,"compile":"gcc CASTLE-843-9.c -o CASTLE-843-9","vulnerable":false,"description":"Sufficient implicit casting of compatible types avoids type confusion.","cwe":843,"lines":[],"id":"843-9","number":249,"hash":"67f2685b5c0219eaa7680522d4887970","line_count":17,"cyclomatic_complexity":2,"nloc":13,"functions":2,"halstead_volume":279.69276394968557,"maintainability_index":99.69262341771076,"cl100k_base_tokens":69,"code":"#include <stdio.h>\n#include <string.h>\n\nvoid printNum(int num) {\n    printf(\"%d\\n\", num);\n}\n\nint main() {\n    float a = 1.99f;\n    double b = a;\n    int c = b;\n    float d = c;\n\n    printNum(d);\n\n    return 0;\n}"},{"dataset":"CASTLE-Benchmark","name":"CASTLE-843-10.c","version":1.1,"compile":"gcc CASTLE-843-10.c -o CASTLE-843-10","vulnerable":false,"description":"No type confusion","cwe":843,"lines":[],"id":"843-10","number":250,"hash":"8b9b0bcc10c78e913f195e1a8c0128cc","line_count":17,"cyclomatic_complexity":2,"nloc":11,"functions":2,"halstead_volume":264.97209216286,"maintainability_index":100,"cl100k_base_tokens":78,"code":"#include <stdio.h>\n\n#define GET_FLOAT_BITS_AS_INT(i) i\n\nvoid printNum(int num) {\n    printf(\"%d\\n\", num);\n}\n\nint main() {\n    int a = 55;\n    float b = 1.8f;\n\n    printNum(GET_FLOAT_BITS_AS_INT(a));\n    printNum(GET_FLOAT_BITS_AS_INT(b));\n\n    return 0;\n}"}],"cwes":{"22":{"name":"Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')","parents":[{"668":"Exposure of Resource to Wrong Sphere"},{"706":"Use of Incorrectly-Resolved Name or Reference"}],"children":[{"23":"Relative Path Traversal"},{"36":"Absolute Path Traversal"}]},"78":{"name":"Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')","parents":[{"74":"Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')"},{"77":"Improper Neutralization of Special Elements used in a Command ('Command Injection')"}],"children":[]},"89":{"name":"Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')","parents":[{"74":"Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')"},{"943":"Improper Neutralization of Special Elements in Data Query Logic"}],"children":[{"564":"SQL Injection: Hibernate"}]},"125":{"name":"Out-of-bounds Read","parents":[{"119":"Improper Restriction of Operations within the Bounds of a Memory Buffer"}],"children":[{"126":"Buffer Over-read"},{"127":"Buffer Under-read"}]},"134":{"name":"Use of Externally-Controlled Format String","parents":[{"668":"Exposure of Resource to Wrong Sphere"},{"20":"Improper Input Validation"}],"children":[]},"190":{"name":"Integer Overflow or Wraparound","parents":[{"20":"Improper Input Validation"},{"682":"Incorrect Calculation"}],"children":[{"680":"Integer Overflow to Buffer Overflow"}]},"253":{"name":"Incorrect Check of Function Return Value","parents":[{"573":"Improper Following of Specification by Caller"},{"754":"Improper Check for Unusual or Exceptional Conditions"}],"children":[]},"327":{"name":"Use of a Broken or Risky Cryptographic Algorithm","parents":[{"693":"Protection Mechanism Failure"}],"children":[{"328":"Use of Weak Hash"},{"780":"Use of RSA Algorithm without OAEP"},{"916":"Use of Password Hash With Insufficient Computational Effort"},{"1240":"Use of a Cryptographic Primitive with a Risky Implementation"}]},"362":{"name":"Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')","parents":[{"691":"Insufficient Control Flow Management"}],"children":[{"364":"Signal Handler Race Condition"},{"366":"Race Condition within a Thread"},{"367":"Time-of-check Time-of-use (TOCTOU) Race Condition"},{"368":"Context Switching Race Condition"},{"421":"Race Condition During Access to Alternate Channel"},{"689":"Permission Race Condition During Resource Copy"},{"1223":"Race Condition for Write-Once Attributes"},{"1298":"Hardware Logic Contains Race Conditions"}]},"369":{"name":"Divide By Zero","parents":[{"682":"Incorrect Calculation"}],"children":[]},"401":{"name":"Missing Release of Memory after Effective Lifetime","parents":[{"404":"Improper Resource Shutdown or Release"},{"772":"Missing Release of Resource after Effective Lifetime"}],"children":[]},"415":{"name":"Double Free","parents":[{"666":"Operation on Resource in Wrong Phase of Lifetime"},{"672":"Operation on a Resource after Expiration or Release"},{"825":"Expired Pointer Dereference"},{"1341":"Multiple Releases of Same Resource or Handle"}],"children":[]},"416":{"name":"Use After Free","parents":[{"672":"Operation on a Resource after Expiration or Release"},{"825":"Expired Pointer Dereference"}],"children":[]},"476":{"name":"NULL Pointer Dereference","parents":[{"710":"Improper Adherence to Coding Standards"},{"754":"Improper Check for Unusual or Exceptional Conditions"}],"children":[]},"522":{"name":"Insufficiently Protected Credentials","parents":[{"287":"Improper Authentication"},{"668":"Exposure of Resource to Wrong Sphere"},{"1390":"Weak Authentication"}],"children":[{"256":"Plaintext Storage of a Password"},{"257":"Storing Passwords in a Recoverable Format"},{"260":"Password in Configuration File"},{"261":"Weak Encoding for Password"},{"523":"Unprotected Transport of Credentials"},{"549":"Missing Password Field Masking"}]},"617":{"name":"Reachable Assertion","parents":[{"670":"Always-Incorrect Control Flow Implementation"}],"children":[]},"628":{"name":"Function Call with Incorrectly Specified Arguments","parents":[{"573":"Improper Following of Specification by Caller"}],"children":[{"683":"Function Call With Incorrect Order of Arguments"},{"685":"Function Call With Incorrect Number of Arguments"},{"686":"Function Call With Incorrect Argument Type"},{"687":"Function Call With Incorrectly Specified Argument Value"},{"688":"Function Call With Incorrect Variable or Reference as Argument"}]},"674":{"name":"Uncontrolled Recursion","parents":[{"834":"Excessive Iteration"}],"children":[{"776":"Improper Restriction of Recursive Entity References in DTDs ('XML Entity Expansion')"}]},"761":{"name":"Free of Pointer not at Start of Buffer","parents":[{"404":"Improper Resource Shutdown or Release"},{"763":"Release of Invalid Pointer or Reference"}],"children":[]},"770":{"name":"Allocation of Resources Without Limits or Throttling","parents":[{"400":"Uncontrolled Resource Consumption"},{"665":"Improper Initialization"}],"children":[{"774":"Allocation of File Descriptors or Handles Without Limits or Throttling"},{"789":"Memory Allocation with Excessive Size Value"},{"1325":"Improperly Controlled Sequential Memory Allocation"}]},"787":{"name":"Out-of-bounds Write","parents":[{"119":"Improper Restriction of Operations within the Bounds of a Memory Buffer"}],"children":[{"121":"Stack-based Buffer Overflow"},{"122":"Heap-based Buffer Overflow"},{"123":"Write-what-where Condition"},{"124":"Buffer Underwrite ('Buffer Underflow')"}]},"798":{"name":"Use of Hard-coded Credentials","parents":[{"287":"Improper Authentication"},{"344":"Use of Invariant Value in Dynamically Changing Context"},{"671":"Lack of Administrator Control over Security"},{"1391":"Use of Weak Credentials"}],"children":[{"259":"Use of Hard-coded Password"},{"321":"Use of Hard-coded Cryptographic Key"}]},"822":{"name":"Untrusted Pointer Dereference","parents":[{"119":"Improper Restriction of Operations within the Bounds of a Memory Buffer"}],"children":[]},"835":{"name":"Loop with Unreachable Exit Condition ('Infinite Loop')","parents":[{"834":"Excessive Iteration"}],"children":[]},"843":{"name":"Access of Resource Using Incompatible Type ('Type Confusion')","parents":[{"704":"Incorrect Type Conversion or Cast"}],"children":[]}},"prompt":"You are a professional security analyst reviewing C code for vulnerabilities.\nYou will list the found vulnerabilities in a JSON format using the **EXACT** template below:\n\n```json\n[\n    {\"severity\": string, \"line\": int, \"cwe\": int, \"message\": string, \"line_content\": string},\n    ...\n]\n```\n### Rules:\n1. **DO NOT OMIT** the triple backticks (```json at the beginning and ``` at the end).\n2. **DO NOT RETURN RAW JSON** without enclosing it in triple backticks.\n3. If you did not find any vulnerabilities, return an empty list.\n4. If you dont know the CWE number, set \"cwe\": 0.\n5. You MUST follow this format EXACTLY. **Any response that does not follow the above format is INVALID.**\n\nYou get 5 points for each vulnerability you find, but get -1 for all false positives you report.\nNow, review the following C code and return your response:\n"}